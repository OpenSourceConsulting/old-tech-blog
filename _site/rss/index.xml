<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>오픈소스컨설팅 
기술 블로그
</title>
    <description>기술을 나눕니다. 함께 성장합니다.
Sharing Tech. Growing Together.
</description>
    <link>https://tech.osci.kr/</link>
    <atom:link href="https://tech.osci.kr/rss" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 30 Jul 2020 15:51:51 +0900</pubDate>
    <lastBuildDate>Thu, 30 Jul 2020 15:51:51 +0900</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>[Success Story] How IT team reduce the costs using Atlassian Marketplace App</title>
        <description>&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97475714/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp&quot; style=&quot;text-align: left;&quot;&gt;
 &lt;strong&gt;
  [Success Story] How IT team reduce the costs using Atlassian Marketplace App
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;h2 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-MiraeAssetLifeInsurancesavedabout34%ofITcostsusingtheFlexibleUserLicense&quot; style=&quot;text-align: left;&quot;&gt;
 &lt;strong&gt;
  Mirae Asset Life Insurance saved about 34% of IT costs using the Flexible User License
 &lt;/strong&gt;
&lt;/h2&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 The IT team plays an important role in driving the business growth and innovation of the company by quickly responding to the changing organization scales and market environment.
&lt;/p&gt;
&lt;p&gt;
 At the same time, they also consider reducing IT costs by eliminating unnecessary waste from their business.
&lt;/p&gt;
&lt;p&gt;
 Due to COVID-19 Pandemic, the pressure on IT team for more efficient IT costs and budget savings is growing.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Please read our customer story that how Mirae Asset Life Insurance, a leading financial company in Korea, has been able to reduce IT costs by 34% using Atlassian marketplace app - Flexible User License.
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97475714/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 Mirae Asset Life Insurance Co., Ltd. that is major life insurance company in Korea provides retirement design services through diverse insurance products.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  Company: Mirae Asset Life Insurance Co., Ltd.
 &lt;/li&gt;
 &lt;li&gt;
  Industry: Insurance
 &lt;/li&gt;
 &lt;li&gt;
  Company size: 34.5 trillion (2018)
 &lt;/li&gt;
 &lt;li&gt;
  Atlassian Products: Jira Software, Confluence , Bitbucket, Bamboo
 &lt;/li&gt;
 &lt;li&gt;
  Hosting type: Server
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-Challenge:Workcomplexityandresourcescontinuetogrow&quot; style=&quot;text-align: left;&quot;&gt;
 &lt;strong&gt;
  Challenge : Work complexity and resources continue to grow
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;p&gt;
 Various regulations in the financial industry and changes in the working environment have resulted in continuous increase in the complexity of work and resources under management. Mirae Asset Life Insurance needs a new ways of working, such as Agile and DevOps to improve work efficiency. At the same time, they were also concerned about ways to reduce IT costs. Mirae Asset Life Insurance was using 250 user tier of Jira and Confluence, but the number of users increased to more than 500 due to increment of inquiries.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-Solution:Respondquicklytothechangethenumberofusers&quot; style=&quot;text-align: left;&quot;&gt;
 &lt;strong&gt;
  Solution : Respond quickly to the change the number of users
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 &lt;span class=&quot;tlid-translation translation&quot; lang=&quot;en&quot;&gt;
  &lt;span title=&quot;&quot;&gt;
   The cost of purchasing all Atlassian products, including the marketplace app, was expected to increase significantly due to the increase in the number of users
  &lt;/span&gt;
  &lt;span title=&quot;&quot;&gt;
   , but
  &lt;/span&gt;
 &lt;/span&gt;
 &lt;strong&gt;
  Flexible User License
 &lt;/strong&gt;
 solved this issue instead of purchasing the additional user licenses. Mirae Asset Life Insurance has experienced a 34% cost savings. In addition, Flexible User License handles to maintain 250 user license at all times through the scheduler. They don't have to monitor the system, so it has been improved the convenience of administrator.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Flexible User License
 &lt;/strong&gt;
 is an efficient user license management app that solves the license shortage issue. The administrator does not need to manually deactivate the user, and the app setting allows automatically the assignment of the licenses to the unlicensed users when they log back in. So, they can respond quickly to the change the number of users. Flexible User License is a global-enterprise-proven app by our large enterprise clients in areas such as IT, manufacturing and finance.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97475714/2.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-Getstaredwithatrialforyourbusiness&quot;&gt;
 &lt;strong&gt;
  Get stared with a trial for your business
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;p class=&quot;fs20 fw300&quot;&gt;
   &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1222216&quot; rel=&quot;nofollow&quot;&gt;
    Flexible User License for Jira
   &lt;/a&gt;
  &lt;/p&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;p class=&quot;fs20 fw300&quot;&gt;
   &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1220252&quot; rel=&quot;nofollow&quot;&gt;
    Flexible User License for Confluence
   &lt;/a&gt;
  &lt;/p&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 Learn more about Flexible User License, please
 &lt;a class=&quot;external-link&quot; href=&quot;https://osci.kr/en/flex_user.php?utm_source=techblog&amp;amp;utm_medium=posting&amp;amp;utm_campaign=appsforeveryteam&amp;amp;utm_term=July_2020&quot; rel=&quot;nofollow&quot;&gt;
  visit our website
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 Or to see how to set up your own license management, please
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.youtube.com/watch?v=3TkVf6tI49A&quot; rel=&quot;nofollow&quot;&gt;
  see this guide video.
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-AboutOpenSourceConsulting...&quot;&gt;
 &lt;strong&gt;
  About Open Source Consulting...
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;p&gt;
 &lt;strong&gt;
  Open Source Consulting Inc.,
 &lt;/strong&gt;
 a platinum partner of Atlassian, has provided  ITSM and DevOps solutions to customers based on our technical experiences in technical/application/system architecture consulting and developments. We also developing and serving the marketplace apps that help customers use Atlassian more efficiently.
&lt;/p&gt;
&lt;p class=&quot;con-title tc&quot; style=&quot;text-align: left;&quot;&gt;
 &lt;span class=&quot;fs30&quot;&gt;
  Open Source Consulting is honored as
 &lt;/span&gt;
 ‘Atlassian Partner of the Year 2019 : Marketing Innovator’ for our outstanding contribution and achievements. This means that implementing the most creative and integrated marketing strategy has contributed to creating customer demand and improving market awareness in Atlassian.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97475714/3.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-[고객사례]IT팀이AtlassianMarketplaceApp을활용하여비용을절감하는방법&quot;&gt;
 [고객사례] IT팀이 Atlassian Marketplace App을 활용하여 비용을 절감하는 방법
&lt;/h2&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-FlexibleUserLicense앱을사용해IT비용의약34%를절감한미래에셋생명의사례를확인해보세요!&quot;&gt;
 &lt;strong&gt;
  Flexible User License 앱을 사용해 IT비용의 약 34%를 절감한 미래에셋생명의 사례를 확인해 보세요!
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 기업의 IT부서는 조직이 확장되고 변화하는 시장 환경에 신속하게 대응함으로써 기업의 비즈니스 성장과 혁신을 주도하는 중요한 역할을 하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 이와 동시에 기업의 불필요한 낭비를 없애 IT비용 절감이라는 미션을 수행해야 합니다.
&lt;/p&gt;
&lt;p&gt;
 최근 코로나 펜데믹 사태에 따라, IT부서에서도 보다 효율적인 IT비용 집행과 예산 절감에 대한 압박이 커지는 상황입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이 포스팅에서는 대표적인 생명보험 회사인
 &lt;strong&gt;
  미래에셋생명이 Atlassian Marketplace App - Flexible User License를 활용하여
 &lt;/strong&gt;
 &lt;strong&gt;
  어떻게 IT 비용을 34% 가량 절감할 수 있었는지
 &lt;/strong&gt;
 소개하고자 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97475714/4.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-Challenge:업무의복잡도및리소스의계속적인증가&quot; style=&quot;text-align: left;&quot;&gt;
 &lt;strong&gt;
  Challenge : 업무의 복잡도 및 리소스의 계속적인 증가
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;p&gt;
 금융권의 각종 규제와 업무 환경의 변화로 업무의 복잡도와 관리 대상 자원이 지속적으로 증가함에 따라, 미래에셋생명은 업무 효율을 개선하기 위한 Agile, DevOps와 같은 새로운 업무 방식이 필요했습니다. 이에 미래에셋생명은 전반적인 요청 관리 프로세스를 통합하는 ITSM 시스템을 아틀라시안 기반으로 새롭게 구축하였습니다. 미래에셋생명은 사용자 수 250명 기준의 Jira와 Confluence 제품을 사용 중이었는데, 점차 문의가 증가하면서 사용자 수도 계속해서 증가하는 상황이었기 때문에 어떻게 IT비용을 줄일 수 있을지에 대한 고민이 있었습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-Solution:사용자수증감에신속하게대응&quot; style=&quot;text-align: left;&quot;&gt;
 &lt;strong&gt;
  Solution: 사용자 수 증감에 신속하게 대응
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 미래에셋생명은 사용자 수가 500명 이상으로 증가함에 따라, 마켓플레이스 앱을 포함한 아틀라시안 전체 제품의 구매 비용이 대폭적으로 증가할 수 있는 상황이었습니다. 하지만 Flexible User License 앱 제품을 도입함으로써 문제를 해결할 수 있었습니다. 미래에셋생명은 라이선스를 추가적으로 구매하지 않고도 사용자 수를 모두 감당할 수 있게 됨으로써, 약 34%의 비용 절감 효과를 누리게 되었습니다.
&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 또한 Flexible User License 제품의 스케쥴러 기능을 통해 항상 250명의 유저 라이선스를 유지시킬 수 있습니다. 별도의 모니터링을 하지 않아도 되기 때문에 관리자의 편의성도 향상 시킬 수 있었습니다.
&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-FlexibleUserLicense?&quot; style=&quot;text-align: left;&quot;&gt;
 Flexible User License?
&lt;/h3&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 &lt;span&gt;
  Flexible User License는 라이선스 그룹의 사용자 수를 유연하게 관리할 수 있는 Atlassian marketplace app입니다. 쉽고 간단한
 &lt;/span&gt;
 &lt;span&gt;
  라이선스 관리를 통해 사용자 증감에 신속하게 대응하고 IT비용을 절감할 수 있습니다. Flexible User license 제품은 사용자 기반의 라이선스 자동 할당 및 삭제 기능을 제공하여,
 &lt;/span&gt;
 &lt;span&gt;
  관리자가 수동으로 사용자를 비활성화할 필요가 없으며 일정 기간 로그인 하지 않은 사용자가 다시 로그인할 때 자동으로 라이선스가 할당됩니다.
 &lt;/span&gt;
 &lt;span&gt;
  IT, 제조, 금융 등 많은 기업들이 Flexible User License 앱을 통해 효율적으로 라이선스 관리를 하고 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97475714/5.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 &lt;strong&gt;
  지금 바로 Atlassian Marketplace에서 Flexible User License 앱을 무료로 사용해 보세요!
 &lt;/strong&gt;
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1222216&quot; rel=&quot;nofollow&quot;&gt;
   [Atlassian Marketplace] Flexible User License for Jira
  &lt;/a&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1220252&quot; rel=&quot;nofollow&quot;&gt;
   [Atlassian Marketplace] Flexible User License for Confluence
  &lt;/a&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;span&gt;
   &lt;a class=&quot;external-link&quot; href=&quot;https://osci.kr/page/view.php?m_id=60&amp;amp;utm_source=techblog&amp;amp;utm_medium=posting&amp;amp;utm_campaign=appsforeveryteam&amp;amp;utm_term=July_2020&quot; rel=&quot;nofollow&quot;&gt;
    Flexible User License 제품 홈페이지 방문하기&amp;gt;&amp;gt;
   &lt;/a&gt;
  &lt;/span&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://osci.kr/page/view.php?m_id=60&amp;amp;utm_source=techblog&amp;amp;utm_medium=posting&amp;amp;utm_campaign=appsforeveryteam&amp;amp;utm_term=July_2020&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97475714/6.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Tue, 21 Jul 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/07/21/97475714/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/07/21/97475714/</guid>
        
        <category>atlassian</category>
        
        <category>atlassian-marketplace</category>
        
        <category>atlassian-customer-story</category>
        
        <category>atlassian-app</category>
        
        <category>cost-saving</category>
        
        <category>license-management</category>
        
        <category>atlassian-admin-tool</category>
        
        <category>atlassian-user-license</category>
        
        <category>apps-for-every-team</category>
        
        <category>atlassian-platinum-partner</category>
        
        <category>atlassian-partner-of-the-year</category>
        
        <category>open-source-consulting</category>
        
        
      </item>
    
      <item>
        <title>아틀라시안 마켓플레이스 소개 및 Jira Add-on 추천</title>
        <description>&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 안녕하세요!
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅의 아틀라시안팀입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 우리나라의 많은 기업들을 포함해 전세계의 150,000개가 넘는 기업들이 Atlassian의 솔루션을 통해서
&lt;/p&gt;
&lt;p&gt;
 업무 효율성을 개선하고 보다 혁신적인 팀워크를 이루고 있다는 것은 모두 잘 알고 계실 것 같아요.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Jira, Confluence
 &lt;/strong&gt;
 와 같은 협업 및 애자일 도구와
&lt;/p&gt;
&lt;p&gt;
 개발에서 운영, 서비스까지 통합하여 관리할 수 있도록 도와주는
 &lt;strong&gt;
  Jira Service Desk, OpsGenie, Bitbucket
 &lt;/strong&gt;
 등
&lt;/p&gt;
&lt;p&gt;
 Atlassian에서 제공하는 대표적인 제품들만으로도 '팀'을 위한 워크플로우를 개선하고 업무 생산성을 높일 수 있지만,
&lt;/p&gt;
&lt;p&gt;
 Atlassian Marketplace에 올라와 있는 다양한 Add-on(또는 Plugin) 제품들을 통해서 보다 확장된 기능을 구현하고 활용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Atlassian 제품을 사용하고 있지만 좀 더 높은 수준의 커스터마이징과 부가적인 기능을 원하시는 분들,
&lt;/p&gt;
&lt;p&gt;
 또는 Atlassian 솔루션의 도입을 계획하고 있는 분들께서는 본 포스팅을 주목해주세요
 &lt;img src=&quot;/assets/images/97469335/1.svg&quot;/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-AtlassianMarketplace란?&quot;&gt;
 Atlassian Marketplace 란?
&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;
 Atlssian Marketplace는 IT부터 HR팀까지, 모든 팀이 사용할 수 있는 Add-on을 구매할 수 있는 일종의 &quot;App Store&quot; 입니다.
&lt;/p&gt;
&lt;p&gt;
 Atlassian Marketplace에는 무려
 &lt;strong&gt;
  4,000개
  &lt;img src=&quot;/assets/images/97469335/2.svg&quot;/&gt;
 &lt;/strong&gt;
 가 넘는 Add-on이 있어요.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 먼저, Atlassian Marketplace(
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/&quot; rel=&quot;nofollow&quot;&gt;
  https://marketplace.atlassian.com/
 &lt;/a&gt;
 ) 페이지에 대해서 간략하게 소개해드릴게요.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/3.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 메인 페이지의 오른쪽의 필터기능을 통해서 구성하려는 제품, 카테고리등을 선택하면 그에 맞는 제품들만 추려서 탐색할 수 있고,
&lt;/p&gt;
&lt;p&gt;
 Marketplace에서도 자체적으로 새롭게 출시된 제품과 추천 Add-on 제품, 인기 제품들을  소개해주고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 앞서 말씀드린 것처럼 다양한 조직의 요구사항을 충족시켜 줄 강력한 도구들이 4000개가 넘게 있지만,
&lt;/p&gt;
&lt;p&gt;
 종류도 너무 많고 또 모든 내용이 영어로 기재되어 있어 정말 내가 원하는 Add-on을 찾기가 쉽지 않게 느껴지실 것 같아요.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 그래서
 &lt;img src=&quot;/assets/images/97469335/4.svg&quot;/&gt;
 많은 고객분들이 이미 사용하고 계시는 검증된 Add-on들을 추천해드리려고 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-1.ProjectManagement-WBS(WorkBreakdownStructure)&quot;&gt;
 1. Project Management - WBS(Work Breakdown Structure)
&lt;/h2&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-“프로젝트계획부터포트폴리오관리까지”&quot;&gt;
 &lt;em&gt;
  &lt;strong&gt;
   “
  &lt;/strong&gt;
  프로젝트 계획부터 포트폴리오 관리까지
  &lt;strong&gt;
   ”
  &lt;/strong&gt;
 &lt;/em&gt;
&lt;/h2&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/5.png&quot;/&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/6.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 하나의 프로젝트를 진행할 때 업무별, 파트별, 기간별 작업 리소스를 분배하고 진행 스케줄을 관리하기 위해서 WBS를 작성하는 것은 이미 익숙하실텐데요.
&lt;/p&gt;
&lt;p&gt;
 Jira 에서도 WBS 형식으로 프로젝트를 계획하고 관리할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 Gantt-Chart 기능을 활용하여 직접 작업을 작성하고 작업 진행률 및 마감일을 확인하여 프로젝트를 효율적으로 관리할 수 있어요.
&lt;/p&gt;
&lt;p&gt;
 Drag &amp;amp; Drop 형식으로 손쉬운 변경이 가능하고, Jira 이슈 연결을 생성하여 여러 이슈와 프로젝트를 관리할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 또한 MS Project와도 연동이 가능해서 MS Project의 작업을 가져오거나 내보낼 수 있도록 도와줍니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;img src=&quot;/assets/images/97469335/7.svg&quot;/&gt;
 &lt;strong&gt;
  추천 Add-on
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1213016/biggantt-gantt-chart-for-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/8.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1212259/bigpicture-project-management-ppm?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/9.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1211768/wbs-gantt-chart-for-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/10.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-2.JiraWorkflowManagement&quot;&gt;
 2. Jira Workflow Management
&lt;/h2&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-“효율적인워크플로우관리와업무자동화”&quot;&gt;
 &lt;em&gt;
  &lt;strong&gt;
   “
  &lt;/strong&gt;
  효율적인 워크플로우 관리와 업무 자동화
  &lt;strong&gt;
   ”
  &lt;/strong&gt;
 &lt;/em&gt;
&lt;/h2&gt;
&lt;p&gt;
 &lt;em&gt;
  &lt;strong&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/97469335/11.png&quot;/&gt;
   &lt;/span&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/97469335/12.png&quot;/&gt;
   &lt;/span&gt;
  &lt;/strong&gt;
 &lt;/em&gt;
&lt;/p&gt;
&lt;p&gt;
 커스터마이징과 자동화. 이 2가지 키워드 만으로도 많은 사용자께서 높은 관심을 보이실 것 같아요.
&lt;/p&gt;
&lt;p&gt;
 Atlassian Marketplace의 워크플로우 관련 Add-on을 통해서 Jira의 업무 프로세스를 자동화할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 또한 필드, 템플릿, 이슈의 인터페이스를 사용자가 원하는 방식으로 커스터마이징해서 효율성을 높여보세요.
&lt;/p&gt;
&lt;p&gt;
 서로 다른 워크플로우간의 연결도 가능하며, 필드 값 복사, 이슈 업데이트, 이슈 연결 등 다양한 Post Function을 제공합니다.
&lt;/p&gt;
&lt;p&gt;
 이슈를 복제하기 전에 원하는 필드의 값을 수정하고, 프로젝트와 이슈 유형을 복제하면서 조정할 수 있는 기능을 통해서,
&lt;/p&gt;
&lt;p&gt;
 시간을 절약하고 오류가 발생하는 것을 줄일 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;img src=&quot;/assets/images/97469335/13.svg&quot;/&gt;
 &lt;strong&gt;
  추천 Add-on
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/6820/scriptrunner-for-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/14.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/5048/jsu-automation-suite-for-jira-workflows?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/15.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/44043/clone-plus-for-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/16.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-3.UserManagement&quot;&gt;
 3. User Management
&lt;/h2&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-“JiraAdmin을위한효율적인사용자관리방안”&quot;&gt;
 &lt;em&gt;
  &lt;strong&gt;
   “
  &lt;/strong&gt;
  Jira Admin을 위한  효율적인 사용자 관리 방안
  &lt;strong&gt;
   ”
  &lt;/strong&gt;
 &lt;/em&gt;
&lt;/h2&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/17.png&quot;/&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/18.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 회사내의 특정 조직이나 팀뿐만 아니라 여러 협력사와의 협업, 대규모 조직의 전사적 사용 목적으로 사용자수가 증가하게 될 수록,
&lt;/p&gt;
&lt;p&gt;
 많게는 10,000명에 가까운 사용자를 관리하는 것이 Admin에게는 매우 큰 숙제로 느껴지실 것 같아요.
&lt;/p&gt;
&lt;p&gt;
 1,000명이 넘는 사용자를 보유한 조직이라면 Add-on을 통해서 사용자 증감에 대해 스케줄러 설정을 통해 알림을 받아보세요.
&lt;/p&gt;
&lt;p&gt;
 또한 활성 사용자를 식별하여 라이선스를 할당하고 오랫동안 활동이 없는 사용자는 삭제해주는 기능으로 쉽고 간단하게 라이선스를 관리할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;inline-comment-marker&quot; data-ref=&quot;930bb705-c753-449b-98b9-bd92adca4f97&quot;&gt;
  사용자 수가 유동적이고 급격하게 증가하게 될 경우 사용자 수를 유연하게 관리할 수 있도록 돕는 Add-on을 활용하시면,
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;inline-comment-marker&quot; data-ref=&quot;930bb705-c753-449b-98b9-bd92adca4f97&quot;&gt;
  유저 라이선스의 약 20% 내외정도는 추가 구매를 하지 않아도 사용자 수를 감당할 수 있어 시간과 비용을 절감할 수 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;inline-comment-marker&quot; data-ref=&quot;930bb705-c753-449b-98b9-bd92adca4f97&quot;&gt;
  (물론 장기적인 관점에서 사용자수가 계속해서 증가할 경우, User Tier를 올리는 것을 고려해야 겠지만요. ^^)
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 사용자 프로필도 좀 더 구체적이고 다채롭게 구성하여 원하는 동료를 빠르게 찾을 수 있다면 더욱 효율적으로 협업이 가능해집니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;img src=&quot;/assets/images/97469335/19.svg&quot;/&gt;
 &lt;strong&gt;
  추천 Add-on
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1222216/flexible-user-license-for-jira?hosting=server&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/97469335/20.png&quot;/&gt;
   &lt;/span&gt;
  &lt;/a&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1215285/user-management-for-jira?hosting=datacenter&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/97469335/21.png&quot;/&gt;
   &lt;/span&gt;
  &lt;/a&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1212508/user-profiles-for-jira?hosting=datacenter&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/97469335/22.png&quot;/&gt;
   &lt;/span&gt;
  &lt;/a&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-4.Theme&amp;amp;Style&quot;&gt;
 4. Theme &amp;amp; Style
&lt;/h2&gt;
&lt;h2 id='id-아틀라시안마켓플레이스소개및JiraAdd-on추천-&quot;우리조직에최적화된인터페이스구현&quot;'&gt;
 &lt;em&gt;
  &quot;우리 조직에 최적화된 인터페이스 구현&quot;
 &lt;/em&gt;
&lt;/h2&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/23.png&quot;/&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/24.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 Jira 뿐만 아니라 Atlassian 제품에서 우리 조직의 브랜드를 표현하고 최적화된 환경을 조성하고 싶다면, Atlassian Marketplace의 Add-on을 활용해보세요.
&lt;/p&gt;
&lt;p&gt;
 팀의 성격과 사용 목적에 따른 맞춤형 레이아웃과 스타일, 테마를 지정하여 사용자들이 보다 쉽고 친숙하게 이용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 향상된 검색 기능과 드롭 다운 형식의 메뉴 탐색을 통해서 유용한 리소스를 바로 찾을 수 있는 편리한 사이트 환경을 조성하세요.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 뿐만 아니라 스크린샷, 복잡한 표등을 삽입하고 내장된 템플릿이나 스타일을 통해 보다 풍부한 컨텐츠를 제작할 수 있으며,
&lt;/p&gt;
&lt;p&gt;
 프로젝트와 이슈 유형에 따라 템플릿을 만들어 생산성을 향상시키도록 도와줍니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;img src=&quot;/assets/images/97469335/25.svg&quot;/&gt;
 &lt;strong&gt;
  추천 Add-on
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1216711/refined-for-jira-sites-themes?hosting=datacenter&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/26.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1210768/jeditor-rich-text-editor-for-jira?hosting=datacenter&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/27.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-5.Integration&quot;&gt;
 5. Integration
&lt;/h2&gt;
&lt;h2 id='id-아틀라시안마켓플레이스소개및JiraAdd-on추천-&quot;다양한외부시스템/툴과의원활한통합&quot;'&gt;
 &lt;em&gt;
  &quot;다양한 외부 시스템/툴과의 원활한 통합&quot;
 &lt;/em&gt;
&lt;/h2&gt;
&lt;p&gt;
 Atlassian Marketplace에는 여러 외부 툴과의 원활한 연동과 통합을 도와주는 Add-on들이 많이 있어요.
&lt;/p&gt;
&lt;p&gt;
 우리 조직에서 이미 사용하고 있는 기존 시스템과 연동해서 보다 풍부하게 활용하고 한 곳에서 리소스를 편리하게 관리하세요.
&lt;/p&gt;
&lt;p&gt;
 &lt;img src=&quot;/assets/images/97469335/28.svg&quot;/&gt;
 &lt;strong&gt;
  추천 Add-on
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1216787/google-drive-docs-for-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/29.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1214214/connector-for-salesforce-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/30.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/4984/git-integration-for-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/31.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1213138/outlook-email-for-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/32.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1212130/saml-single-sign-on-sso-jira-saml-sso?hosting=datacenter&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/33.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1215229/bigtemplate-export-to-pdf-word-excel?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/34.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이 밖에도 Atlassian Marketplace에는 정말 다양하고 유용한 Add-on 들이 많이 있습니다!
&lt;/p&gt;
&lt;p&gt;
 Add-on을 통해서 더욱 다양하게 Atlassian 제품을 활용하기 위한 제품구성이나 금액이 궁금하시다면,
&lt;/p&gt;
&lt;p&gt;
 아래 연락처로 언제든지 편하게 문의해주세요.
 &lt;img src=&quot;/assets/images/97469335/35.svg&quot;/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(0,0,255);&quot;&gt;
  &lt;strong&gt;
   E-mail: atlassian
   &lt;a class=&quot;external-link&quot; href=&quot;mailto:atlassian@osci.kr&quot; rel=&quot;nofollow&quot; style=&quot;color: rgb(0,0,255);&quot;&gt;
    @
   &lt;/a&gt;
   osci.kr / Tel: 02-516-0711
  &lt;/strong&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 다음 포스팅에서는 Confluence 와 관련하여 매우 유용한 Add-on 들을 소개해드릴 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 감사합니다!
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Wed, 24 Jun 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/06/24/97469335/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/06/24/97469335/</guid>
        
        <category>atlassian</category>
        
        <category>아틀라시안</category>
        
        <category>marketplace</category>
        
        <category>jira</category>
        
        
      </item>
    
      <item>
        <title>[Container 시리즈] 05. Kuberbetes란?</title>
        <description>&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Confluence&quot; data-theme=&quot;Confluence&quot;&gt;쿠버네티스를 들어는봤는데... 컨테이너를 관리하는거라고 알고는 있는데...
정확히 이 녀석이 무엇을 하는건지 이해가 잘 안가는 분들을 위한 
Kubernetes 기초개념!&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  안녕하세요!
지난시간에 Container와 Docker에 대한 글을 작성하였었는데 Kubernetes가 과연 무엇인지?
왜 컨테이너를 이야기하면 쿠버네티스가 나오는지?
그럼 컨테이너와 쿠버네티스가 같은것인지?
이번시간에 자세히 다뤄보도록 하겠습니다!
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  지난글에서 설명드린 Container와 Docker가 기억나시나요?
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  예를들어 여러분이 새롭게 오픈한 신규 서비스가 있다고 가정해보겠습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  개발자들이 열씸히 코드를 개발하여 요즘 핫하디 핫한 컨테이너화 하게 구축을 한 후 서버에 이 컨테이너를 배포를 하였습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  대망의 오픈 첫날! 사용자가 신규 서비스로 접속을 하기 시작합니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  가장 떨리는 순간이죠
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  하지만? 너무나 핫한 신규서비스이기에 저희가 예측했던 사용자보다 훨씬 더 많은 사용자가 몰리기 시작하네요...
  &lt;br/&gt;
  즐거운 비명입니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  음... 사용자가 몰리니...
  &lt;br/&gt;
  scale out을 해야할 시점인 것 같습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  서버의 확장? 자신있습니다!
  &lt;br/&gt;
  클라우드 환경이라면 더더욱 간단하죠
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/2.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  서버를 확장하였어요!!!
 &lt;/p&gt;
 &lt;p&gt;
  근데 잠시만....
  &lt;br/&gt;
  저희 신규서비스는 컨테이너 환경인데......
  &lt;br/&gt;
  안에있는 컨테이너들은..... 어떻게 옮겨야하지....?
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/3.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  여차저차해서 새롭게 확장한 서버에 컨테이너를 가져왔습니다!!
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  하지만.....
  &lt;br/&gt;
  이렇게 가져온 컨테이너를 어떻게 적절하게 배치를 해야하는걸까요......
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  이렇게해서
  &lt;br/&gt;
  다수의 컨테이너를 관리해주는
  &lt;br/&gt;
  Container Orchestration 이라는 개념이 나오게 되었습니다!
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/4.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  즉,
  &lt;br/&gt;
  오케스트레이션 이란 단어를 들으면 다음의 이미지를 떠올리신 분들이 계시리라 생각되는데
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/5.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot; style=&quot;text-align: center;&quot;&gt;
 출처 : KBS 교향악단
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;br/&gt;
 저희 컨테이너 환경에서의 오케스트레이션은
 &lt;br/&gt;
 다음의 이미지라 생각하시면 조금 쉬우실 것 같습니다!
 &lt;br/&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/6.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;br/&gt;
 쿠버네티스도 이러한 컨테이너 오케스트레이션 중 하나의 툴인데
쿠버네티스 뿐만아니라, Docker Swarm, Rancher, Apache Mesos 등등 여러가지 툴이 존재하고 있습니다.
 &lt;p&gt;
  그중에서 이번 글에서는 대표적인, De facto(사실상 업계표준) Kubernetes에 대하여 알아보겠습니다!!
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/7.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#kubernetes란&quot; id=&quot;kubernetes란&quot;&gt;
   Kubernetes란?
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   Kubernetes
  &lt;/p&gt;
  &lt;blockquote&gt;
   &lt;p&gt;
    쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장가능한 오픈소스 플랫폼이다.
    &lt;br/&gt;
    쿠버네티스는 선언적 구성과 자동화를 모두 용이하게 해준다. 쿠버네티스는 크고, 빠르게 성장하는 생태계를 가지고 있다.
    &lt;br/&gt;
    쿠버네티스 서비스, 기술 지원 및 도구는 어디서나 쉽게 이용할 수 있다.
    &lt;br/&gt;
   &lt;/p&gt;
  &lt;/blockquote&gt;
 &lt;/blockquote&gt;
 &lt;blockquote&gt;
  &lt;blockquote&gt;
   &lt;p&gt;
    쿠버네티스란 명칭은 키잡이(helmsman)나 파일럿을 뜻하는 그리스어에서 유래했다.
    &lt;br/&gt;
    구글이 2014년에 쿠버네티스 프로젝트를 오픈소스화했다.
    &lt;br/&gt;
    쿠버네티스는 프로덕션 워크로드를 대규모로 운영하는 15년 이상의 구글 경험과 커뮤니티의 최고의 아이디어와 적용 사례가 결합되어 있다.
    &lt;br/&gt;
    &lt;del&gt;
     라고 kubernetes의 공식 문서에 나와있습니다 ㅎ_ㅎ
    &lt;/del&gt;
   &lt;/p&gt;
  &lt;/blockquote&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
  즉 쿠버네티스는 앞에서 설명드린대로 컨테이너를 관리를 위해 나온 오픈소스 플랫폼입니다! (갓구글이 만듬)
 &lt;/p&gt;
 &lt;p&gt;
  쿠버네티스 특징이라고 하면 굉장히 많은 정보들이 쏟아져 나오는데요
대표적으로 아래의 3가지 특징이 있습니다.
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/8.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  &lt;strong&gt;
   1. 확장성
  &lt;/strong&gt;
  &lt;br/&gt;
  Google에서 만든것의 명성에 걸맞게 일주일에 수십억 개의 컨테이너들을 운영하게 해준 경험에 따라 쿠버네티스가 디자인되었기 때문에, 손쉽게 확장될 수 있습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   2. 유연성
  &lt;/strong&gt;
  &lt;br/&gt;
  로컬 테스트, 프로덕트 운영이든 환경에 상관없이, 사용자의 복잡한 니즈를 모두 수용할 수 있는 유연성을 가지기에 사용자의 애플리케이션들을 끊임없고 쉽게 전달할 수 있습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   3. 이식성
  &lt;/strong&gt;
  &lt;br/&gt;
  쿠버네티스는 오픈소스로서 on-prem, 하이브리드, 또는 퍼블릭 클라우드 인프라스트럭처등 여러 환경에서 기동됩니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  그 밖에 수 많은 장점, 특징을 가지고 있는 쿠버네티스 이지만 굉장히 단순한 로직을 가지고있습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  현재상태를 모니터링하면서 관리자가 설정한 상태의 값과 다르면, 관리자가 설정한값으로 바꿔주는 3단계의 심플한 법칙
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  그렇기에 관리자는 명령어로 관리하는것이 아니라,
  &lt;strong&gt;
   설정한 값이 들어있는 yaml 파일
  &lt;/strong&gt;
  등으로 관리를 해 줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#kubernetes-workflow&quot; id=&quot;kubernetes-workflow&quot;&gt;
   Kubernetes workflow
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  쿠버네티스는 다음과 같은 흐름을 가지고 있습니다.
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/9.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  보통은 조직마다 다르겠지만 협업사 혹은 협업부서에서 서비스에 해당하는 요청을 관리자 에게 전달합니다.
  &lt;br/&gt;
  관리자는 이 명렁을
  &lt;strong&gt;
   Master Node
  &lt;/strong&gt;
  에 전달하고
  &lt;br/&gt;
  Master Node는
  &lt;strong&gt;
   Worker Node
  &lt;/strong&gt;
  에게 명령어를 전달함과 동시에 트래픽을 분배해줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  위와같은 다이어그램을 조금 더 자세히 살펴보자면
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/10.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  위와 같은 아키텍처가 나옵니다!
  &lt;br/&gt;
  기본적으로 쿠버네티스는 하나의 마스터노드와 여러개의 워커노드로 구성이 되어져있는데
  &lt;br/&gt;
  &lt;del&gt;
   굉장히 복잡하고 뭐가 내부에 있는지 궁금하지도, 알고싶지도 않게 생겼지만
  &lt;/del&gt;
  &lt;br/&gt;
  해당 아키텍처에 있는 Kubernetes의 컴포넌트에 대해서 하나하나 간략하게 살펴보겠습니다
  &lt;sup&gt;
   0
  &lt;/sup&gt;
  (해맑)
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#kubernetes-components&quot; id=&quot;kubernetes-components&quot;&gt;
   Kubernetes Components
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#master-node&quot; id=&quot;master-node&quot;&gt;
   Master Node
   &lt;br/&gt;
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  : 쿠버네티스의 주요 컨트롤 유닛으로서 Worker Nodes를 관리하는 주체입니다.
  &lt;br/&gt;
  클러스터에 관한 전반적인 결정을 하고 이벤트를 감지, 반응하는 역할을 합니다
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
   &lt;tr&gt;
    &lt;th align=&quot;left&quot;&gt;
     Component
    &lt;/th&gt;
    &lt;th align=&quot;left&quot;&gt;
     설명
    &lt;/th&gt;
   &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      Kubectl
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     -마스터 노드와 통신하는 명령어로서 쿠버네티스 API를 사용해서 마스터노드와 상호작용을 합니다.
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      API Server
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     - REST API 요청을 처리하고 쿠버네티스 클러스터를 구성하는 각 컴포넌트들과 통신을 담당합니다.
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      Scheduler
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     - 노드들의 리소스 상태를 파악하여 pod가 배치될 적절한 노드를 선택해 주는 역할.
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      Controller Manager
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     - 쿠버네티스 클러스터 상태 감시, 설정한 상태로 유지하는 역할.
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      ETCD
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     - 오픈소스 key-value 저장소로서 Kubernetes에서는 Master Node의 API Server가 HTTP/JSON API를 이용하여 접근할 수 있는 구성 데이터를 저장하는 용도로 사용됩니다.
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#worker-node&quot; id=&quot;worker-node&quot;&gt;
   Worker Node
   &lt;br/&gt;
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  : 워커노드는 할당된 task를 요청대로 수행하는 시스템입니다.
  &lt;br/&gt;
  예전에는 Minions 라고도 불렸으며 컨테이너들간의 네트워크 등 서비스에 필요한 전반적인 일들을 마스터 노드와 통신하며 수행합니다.
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
   &lt;tr&gt;
    &lt;th align=&quot;left&quot;&gt;
     Component
    &lt;/th&gt;
    &lt;th align=&quot;left&quot;&gt;
     설명
    &lt;/th&gt;
   &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      Kubelet
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     - 쿠버네티스 마스터 노드간의 통신을 담당하는 에이전트로서 노드에서 동작하는 pod들을 관리합니다
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      Kube-proxy
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     - 각 노드별로 탑재되며 네트워크 프록시 및 로드밸런서 역할을 해줍니다.
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      Pod
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     - Pod는 컨테이너의 그룹으로 한 개 또는 여러 개의 컨테이너를 포함하는 쿠버네티스의 작업단위 입니다.
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  각각의 컴포넌트들이 굉장히 복잡해 보이는데 조금 더 쉬운 다이어그램을 가지고 왔습니다.
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/11.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  Kuberenetes 도큐먼트에 한번쯤 들어가보셨다면 익숙하실 그림일겁니다.
 &lt;/p&gt;
 &lt;p&gt;
  조금더 쉽게 말씀드리자면,
  &lt;br/&gt;
  마스터노드는 쿠버네티스 클러스터를 관리하며
  &lt;br/&gt;
  워커노드는 실질적인 업무를 수행하는 주체입니다.
  &lt;del&gt;
   열일하는 worker node 친근하네요
  &lt;/del&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  또한 이 워커노드를 확대하면 오른쪽 다이어그램처럼 되는데요,
  &lt;br/&gt;
  워커노드안에는 pod가 들어가게 되고
  &lt;br/&gt;
  이 pod안에는 containerized된 application이 들어가게됩니다!
 &lt;/p&gt;
 &lt;p&gt;
  이 pod는 쿠버네티스의 가장작은 작업단위 요소로서,
  &lt;br/&gt;
  필요에 따라 쉽게 생성되고 쉽게 버려지는 비교적 짧은 수명을 가지는 것이 특징입니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  또한, 각각의 pod마다 다른 ip를 가지고 있고 pod 안에 있는 컨테이너끼리 는 내부 통신이 가능합니다.
  &lt;br/&gt;
  &lt;em&gt;
   (DNS로 통신 (coredns))
  &lt;/em&gt;
 &lt;/p&gt;
 &lt;p&gt;
  Pod안에 있는 컨테이너들 끼리 볼륨을 공유하며
  &lt;br/&gt;
  컨테이너가 죽고 재시작 되어도 pod가 살아있는 한 shared volume은 유지됩니다.
 &lt;/p&gt;
 &lt;p&gt;
  여러분의 Application을 컨테이너로 이쁘게 만들고 이를 사용자들에게 서비스를 하려면
  &lt;br/&gt;
  실질적으로 동일한 pod가 지속적으로 올라와져 있어야하는데요~
  &lt;br/&gt;
  (좀 전에 pod는 쉽게 죽는 특징을 가지고 있다고 했는데 ....)
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  우리의 쿠버네티스는 똑똑한 친구이니 이런 빅픽쳐를 계산해두었습니다.
  &lt;br/&gt;
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  어디에서 많이들어본...
  &lt;br/&gt;
  Replica Set, Deployment, Service, Ingress 등등
  &lt;br/&gt;
  모임에서 한번 쯤 들었던거같은 이름들..
  &lt;br/&gt;
  다음시간에는 이런 Kubernetes의 구성요소들에 대하여 더 깊게 알아보는 시간을 가지도록 하겠습니다!
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;del&gt;
   뜬금없지만
  &lt;/del&gt;
  다들 코로나 조심하세요!
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;div class=&quot;confluence-information-macro has-no-icon confluence-information-macro-information conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;info&quot;&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   참고 URL
  &lt;/p&gt;
  &lt;p&gt;
   Container Orchestration Image :
   &lt;a class=&quot;external-link&quot; href=&quot;https://www.awsforbusiness.com/what-is-container-orchestration/&quot; rel=&quot;nofollow&quot;&gt;
    https://www.awsforbusiness.com/what-is-container-orchestration/
   &lt;/a&gt;
  &lt;/p&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Sat, 06 Jun 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/06/06/97465347/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/06/06/97465347/</guid>
        
        <category>docker</category>
        
        <category>kubernetes</category>
        
        <category>k8s</category>
        
        <category>kubernetes기초</category>
        
        <category>container</category>
        
        
      </item>
    
      <item>
        <title>아틀라시안 클라우드 마이그레이션에 대한 10가지 오해와 진실</title>
        <description>&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97456877/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 안녕하세요, 오픈소스컨설팅 한진규상무입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 지라와 컨플루언스 같은 아틀라시안 제품을 사용할 때 아직은 직접 서버에 설치형으로 사용하시는 경우가 많은데요, 작년부터는 클라우드 제품을 활용하시는 분들이 늘어가는 것 같습니다.
&lt;/p&gt;
&lt;p&gt;
 최근 아틀라시안을 구매하는 신규 고객의 90%이상이 클라우드 제품을 사용하는 걸 보면, 앞으로는 클라우드 제품이 더 많은 비중을 차지 하지 않을까 하는 생각이 드네요.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아, 혹시 모르시는 분들을 위해 설명드리면, 아틀라시안의 대부분의 제품은 자사 서버에 설치 할 수 있는 설치형 제품(서버, 데이터센터)과 클라우드에 접속해서 사용할수 있는 클라우드형(SaaS) 제품 두가지로 공급이 되고 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 자, 그럼 본론으로 들어가서
&lt;/p&gt;
&lt;p&gt;
 오늘 이야기할 내용은, 아틀라시안 클라우드로 이전하는데 있어서 사람들이 흔히 알고 있는 오해와 그에 대한 진실에 대해 이야기 해보려고 합니다.
&lt;/p&gt;
&lt;p&gt;
 이 내용은 아틀라시안 블로그에 게재된 내용인데, 편안하게 읽으시라고
 &lt;s&gt;
  오역과
 &lt;/s&gt;
 의역을 담아 한글로 전달하는데 목적을 두고 적는 것이니,
 &lt;s&gt;
  오역과
 &lt;/s&gt;
 의역이 불편하신 경우 상큼하게 영어 원본을 읽으시길 권장 드립니다 ㅎㅎ
&lt;/p&gt;
&lt;p&gt;
 그 마음 충분히 이해하거든요. 워낙 발번역이라.....흠흠..
&lt;/p&gt;
&lt;p&gt;
 &lt;em&gt;
  &lt;strong&gt;
   원본 링크 :
  &lt;/strong&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/blog/platform/myths-about-moving-to-atlassian-cloud&quot; rel=&quot;nofollow&quot;&gt;
   https://www.atlassian.com/blog/platform/myths-about-moving-to-atlassian-cloud
  &lt;/a&gt;
 &lt;/em&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 일단 그럼 어떤 오해가 있는지 한번 알아볼까요?
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 오해1. 클라우드와 서버 제품은 동일하다.
&lt;/p&gt;
&lt;p&gt;
 오해2. 온프레미스(On-premise)가 클라우드보다 더 안전하게 데이터를 보관한다.
&lt;/p&gt;
&lt;p&gt;
 오해3. 온프레미스(On-premise) 관리 비용이 클라우드보다 더 싸다.
&lt;/p&gt;
&lt;p&gt;
 오해4. 대기업은 클라우드를 사용하지 않는다.
&lt;/p&gt;
&lt;p&gt;
 오해5. 운영서버 마이그레이션이 핵심이다.
&lt;/p&gt;
&lt;p&gt;
 오해6. 클라우드 마이그레션 전에 '정리'작업은 필요없다.
&lt;/p&gt;
&lt;p&gt;
 오해7. 클라우드에서는 애드온을 사용할 수 없다.
&lt;/p&gt;
&lt;p&gt;
 오해8. 애드온은 클라우드로 이관되지 않는다.
&lt;/p&gt;
&lt;p&gt;
 오해9. 클라우드 마이그레이션은 우리 조직의 니즈에 부합 할 만큼 유연하지 못하다.
&lt;/p&gt;
&lt;p&gt;
 오해10. 클라우드 마이그레이션은 우리 조직에서 수행하기에 너무 번거로운 일이다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 어떠세요? 맞다~ 맞다~ 하고 계신가요??
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 그렇다면 진실은 무엇일까요??
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해1.클라우드제품과서버제품은똑같은거아녀?지라가그놈이그놈이지....&quot;&gt;
 오해1. 클라우드제품과 서버제품은 똑같은거 아녀? 지라가 그놈이 그놈이지....
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아닙니다. 아틀라시안 클라우드 제품들이 서버 제품과 동일한 이점을 제공하긴 하지만 서버제품과는 기능과 고객경험에 있어서 약간의 차이가 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 즉, Jira Cloud 및 Confluence Cloud 고유의 차이점 뿐만 아니라 플랫폼 차이에서 오는 특징들이 있거든요.
&lt;/p&gt;
&lt;p&gt;
 일단, 클라우드 제품들은 서버제품과 메뉴바 등도 다르고, 애드온이나, 사용자관리 등 다양한 차이가 있습니다.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  Jira Cloud는 새로운 이슈보기 및 '차세대 프로젝트'를 제공하고 Confluence Cloud에는 서버제품에는 없는 새로운 페이지 편집기가 있습니다. 또한 iOS 및 Android 용 무료 모바일 앱을 사용하여 어디서나 이슈와 페이지에 쉽게 액세스하고 업데이트 할 수 있습니다. 특히, 차세대 프로젝트는 지라를 마치 트렐로처럼 쓸수 있게 해주는데요 즉, 복잡한 설정 없이 클릭만으로 워크플로우를 생성/편집/삭제 할 수 있어서 엄청 편리합니다. 서버제품에는 제공할 생각이 없는 듯 해서 좀 아쉽네요.
 &lt;/li&gt;
 &lt;li&gt;
  클라우드에서는 제품 관리 및 사용자 계정이 중앙 집중화되어 관리 됩니다. 저희가 서버 제품을 쓸때는 주로 크라우드(Crowd)라는 제품을 통해서 계정을 관리하는데요, 클라우드에서는 Atlassian Access라는 제품을 통해 비슷한 역할을 합니다. 하지만 좀 더 강력하죠. Atlassian Access는 Atlassian의 클라우드 제품 전체에 추가적인 엔터프라이즈급 보안 및 강화 된 관리 도구를 제공합니다. 클라우드 별 비용 플랜 및 청구 / 라이센스모델을 관리 할수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 이러한 기능을 익히는 가장 좋은 방법은 사용해 보는 거겠죠? 현재 서버 및 데이터센터 고객이라면, 해당 라이센스 기간동안
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  클라우드 평가판을 무료로 제공
 &lt;/span&gt;
 해 줍니다. (자세한 사항은 파트너사에 문의해 주세요)
&lt;/p&gt;
&lt;p&gt;
 그리고 저희 오픈소스컨설팅과 같은 파트너사를 통해서도 연단위/월단 빌링이 가능하기 때문에 담당자는 관리에 신경쓰지 않고 편하게 사용하실 수 있다는점. 다시한번 강조드립니다. ㅎㅎ
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해2.온프레미스(On-premise)가당연히클라우드보다더안전하게데이터를보관하겠지.중요한데이터는무조건온프레미스야!!마이프레셔~스~&quot;&gt;
 오해2. 온프레미스(On-premise)가 당연히 클라우드보다 더 안전하게 데이터를 보관하겠지. 중요한 데이터는 무조건 온프레미스야!! 마이 프레셔~스~
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아닙니다. Atlassian 클라우드 플랫폼의 핵심은 보안, 안정성, 개인 정보 및 규정 준수입니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 여러분의 회사가 Atlassian 클라우드로 전환하면, 그 순간부터 아틀라시안이 여러분 회사의 보안팀이 됩니다. 클라우드로 전환했을뿐인데, 보안팀이 딸려왔네? 요런느낌적인 느낌
&lt;/p&gt;
&lt;p&gt;
 Atlassian의 클라우드 제품은 전 세계적으로 업계에서 승인 된 규정 준수 및 데이터 개인 정보 보호 표준을 능가하며 전송 및 저장시 암호화를 통해 데이터를 보호하거든요.
&lt;/p&gt;
&lt;p&gt;
 Atlassian Access는 관리자에게 클라우드 제품을 사용하는 모든 사람을 파악하고 관리 할 수 있는 중앙 위치를 제공합니다.
&lt;/p&gt;
&lt;p&gt;
 그렇게 때문에 많은 기업이 마이그레이션의 첫 단계로 Atlassian Access에 가입합니다. 이를 통해 기존 클라우드 사용량에 대한 가시성이 향상되고 보안 기준이 설정됩니다.
&lt;/p&gt;
&lt;p&gt;
 Atlassian이 사용자를 보호하는 방법에 대해 자세히 알아 보려면
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/trust&quot; rel=&quot;nofollow&quot;&gt;
  Atlassian 보안 센터
 &lt;/a&gt;
 를 방문해보시길 권장합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해3.온프레미스(On-premise)관리비용이클라우드보다훨씬쌀껄?클라우드로가면비싸다던데...&quot;&gt;
 오해3. 온프레미스(On-premise) 관리 비용이 클라우드보다 훨씬 쌀껄? 클라우드로가면 비싸다던데...
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아닙니다. TCO (Total cost of ownership)로 보면 클라우드 제품이 온프레미스보다 저렴합니다. 온프레미스를 관리하는데 들어가는 숨은 비용이 많거든요.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97456877/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 클라우드로의 원활한 전환을 위해서 아틀라시안이 제공하는 비용절감 방안을 활용하는 것도 좋은 방법입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/cloud-migration/explore-cloud&quot; rel=&quot;nofollow&quot;&gt;
  무료 확장 클라우드 평가판 라이센스
 &lt;/a&gt;
 , 미사용 서버 메인터넌스 할인,
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/licensing/cloud/cloudmigrationfaq&quot; rel=&quot;nofollow&quot;&gt;
  기업 고객에 대한 로열티 요금정책
 &lt;/a&gt;
 등을 제공하고 있으며, 특히 학교나 비영리단체에는 할인된 가격으로 제품을 공급하고 있으니 참고하세요!
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해4.대기업은클라우드를사용하지않는다?&quot;&gt;
 오해4. 대기업은 클라우드를 사용하지 않는다?
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아닙니다. 많은 수의 대기업이 클라우드로 옮겨가고 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 포춘 500대 기업 중 80% 이상(ARM, Oracle 등)이 아틀라시안 클라우드 라이센스를 사용 중이며, 신규 고객의 90%가 클라우드 제품을 선택하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 아틀라시안의 Maren Hotvedt에 따르면,
&lt;/p&gt;
&lt;p&gt;
 그 어느때보다 많은 수의 Atlassian 서버 및 데이터센터 고객이 클라우드로 마이그레이션하고 있으며 새로운 엔터프라이즈 고객도 클라우드를 선택하고 있다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 소규모 고객만이 아니라, Redfin, Nestle, Lululemon, Pfizer, Unilever 등의 엔터프라이즈 회사도 많다고 하네요.
&lt;/p&gt;
&lt;p&gt;
 엔터프라이즈 마이그레이션에 대한 자세한 내용은 1,000유저 규모의 북미에 위치한 부동산 전문 회사
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/customers/redfin&quot; rel=&quot;nofollow&quot;&gt;
  Redfin이 최근 Atlassian 클라우드로 마이그레이션
 &lt;/a&gt;
 하고 6 만 달러 이상을 절약하여 경쟁력을 유지하고 미션에 집중할 수 있었던 사례를 확인해 보시기 바랍니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해5.운영서버마이그레이션이핵심이다?&quot;&gt;
 오해5. 운영서버 마이그레이션이 핵심이다?
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아닙니다. 오히려 계획 및 준비 과정이 마이그레이션에서 가장 크고 중요한 부분이며, 이러한 과정이 얼마나 잘 준비되느냐가 마이그레이션 성공에 가장 큰 영향을 미칩니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 특히, 여러 인스턴스를 통합하거나 많은 수의 앱이 설치된 경우 클라우드로 마이그레이션하는 데 6개월 이상이 걸릴 수 있어요.
&lt;/p&gt;
&lt;p&gt;
 이때 운영서버 이전은 하나의 과정일 뿐이며, 오히려 마이그레이션과 관련된 대부분의 작업은 운영서버  마이그레이션전과 마이그레이션 후에 유저들이 새로운 시스템에 적응하면서 이루어집니다.
&lt;/p&gt;
&lt;p&gt;
 그 과정을 살펴보면 다음과 같습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97456877/2.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해6.클라우드마이그레션전에'정리'작업은필요없다?&quot;&gt;
 오해6. 클라우드 마이그레션 전에 '정리'작업은 필요없다?
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아닙니다. 클라우드로 이전하기 전에 이주 전에 소위 말하는 &quot;봄맞이 대청소&quot;와 같은 시간을 갖는다면 훨씬 좋은 효과를 가질 수 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 많은 조직에서 마이그레이션 전 정리작업이 필수가 아니라 &quot;하면 좋은&quot;것 정도로 간주하는데요,  Atlassian 클라우드 마이그레이션 전에 자체 관리 형 인스턴스를 구성하는 것이 중요합니다. 여기에는 사용되지 않은 공간(Space) 및 프로젝트 아카이빙, 사용자 계정 정리, Add-on Test, 커스터마이징 검토 및 최소화, 중복 제거 및 사용되지 않은 스키마, 필드 및 이슈 유형 삭제가 포함됩니다.
&lt;/p&gt;
&lt;p&gt;
 이러한 봄맞이 대청소를 실시하면 두 가지 이점이 있습니다. 첫째, 마이그레이션을 더 빠르고 원활하게 하며, 둘째, 클라우드 마이그레이션이 완료되었을 때 시스템의 데이터 및 볼륨 감소 덕분에 성능도 향상되는 경우가 많습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해7.클라우드에서는앱(애드온)을사용할수없다.&quot;&gt;
 오해7. 클라우드에서는 앱(애드온)을 사용할 수 없다.
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아닙니다. 앱(아틀라시안에서는 애드온을 App이라고 표현) 개발자들은 더 좋고 더 많은 클라우드용 앱을 빠르게 만들어내고 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 Atlassian Marketplace는 클라우드 제품의 사용성 확장을 지원하는 1,000 개 이상의 앱을 클라우드 고객에게 제공합니다.
&lt;/p&gt;
&lt;p&gt;
 가장 인기있는 서버용 앱인 Insight Asset Management(자산관리), Jira Workflow Toolbox, JSU Automation for Jira, Structure(간트챠트 및 시각화 지원) 및 ConfiForms들은 이미 클라우드 버전을 공급하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 이 뿐이 아니라 매일 새로운 앱이 나옵니다. Atlassian은 2019 년에만 250 개의 새로운 클라우드 앱을 추가했습니다. 특히 내가 사랑하는 서버용 앱이 클라우드에는 아직 없을 경우 공급 업체에 문의하여 개발중인 제품을 확인하는 것이 좋습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해8.앱(애드온)은클라우드로이관되지않는다.&quot;&gt;
 오해8. 앱(애드온)은 클라우드로 이관되지 않는다.
&lt;/h2&gt;
&lt;p&gt;
 사실, 앱 마이그레이션은 Atlassian 및 앱 공급 업체의 주요 관심사입니다.
&lt;/p&gt;
&lt;p&gt;
 고객의 60 % 이상이 Atlassian Marketplace에서 앱을 사용하므로 마이그레이션 팀은 앱 평가 및 마이그레이션을 단순화하기 위해 노력하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 앱 평가 도구를 사용하면 서버의 앱 사용 공간과 사용량을보다 쉽게 ​​이해할 수 있습니다. 이 정보는 클라우드에서 필요할 앱에 대한 마이그레이션 계획을 작성하는 데 사용될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 Atlassian의 Migration Assistant 도구는 팀이 앱을 얼마나 자주 사용 하는지를 표시합니다.
&lt;/p&gt;
&lt;p&gt;
 클라우드 버전을 사용할 수 있으며 마이그레이션 경로가 있는지 여부 이 기능은 현재
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1219672/confluence-cloud-migration-assistant?hosting=server&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  Confluence Cloud Migration Assistant
 &lt;/a&gt;
 및
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1222010/jira-cloud-migration-assistant?hosting=server&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  Jira Cloud Migration Assistant
 &lt;/a&gt;
 에서 사용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 그러나 평가는 과정의 절반에 불과합니다.
&lt;/p&gt;
&lt;p&gt;
 현재 앱 데이터는 핵심 제품 데이터와 클라우드로 마이그레이션되지 않습니다. 앱 데이터 마이그레이션은 공급 업체와 직접 작업해야 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 이는 마이그레이션 계획 기간과 프로덕션 마이그레이션을 연장하고 복잡하게 만들 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  이러한 어려움을 완화하기 위해 Atlassian은 오버 헤드를 최소화하고 안정성을 극대화하는 앱 마이그레이션 도구를 개발하고 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해9.클라우드마이그레이션은우리조직의니즈에부합할만큼유연하지못하다.&quot;&gt;
 오해9. 클라우드 마이그레이션은 우리 조직의 니즈에 부합 할 만큼 유연하지 못하다.
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;color: rgb(255,0,0);&quot;&gt;
  아닙니다.
 &lt;/span&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  Atlassian은 조직이 원하는 속도로 클라우드로 이동하거나 단계별로 마이그레이션하거나 하이브리드 방식을 사용할 수 있는
  &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
   유연한 마이그레이션 도구를 공급하고 있습니다.
  &lt;/span&gt;
  &lt;br/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  처음에는 이러한 도구가 없어서 진짜 어려웠지만, 컨플루언스같은 경우는 거의 문제 없이 이관이 가능해졌고, 지라도 점점 마이그레이션 도구가 업데이트 되면서 상당부분 스트레스 받지 않고 마이그레이션이 가능하게 되었어요.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  아틀라시안에서 제공중인 무료 마이그레이션 도구 :
  &lt;br/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  ·
  &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1219672/confluence-cloud-migration-assistant?hosting=server&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
   Confluence Migration Assistant
  &lt;/a&gt;
  - 이 무료 서버 앱은 2018 년에 출시되었습니다. Confluence Server 또는 Data Center에서 클라우드로 데이터 및 사용자를 쉽게 마이그레이션 할 수 있습니다. 이 도구를 사용하여 관리자는 마이그레이션 대상, 방법 및시기를 선택할 수 있습니다.
  &lt;br/&gt;
  ·
  &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1222010/jira-cloud-migration-assistant?hosting=server&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
   Jira Cloud Migration Assistant
  &lt;/a&gt;
  - 조직은 사용자 및 그룹과 함께 프로젝트별로 Jira 인스턴스를 마이그레이션 할 수 있습니다. Migration Assistant는 조직이 클라우드 마이그레이션에보다 전략적으로 접근 할 수 있도록 도와줍니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97456877/3.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해10.클라우드마이그레이션은우리조직에서수행하기에너무번거로운일이다.&quot;&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  오해10. 클라우드 마이그레이션은 우리 조직에서 수행하기에 너무 번거로운 일이다.
 &lt;/span&gt;
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;http://www.osci.kr&quot; rel=&quot;nofollow&quot;&gt;
   오픈소스컨설팅
  &lt;/a&gt;
  과 같은 아틀라시안 파트너사는 이러한 문제를 해결하고 고객이 무리없이 클라우드로 이전할 수 있도록 기획 단계부터 컨설팅을 지원합니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  초기 단계에서 부터 함께 이야기를 나누다면, 더 완벽한 클라우드로의 이전이 가능해 집니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  이렇게 10가지 오해와 진실에 대해서 알아봤는데요, 클라우드제품도 편리하게 무료 트라이얼이 가능하니까 고민만 하지 마시고 한번 사용해보시길 권해 드립니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/ko/software/free&quot; rel=&quot;nofollow&quot;&gt;
   https://www.atlassian.com/ko/software/free
  &lt;/a&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  클라우드 사용 및 이전과 관련한 더 궁금한 사항은 오픈소스컨설팅으로 문의 주세요!
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;mailto:atlassian@osci.kr&quot; rel=&quot;nofollow&quot;&gt;
  atlassian@osci.kr
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Fri, 08 May 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/05/08/97456877/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/05/08/97456877/</guid>
        
        <category>아틀라시안</category>
        
        <category>atlassian</category>
        
        <category>cloud</category>
        
        
      </item>
    
      <item>
        <title>[Container 시리즈] 04. 실행중인 App 서비스를 컨테이너화 해보자!</title>
        <description>&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-information conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;info&quot;&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   Sample application으로 dockerized 하는 과정에 대해 기술
  &lt;/p&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  안녕하세요! 굉장히 오랜만에 블로그로 다시 찾아온 것 같습니다.
 &lt;/p&gt;
 &lt;p&gt;
  지난시간에 Docker의 기본적인 개념과 어떻게 동작했는지를 알아봤는데요,
  &lt;br/&gt;
  이번에는
  &lt;u&gt;
   실질적으로 사용하고있는 Application을 어떻게 Containerized 할지에 관련된 주제
  &lt;/u&gt;
  를 가지고 돌아왔습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;br/&gt;
 &lt;p&gt;
  &lt;strong&gt;
   순서는 다음과 같습니다.
  &lt;/strong&gt;
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;1. Source code clone
2. npm build
3. docker file 생성
4. docker file을 통한 docker image 생성
5. docker run을 이용한 컨테이너 실행
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#1-source-code-clone&quot; id=&quot;1-source-code-clone&quot;&gt;
   1. Source Code Clone.
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  해당 Source 들은 GitLab에 올려져 있으며.
  &lt;br/&gt;
  해당 애플리케이션 같은경우 Hostname과 현재 시간을 출력해주는 simple application입니다.
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  자 그럼 Giblab에 올려진 코드들을 가지고 와봅니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stl]# git clone http://192.168.197.132/root/stlapp.git
Cloning into 'stlapp'...
Username for 'http://192.168.197.132': kbseo
Password for 'http://kbseo@192.168.197.132': 
remote: Enumerating objects: 131, done.
remote: Counting objects: 100% (131/131), done.
remote: Compressing objects: 100% (69/69), done.
remote: Total 217 (delta 70), reused 112 (delta 56), pack-reused 86
Receiving objects: 100% (217/217), 564.33 KiB | 0 bytes/s, done.
Resolving deltas: 100% (84/84), done.
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  소스들을 서버로 잘 데리고 왔습니다.
  &lt;br/&gt;
  참고로 말씀드리자면 해당 Application은 React와 Spring Boot로 만들어졌고 maven을 통해 build하도록 되어져있습니다.
  &lt;br/&gt;
  추가로 Maven내에 npm build가 가능하도록 한 상태여서 maven 명령을 통해서 빌드가 가능합니다.
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#2-npm-build&quot; id=&quot;2-npm-build&quot;&gt;
   2. npm build
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# ./mvnw package
[INFO] Scanning for projects...
[INFO] 
[INFO] -------------------------&amp;lt; no.kantega:stlapp &amp;gt;--------------------------
[INFO] Building spring-and-react 0.1
[INFO] --------------------------------[ war ]---------------------------------
[INFO] 
[INFO] --- frontend-maven-plugin:1.6:install-node-and-npm (install node and npm) @ stlapp ---
[INFO] Installing node version v6.17.1
[INFO] Unpacking /root/.m2/repository/com/github/eirslett/node/6.17.1/node-6.17.1-linux-x64.tar.gz into /root/stl/stlapp/target/node/tmp
[INFO] Copying node binary from /root/stl/stlapp/target/node/tmp/node-v6.17.1-linux-x64/bin/node to /root/stl/stlapp/target/node/node
[INFO] Installed node locally.
[INFO] Installing npm version 3.10.10
[INFO] Unpacking /root/.m2/repository/com/github/eirslett/npm/3.10.10/npm-3.10.10.tar.gz into /root/stl/stlapp/target/node/node_modules
.....
[INFO] --- spring-boot-maven-plugin:2.0.1.RELEASE:repackage (default) @ stlapp ---
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 02:22 min
[INFO] Finished at: 2020-04-24T18:30:05+09:00
[INFO] ------------------------------------------------------------------------
[root@kbseo-test1 stlapp]# 

&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  빌드를 완료해주었습니다!
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#3-docker-file-생성&quot; id=&quot;3-docker-file-생성&quot;&gt;
   3. docker file 생성
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  이렇게 가지고 온 source를 컨테이너화 하기위하여 docker file을 먼저 생성해 줘야겠죠?
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# vim Dockerfile
FROM tomcat:8.5.50-jdk8-openjdk

MAINTAINER kbseo@osci.kr

ENV TZ=Asia/Seoul
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime

RUN rm -rf /usr/local/tomcat/webapps/ROOT
COPY target/stlapp-0.1.war /usr/local/tomcat/webapps/ROOT.war

&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  Simple application은 hostname과 time zone을 출력해주는 간단한 동작을 하는 애플리케이션 이기에
  &lt;br/&gt;
  docker file안에 timezone을 설정해주고 tomcat상에서 동작될 war파일을 복사해줍니다.
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#4-docker-file을-통한-docker-image-생성&quot; id=&quot;4-docker-file을-통한-docker-image-생성&quot;&gt;
   4. docker file을 통한 docker image 생성
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  이전 글에서 설정해드린것과 같이 docker는 image로 배포를 하기 때문에
  &lt;br/&gt;
  만들어두었던 docker file을 image화 해 줍니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;# 현재 가지고있는 이미지가 있나 확인을 해줍니다
[root@kbseo-test1 stlapp]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
[root@kbseo-test1 stlapp]# 
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  이미지가 한개도 없는것을 확인하실수 있습니다.
 &lt;/p&gt;
 &lt;p&gt;
  이미지 형태로 빌드를 해줍니다!
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker build -t stlapp:1.0 .
Sending build context to Docker daemon 252.2 MB
Step 1/6 : FROM tomcat:8.5.50-jdk8-openjdk
Trying to pull repository docker.io/library/tomcat ... 
8.5.50-jdk8-openjdk: Pulling from docker.io/library/tomcat
dc65f448a2e2: Pull complete 
346ffb2b67d7: Pull complete 
dea4ecac934f: Pull complete 
8ac92ddf84b3: Pull complete 
d8ef64070a18: Pull complete 
6577248b0d6e: Pull complete 
576c0a3a6af9: Pull complete 
6e0159bd18db: Pull complete 
944191e51caa: Pull complete 
9ee6a5ca751e: Pull complete 
Digest: sha256:d53c2079ea67db92f6d7c39e9450f641610336016fdddef5392c5afd41518e5e
Status: Downloaded newer image for docker.io/tomcat:8.5.50-jdk8-openjdk
 ---&amp;gt; b56d8850aed5
Step 2/6 : MAINTAINER jacobbaek@osci.kr
 ---&amp;gt; Running in 148cd746d772
 ---&amp;gt; 3b0a94a52842
Removing intermediate container 148cd746d772
Step 3/6 : ENV TZ Asia/Seoul
 ---&amp;gt; Running in 7398ad9609a2
 ---&amp;gt; 706e8669d2d6
Removing intermediate container 7398ad9609a2
Step 4/6 : RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime
 ---&amp;gt; Running in 1bcb6e658984

 ---&amp;gt; 453ac37a79dd
Removing intermediate container 1bcb6e658984
Step 5/6 : RUN rm -rf /usr/local/tomcat/webapps/ROOT
 ---&amp;gt; Running in f3c3bf4eb17b

 ---&amp;gt; 32f3bddc0334
Removing intermediate container f3c3bf4eb17b
Step 6/6 : COPY target/stlapp-0.1.war /usr/local/tomcat/webapps/ROOT.war
 ---&amp;gt; 3f24f0f7deaa
Removing intermediate container 134e07409a14
Successfully built 3f24f0f7deaa
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  docker build 같은경우 지난시간의 글에서 좀 더 자세히 확인 가능하십니다 ㅎ.ㅎ
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  명령어에 대해서 간단히 설명을 다시 드리자면,
  &lt;br/&gt;
  &lt;strong&gt;
   $ docker build &amp;lt;옵션&amp;gt; &amp;lt;dockerfile 경로&amp;gt;
  &lt;/strong&gt;
  &lt;br/&gt;
  저는 태그를 지정해주기 위하여 -t옵션을 사용해주었습니다.
  &lt;br/&gt;
  태그는 &amp;lt;저장소이름&amp;gt;/&amp;lt;이미지이름&amp;gt;:&amp;lt;태그&amp;gt; 형식입니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  다시 이미지를 확인해보면 좀전에 build한 이미지가 올라온 것을 확인 하실 수 있습니다!
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker images
REPOSITORY          TAG                   IMAGE ID            CREATED             SIZE
stlapp              1.0                   3f24f0f7deaa        3 minutes ago       545 MB
docker.io/tomcat    8.5.50-jdk8-openjdk   b56d8850aed5        2 months ago        529 MB
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  어라? 왜 두개의 이미지가 올라가져있을까요....?
분명히 도커 빌드는 한번만 실행했는데..
도커파일을 다시 살펴볼까요?
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;FROM tomcat:8.5.50-jdk8-openjdk
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  첫줄에서 답이 나왔습니다!
  &lt;br/&gt;
  FROM 을 통해 tomcat이미지를 먼저 받아서 그 위에 차례대로 레이어를 쌓아가면서 도커파일을 실행하기에
  &lt;br/&gt;
  이미지가 두개가 만들어지게 됩니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;ol start=&quot;5&quot;&gt;
  &lt;li&gt;
   docker run을 이용한 컨테이너 실행
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;p&gt;
  이제 Image를 만들었으니 실행해봅시다!
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@kbseo-test1 stlapp]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  아직까지 실행되고있는 컨테이너가 없네요
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker run -d -p 8081:8080 --name=stlapp stlapp:1.0
fc16ba3e9f3f03ba22a2ca0b7eb12909a8311b555ef34bcf9b0f591537a76d2a
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  명령어에 대해 간단히 설명드리자면
  &lt;br/&gt;
  &lt;strong&gt;
   $ docker run &amp;lt;옵션&amp;gt; &amp;lt;이미지이름, ID &amp;gt; &amp;lt;명령&amp;gt; &amp;lt;매개변수&amp;gt;
  &lt;/strong&gt;
 &lt;/p&gt;
 &lt;p&gt;
  이렇게 구성되어있습니다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   docker run -d -p 8081:8080 --name=stlapp stlapp:1.0
  &lt;/code&gt;
  이 명령어를 보자면
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;p&gt;
    -d 데몬모드로 컨테이너를 실행하고,
   &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;
    -p 옵션을 이용하여 외부포트를 연결해줍니다
    &amp;lt;호스트포트&amp;gt;:&amp;lt;컨테이너포트&amp;gt; -&amp;gt; 8080컨테이너 포트를 8081포트를 이용해 외부로 연결시킵니다.
   &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;
    --name 컨테이너 이름을 지정해줍니다.
    여기에서는 stlapp이라는 이름을 달아주었습니다.
   &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;
    실행시킬 컨테이너와 태그정보를 입력해줍니다.
   &lt;/p&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
  결과를 한번 봐볼까요?
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
fc16ba3e9f3f        stlapp:1.0          &quot;catalina.sh run&quot;   11 minutes ago      Up 11 minutes       0.0.0.0:8081-&amp;gt;8080/tcp   stlapp
[root@kbseo-test1 stlapp]# 

&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  실행되고있는 컨테이너를 확인하실 수 있습니다.
 &lt;/p&gt;
 &lt;p&gt;
  브라우저를 통해 확인해볼까요?
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97455310/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  컨테이너 이미지의 ID와 현재 시간이 잘 출력되는것을 보실 수 있습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  하지만 빨간색이라 눈이 너무나 아픈것같은 느낌적인 느낌입니다
  &lt;br/&gt;
  그래서 검은색으로 바꾸고 재 배포를 해볼까요??
 &lt;/p&gt;
 &lt;p&gt;
  순서는 간단합니다!
 &lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;
   실행되고 있는 컨테이너 중지
  &lt;/li&gt;
  &lt;li&gt;
   해당 컨테이너 삭제
  &lt;/li&gt;
  &lt;li&gt;
   소스수정
  &lt;/li&gt;
  &lt;li&gt;
   소스빌드, 컨테이너 빌드
  &lt;/li&gt;
  &lt;li&gt;
   컨테이너 실행
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#1-실행되고-있는-컨테이너-중지&quot; id=&quot;1-실행되고-있는-컨테이너-중지&quot;&gt;
   1. 실행되고 있는 컨테이너 중지
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  단칼에 중지시켜 줍니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 src]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
fc16ba3e9f3f        stlapp:1.0          &quot;catalina.sh run&quot;   29 minutes ago      Up 29 minutes       0.0.0.0:8081-&amp;gt;8080/tcp   stlapp

 
[root@kbseo-test1 src]# docker kill stlapp
stlapp


[root@kbseo-test1 src]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                       PORTS               NAMES
fc16ba3e9f3f        stlapp:1.0          &quot;catalina.sh run&quot;   29 minutes ago      Exited (137) 3 seconds ago                       stlapp
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  docker kill 명령어를 통해 중지시켜준 후
  &lt;br/&gt;
  docker ps 를 통해 확인해보면 상태가 바뀐것을 보실 수 있습니다.
  &lt;br/&gt;
  브라우저를 통해 접속해봐도 접속이 안되는것을 보실 수 있죠
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#2-해당-컨테이너-삭제&quot; id=&quot;2-해당-컨테이너-삭제&quot;&gt;
   2. 해당 컨테이너 삭제
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  프로세스를 삭제시켜 줍니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 src]# docker rm stlapp
stlapp

[root@kbseo-test1 src]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#3-소스수정&quot; id=&quot;3-소스수정&quot;&gt;
   3. 소스수정
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  css코드를 수정하여 색상을 변경해줍니다.
  &lt;del&gt;
   저는 블랙블랙으로 바꿨습니다.(TMI)
  &lt;/del&gt;
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#4-소스빌드&quot; id=&quot;4-소스빌드&quot;&gt;
   4. 소스빌드
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  소스를 수정했으니 재빌드를 해줘야겠죠?
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# ./mvnw package
INFO] Scanning for projects...
[INFO] 
[INFO] -------------------------&amp;lt; no.kantega:stlapp &amp;gt;--------------------------
[INFO] Building spring-and-react 0.1
[INFO] --------------------------------[ war ]---------------------------------
[INFO] 
[INFO] --- frontend-maven-plugin:1.6:install-node-and-npm (install node and npm) @ stlapp ---
[INFO] Node v6.17.1 is already installed.
[INFO] NPM 3.10.10 is already installed.
[INFO] 
[INFO] --- frontend-maven-plugin:1.6:npm (npm install) @ stlapp ---
[INFO] Running 'npm install' in /root/stl/stlapp/frontend
...
...
[INFO] --- spring-boot-maven-plugin:2.0.1.RELEASE:repackage (default) @ stlapp ---
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 43.467 s
[INFO] Finished at: 2020-04-27T20:10:43+09:00
[INFO] ------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  소스를 빌드했으니 도커를 빌드해봅시다!
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker build -t stlapp .
Sending build context to Docker daemon 252.2 MB
Step 1/6 : FROM tomcat:8.5.50-jdk8-openjdk
 ---&amp;gt; b56d8850aed5
Step 2/6 : MAINTAINER jacobbaek@osci.kr
 ---&amp;gt; Using cache
 ---&amp;gt; 3b0a94a52842
Step 3/6 : ENV TZ Asia/Seoul
 ---&amp;gt; Using cache
 ---&amp;gt; 706e8669d2d6
Step 4/6 : RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime
 ---&amp;gt; Using cache
 ---&amp;gt; 453ac37a79dd
Step 5/6 : RUN rm -rf /usr/local/tomcat/webapps/ROOT
 ---&amp;gt; Using cache
 ---&amp;gt; 32f3bddc0334
Step 6/6 : COPY target/stlapp-0.1.war /usr/local/tomcat/webapps/ROOT.war
 ---&amp;gt; Using cache
 ---&amp;gt; 3f24f0f7deaa
Successfully built 3f24f0f7deaa
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  이미지가 만들어졌는지 확인해볼까요?
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker images
REPOSITORY          TAG                   IMAGE ID            CREATED             SIZE
stlapp              1.0                   3f24f0f7deaa        3 hours ago         545 MB
stlapp              latest                3f24f0f7deaa        3 hours ago         545 MB
docker.io/tomcat    8.5.50-jdk8-openjdk   b56d8850aed5        2 months ago        529 MB
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  하나의 이미지가 추가로 생성된 것을 보실 수 있습니다!
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#5-컨테이너-실행&quot; id=&quot;5-컨테이너-실행&quot;&gt;
   5. 컨테이너 실행
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  돌려봅니다
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker run -d -p 8081:8080 --name=stlapp stlapp
5140e8332057ed23c4bf491a36d2d63fa0d09f0ffc4378073e145c2626075c30
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  잘 올라가져있는지 확인해볼까요?
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
dd58841261fa        stlapp              &quot;catalina.sh run&quot;   55 seconds ago      Up 55 seconds       0.0.0.0:8081-&amp;gt;8080/tcp   stlapp
&lt;/code&gt;&lt;/pre&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97455310/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  이제 깔끔한 BLACK 색상으로 바뀌었습니다.
 &lt;/p&gt;
 &lt;p&gt;
  이렇게 제 local환경에서 테스트한 컨테이너들에게 TAG를 지정하여서 버전관리도 할 수 있습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker tag stlapp:latest 192.168.197.130:5000/stlapp_kb:1.2.0

[root@kbseo-test1 stlapp]# docker images
REPOSITORY                       TAG                   IMAGE ID            CREATED             SIZE
192.168.197.130:5000/stlapp_kb   1.2.0                 3e72ae5de27a        5 minutes ago       545 MB
stlapp                           latest                3e72ae5de27a        5 minutes ago       545 MB
docker.io/tomcat                 8.5.50-jdk8-openjdk   b56d8850aed5        2 months ago        529 MB
[root@kbseo-test1 stlapp]# 
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  테스트를 끝냈으니 registry에 올려줄 차례죠
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker push 192.168.197.130:5000/stlapp_kb:1.2.0
The push refers to a repository [192.168.197.130:5000/stlapp_kb]
The push refers to a repository [192.168.197.130:5000/stlapp_kb]
Get https://192.168.197.130:5000/v1/_ping: http: server gave HTTP response to HTTPS client
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  어랏? 안돼네요?
  &lt;br/&gt;
  이유는 바로 도커는 https 통신을 하기 때문입니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  고로 저는 http 통신을 하기위해
  &lt;br/&gt;
  docker에게 직접 친절히 사용하고자 하는 ip를 등록해주도록 하겠습니다.
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#docker-insecure&quot; id=&quot;docker-insecure&quot;&gt;
   docker insecure
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  여러가지의 방법이 있지만
  &lt;br/&gt;
  저는 daemon.json 파일 안에 등록을 해주도록 하겠습니다.
  &lt;br/&gt;
  (가장 간단해서 이방법으로 하였습니다 히힛)
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;
   /etc/docker/daemon.json 수정
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# cat /etc/docker/daemon.json 
{
&quot;insecure-registries&quot;:[&quot;192.168.197.130:5000&quot;]
}
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  사용할 registry 주소와 포트를 입력해줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;
   dpcker 데몬 재기동
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# service docker restart
Redirecting to /bin/systemctl restart docker.service
&lt;/code&gt;&lt;/pre&gt;
 &lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;
   레지스트리에 login
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker login http://192.168.197.130:5000
Username: admin
Password: 
Login Succeeded
&lt;/code&gt;&lt;/pre&gt;
 &lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;
   레지스트리에 push
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker push 192.168.197.130:5000/stlapp_kb:1.2.0
The push refers to a repository [192.168.197.130:5000/stlapp_kb]
c20036844421: Pushed 
64bc7cab37ab: Pushed 
caeac141f483: Layer already exists 
5245df7d360d: Layer already exists 
78f5460c83b5: Layer already exists 
c601709dd5d2: Layer already exists 
72ce39f2b7f6: Layer already exists 
33783834b288: Layer already exists 
5c813a85f7f0: Layer already exists 
bdca38f94ff0: Layer already exists 
faac394a1ad3: Layer already exists 
ce8168f12337: Layer already exists 
1.2.0: digest: sha256:93e8b021981faed5cb1e5b22f4c0694f841afc1aa4502fff78d7edf9ffdb97cf size: 2840
[root@kbseo-test1 stlapp]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  짜잔! 등록이 되었습니다
 &lt;/p&gt;
 &lt;p&gt;
  이번시간에는 간단한 Application을 컨테이너화 하여 실행하는거 까지 함께 했는데요
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  간단하다고 했지만 실질적으로 여러 작업이 들어갔었습니다
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  그래서 다음시간에는 이를 좀 더 간단히 수행하기위해
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  젠킨스를 이용하여 작업을 해보도록 하겠습니다!
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  뿅!
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;</description>
        <pubDate>Thu, 30 Apr 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/04/30/97455310/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/04/30/97455310/</guid>
        
        <category>docker</category>
        
        <category>kubernetes</category>
        
        <category>dockerize</category>
        
        <category>containerize</category>
        
        <category>도커</category>
        
        <category>컨테이너</category>
        
        
      </item>
    
      <item>
        <title>오픈소스에 기여하는 방법에 대하여 - #2 새로운 프로젝트 시작하기</title>
        <description>&lt;p&gt;
 이전 편에 이어, 새로운 오픈소스 프로젝트를 시작하는 방법에 대해서 설명하고자 합니다.
&lt;/p&gt;
&lt;p&gt;
 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://tech.osci.kr/2020/04/09/94568493/&quot; rel=&quot;nofollow&quot;&gt;
  오픈소스에 기여하는 방법에 대하여 - #1 기존 프로젝트 활용하기
 &lt;/a&gt;
 보러 가기
&lt;/p&gt;
&lt;h1 class=&quot;auto-cursor-target&quot; id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-2.기여#2-아니야!내가새로만들래!&quot;&gt;
 &lt;strong&gt;
  2. 기여 #2 - 아니야! 내가 새로 만들래!
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;p&gt;
 새로운 오픈소스 소프트웨어 프로젝트의 시작은 요구 사항을 만족하는 기존 프로젝트를 발견하지 못한 경우나 기존의 유사 프로젝트에 새로운 기능에 대한 수용 요구가 받아들여지지 않은 경우 등에 내리는 최후의 선택이라고 볼 수 있습니다. 그 밖에 자주 발생하는 새 프로젝트 시작 요인으로는 개인적 취향에 따른 것인데, 기존 프로젝트에 사용된 개발 언어가 마음에 들지 않는 경우도 많습니다.
&lt;/p&gt;
&lt;p&gt;
 실제 오픈 소스 소프트웨어들은 다양한 라이선스 정책을 가지고 있지만, 거의 대부분은 기존의 코드에서의 브랜치가 문제가 되는 경우는 많이 없습니다. 자신이 순환 구조에의 참여가 어렵다고 느끼는 경우, 프로젝트 결과물의 설계 구조에 전혀 동의 할 수 없는 경우, 마지막으로는 기존 프로젝트의 핵심 개발자, 관리자 그룹을 개인적으로 선호하지 않는 경우 등이 있을 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 일단 여러 동기에 의하여, 새로운 프로젝트가 시작되면, 상용 소프트웨어의 개발과 유사한 과정을 거치게 되는데, 이 과정은 같은 동기와 목표 의식을 가진 핵 심 개발자들로 개발팀을 구성하고, 요구 분석을 더욱 견고하게 한 뒤, 각종 위험 요인 분석, 일정 만들기 등의 절차적인 작업들로 시작됩니다.
&lt;/p&gt;
&lt;p&gt;
 그 가운데 위험 요인 분석에는, 이 새로운 프로젝트가 기존 프로젝트들 에 비하여 경쟁력을 가질 수 있는지, 개발과 추후 관리를 위한 충분한 자원자를 확보할 수 있는지, 개발에 필요한 장비가 확보 가능한지 등을 포함하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 프로젝트의 시작 단계에서부터 소스의 관리, 버그의 관리, 개발자들 간의 원활한 의사소통을 위하여 Github와 같은 오픈소스 소프트웨어 개발자 사이트를 이용할 수 있지만, 많은 초기의 프로젝트의 경우, 프로젝트의 시작 동기, 요구 사항, 설계 등이 기술된 공식적 문서의 부족이나, 다운로드가 가능한 소프트웨어 릴리즈가 없다는 이유로 개발자 지원 사이트에 등록된다 해도 커뮤니티 형성 등의 파급 효과를 기대하기는 어렵긴 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-첫번째할일.프로토타입구현&quot;&gt;
 첫번째 할 일. 프로토타입 구현
&lt;/h3&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 소프트웨어가 커뮤니티의 관심을 끌기 위한 최소한의 작업은 고품질의 프로토타입을 완성하는 일입니다. 프로토타입의 개발은 비교적 소수의 폐쇄적인 핵심 개발자 그룹을 중심으로 이루어집니다. 따라서 개발자들 사이의 의견 교환 및 의사 결정을 위한 시스템의 존재 여부는 크게 문제가 되지 않지만, 프로토타입 구현이 진행되면서, 최초의 요구 사항이 일부 수정되고 그 결과가 설계의 변경을 필요로 하는 경우도 많아, 구성원 사이의 의사소통 방법과 최소한의 문서 화는 노력이 반드시 필요합니다.
&lt;/p&gt;
&lt;p&gt;
 많은 오픈 소스 소프트웨어 프로젝트에서는 상용의 대형 소프트웨어 개발 방식에서 사용되는 소프트웨어 공학적 개발 방법론이 사용되지 않으며, 설계 방식과 참여한 개발자들의 취향에 따른 개발 방식이 사용되는게 일반적입니다. 하지만, 오픈 소스 개발의 가장 중요한 특징인 분산 개발을 효과적으로 수행하고, 소스 코드의 재사용 가능성을 높이기 위하여 모듈화, 계층화된 소프트웨어 설계를 하는 것이 중요합니다.
&lt;/p&gt;
&lt;p&gt;
 설계는 이전에 있던 유사 프로젝트의 설계를 바탕으로 이루어지기도 하며, 더 많은 경우는, 개발자들의 혁신 의지에 따라, 새로운 설계를 추구하게 됩니다. 프로토타입 구현의 완성도와 설계 특징들은, 프로젝트의 동기와 목표에 수긍하는 개발자들을 커뮤니티에 끌어들이고, 그들의 적극적인 피드백을 유도하는 중요한 원동력입니다.
&lt;/p&gt;
&lt;p&gt;
 따라서 프로토타입은 기본적인 기능 요구를 만족하며, 안정적인 동작을 해야 하며, 단순 명료한 소프트웨어 구조를 유지 하는 것이 바람직하며. 또한 기능적인 부분을 포함하여 개선할 여지도 있어야 개발자들이 많이 참여를 하게 될 것입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568500/0.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 프로토타입의 배포 이전에 반드시 거쳐야 하는 단계는 내부 시험입니다. 이 단계는 커뮤니티 참여자를 끌어 들이기 위하여, 최초로 오픈되는 소프트웨어가 그럴 듯하게 보여야할 뿐만 아니라 높은 수준의 안정성도 확보되어야 한다는 관점에서 매우 중요합니다. 대개의 프로젝트에서  별도의  QA, 테스팅 도구나 정교한 방법론은 잘 사용되지 않으며, 최근에는 가상 머신을 이용하여, 다양한 시스템 환경에서의 테스팅을 이전 보다는 더 용이하게 할 수 있다는 특징이  있습니다. 주로 모듈 단위로 설계, 구현되는 소프트웨어 구조 때문에 오픈 소스 프로젝트에서는 기존의 라이브러리들을 적극적으로 활용하게 되며, 많은 경우 각 모듈 또한 라이브러리 형식으로 개발되는 게 일반적입니다.  사실 개발되는 많은 오픈소스 소프트웨어들이 패키지 형태의 완성품보다는 라이브러리 형태의 모듈이 상당히 많습니다.
&lt;/p&gt;
&lt;p&gt;
 프로토타입 개발자들은 오픈 소스 프로젝트로서 성공적인 정착을 위해 배포 전에 호환성, 가이드, 편의성 문제의 해결에 많은 노력을 기울여야 하며,  다양한 빌드도구를 활용하여 개발자들이 손쉽게 우리가 만든 소프트웨어를 개발하고 테스팅할 수 있는 환경을 만들어주는 것이 중요합니다.
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-두번째.결과물배포&quot;&gt;
 두번째. 결과물 배포
&lt;/h3&gt;
&lt;p&gt;
 프로그램 배포는 완성된 프로토타입을 공개함으로써, 프로젝트를 오픈소스 소프트웨어 순환 구조 안에서 발전 하도록 만들기 위한 단계입니다. 프로젝트의 오픈과 소프트웨어의 배포는 BitBucket, GitHub과 같은 오픈소스 프로젝트 사이트를 이용할 수 있습니다. 하지만 GitHub만 따져도
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  &lt;strong&gt;
   &lt;span&gt;
   &lt;/span&gt;
   현재 등록된 프로젝트의 수가 이미 수십만 개를 넘었기 때문에
  &lt;/strong&gt;
 &lt;/span&gt;
 , 초기 단계의 프로젝트가 검색 단계에서 발견되어 커뮤니티의 주목을 받기는 쉽지가 않은 상황입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568500/1.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;createlink&quot; href=&quot;https://wiki.osci.kr/pages/createpage.action?spaceKey=CIS&amp;amp;title=%ED%97%88%EA%B1%B1%21+%EC%88%98%EC%8B%AD%EB%A7%8C%EA%B0%9C%21&amp;amp;linkCreation=true&amp;amp;fromPageId=91696766&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: underline;&quot;&gt;
  허걱! 1억개!
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 배포를 통해 성공적인 커뮤니티 기반 오픈 소스 프로젝트가 되기 위해서는 프로젝트 관리 구조에 대한 프로세스 등의 여러 가지 중대한 결정들이 필요합니다. 프로젝트 관리 구조는 개발자 그룹과 최종적으로 프로젝트의 방향을 결정하는 의사 결정 그룹, 그리고 의사 결정 과정을 의미하는 것입니다. 즉, 배포를 통해서 프로젝트의 소유가 초기의 핵심 개발자 그룹에서 커뮤니티로 바뀐다는 점을 바탕으로, 프로젝트에 더 많은 사람들이 참여할 수 있는 구조와 의사 결정 과정을 만드는 것인데, 이 관리 구조는 프로젝트 결과물의 성격에 따라 다르게 결정되어야 합니다. 예를 들어 운영체제의 커널 또는 그의 일부와 같이 기술적 위험이 수반되는 프로젝트의 경우에는 보수적 관점에서의 관리를 추구하여야 합니다.
&lt;/p&gt;
&lt;p&gt;
 새로운 기능의 수용, 소스 코드의 수정 등에 매우 신중한 결정을 해야 하며, 시험 및 새로운 릴리즈에 관한 중앙집중형 통제권을 유지하는 것이 바람직합니다. 반면에 GUI와 같은 사용자 편의 위주의 프로젝트는 다양한 기능적 요구를 빠르게 수용하기 위한 관리 스타일이 좋다. 초기의 프로젝트에서는 메일링 리스트, 뉴스그룹, 포럼 등을 이용 한 의견 교환과 묵시적인 합의에 의하여 프로젝트가 진행될 수 있으나, 프로젝트가 점차 명성을 얻어 커뮤니티가 커지면, 공개적이면서도 좀 더 명확한 의사 결정 구조를 요구합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 여러 관리 스타일에도 불구하고 커뮤니티를 기반으로 발전하는 오픈 소스 프로젝트에서는 개발자, 사용자들의 모든 형태의 기여(기능 추가, 버그 수정, 버그 리포팅, 새로운 기능 요구, 등)가 반드시 권장되야 하며, 개발자들의 기여 내용이 빠르게 프로젝트에 반영되어야 합니다. 배포 전에 결정해야 할 또 다른 중요한 사항은 공개될 소스의 라이선스를 결정하는 것입니다.
&lt;/p&gt;
&lt;p&gt;
 OSI(Open Source Initiative)의 오픈 소스 정의는 오픈 소스 에 대한 명확한 가이드라인으로 사용되고 있으며, 라이선스가 이 가이드라인을 만족하면, 오픈소스 소프트웨어라고 할 수 있습니다. 많은 오픈 소스 소프트웨어들이 GPL(Generic Public Licence) 또는 LGPL(Lesser GPL) 라이선스를 가지고 있지만, GPL 버전들 사이의 차이를 비롯하여, OSI에 등록된 다양한 오픈소스 라이선스들의 미묘한 차이점은 오픈소스 개발자 들이 프로젝트에의 참여 여부를 결정하는 한 요인이 되기도 합니다.
&lt;/p&gt;
&lt;p&gt;
 기타 결정 사항에는 커뮤니티 참여자들의 주 통신 방법과 소스 코드로의 접근방법 등이 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-세번째!개발자간의사소통&quot;&gt;
 세번째! 개발자간 의사소통
&lt;/h3&gt;
&lt;p&gt;
 개발자간 소통 방법에는 커뮤니티 참여자의 성격(개발자, 관리자, 사용자 등)에 따른 메일링 리스트, 포럼과 그들의 아카이브, 버그 리포트, 프로젝트 관련 문서, FAQ 등이 있습니다. 버그 리포트는 사용자와 개발자의 공식적인 통신 방법으로, 오픈 소스 소프트웨어 개발자 사이트들이 공통으로 제공하는 버그 트래킹 시스템을 이용합니다. 별도의 홈페이지를 이용하여 프로젝트를 공개한다면, Bugzilla, Trac, Redmine과 같은 버그 트래킹 시스템을 설치하여 이용할 수 있으며,
 &lt;span&gt;
 &lt;/span&gt;
 &lt;u&gt;
  &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
   &lt;strong&gt;
    아틀라시안의 JIRA를 오픈소스 개발자용 버전으로 받아 사용하는 방법도 있습니다.(아틀라시안 강추!!)
   &lt;/strong&gt;
  &lt;/span&gt;
 &lt;/u&gt;
&lt;/p&gt;
&lt;p&gt;
 버그 트래킹 시스템은 버그를 등록 하고, 누가 그것을 담당하여 수정할 지를 할당하고, 현재 처리 상태는 어떤지, 그리고 그 버그에 대한 의견 교환을 하는 등, 버그의 발생부터 해결까지의 전 과정에 대한 체계적인 관리 방법을 제공합니다. 소스 코드의 경우 안정된 배포 버전, 흔히 베타 버전라고 하는 외부용 시험 버전, 그리고 현재 개발이 진행 중인 소스 코드 스냅샷, 세 가지를 모두 공개하는 것이 보통입니다.
&lt;/p&gt;
&lt;p&gt;
 소스 코드 스냅샷 공개는 개발자들 이 소스의 버전 관리를 위하여 사용하고 있는 소스 코드 버전 관리 서버에 로그인하여 소스에 읽을 수 있도록 하는 것입니다. 소스 코드의 공개는 오픈소스 소프트웨어의 가장 큰 미덕으로 누구나 쉽게 다운로드, 리뷰, 빌드를 할 수 있도록 하고, 궁극적으로 패치를 만들어 프로젝트 관리자에게 보낼 수 있어야 합니다.
&lt;/p&gt;
&lt;p&gt;
 많은 오픈 소스 프로젝트들은 홈페이지 또는 배포된 소스에 프로젝트 컨트리뷰터(기여자)와 커미터들을 나열함으로써, 그들의 기여에 감사하고, 동시에 그 목록에 없는 개발자, 사용자들에게 동기를 부여하고 있으며 커리어 개발의 도구로도 활용되고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-네번째,커뮤니티기반개발&quot;&gt;
 네번째, 커뮤니티 기반 개발
&lt;/h3&gt;
&lt;p&gt;
 일단 프로젝트의 프로토타입, 소스가 공개되어, 점차 알려지고, 사용자,  개발자 등의 관심을 끌어, 커뮤니티가 형성되면 오픈소스 순환 구조에 의해 프로젝트는 진화하는 게 일반적입니다. 공개에 앞서 결정된 의사 결정 구조 등에 의거하여 수정 버전의 릴리즈, 기능이 대폭 강화된 버전업 등이 이루어지며, 사용 중에 발생하는 버그의 리포팅 및 수정, 기능 추가 요구 등이 커뮤니티 측에서도 이루어지며, 그 결과가 프로젝트 관리자 그룹에 의해 반영됩니다.
&lt;/p&gt;
&lt;p&gt;
 이 순환 구조가 얼마나 원활하게 운영되는지가 결국 오픈소스 소프트웨어 프로젝트의 성패를 결정하게 되며, 이 구조의 원활한 순환과 효율성은 모든 참여자 사이의 의사소통 및 의사 결정 과정 등, 배포 전에 내려진 여러 결정에 의해 좌우됩니다. 오픈소스 소프트웨어가 커뮤니티에 의해 진화한다는 일반적인 인식에도 불구하고, 그 프로젝트를 처음 시작하고, 많은 경우 결국 관리하게 되는 코어 개발자 그룹의 지속적인 관심과 개선 의지는 프로젝트 성공의 가장 중요한 요인이 됩니다.
&lt;/p&gt;
&lt;p&gt;
 많은 오픈 소스 소프트웨어 프로젝트 참여의 동기가 ‘재미’로 시작되는 경우입니다. 하지만, 오픈소스 순환 구조에 안정적으로 들어선 아주 성공적인 프로젝트들(예: 빅데이터 프로젝트, NoSQL 등)은 그 결과가 상업적인 활동에 점차 많이 적용되면서, 기술 지원과 새로운 기능 요구에 대하여 시기적절한 대응이 요구되며, 프로젝트의 핵심 개발자, 관리자 그룹에게는 더 빠른 진화를 할 수 있는 추가적인 동력이 필요하게 되고, 이 과정에서 많은 경우 기술 지원에 대한 대가로서 금전적 보상이 따르는 경우가 많아져 많은 개발자들이 이러한 오픈소스 개발에 관심을 가지게 되었습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 간략하게나마 오픈소스에 기여하는 방법에 대해 살펴보았는데 읽을만 하셨나요? 사실 바쁘게 업무 시스템관리하면서 오픈소스하기가 쉽지 않습니다. 대부분의 오픈소스 개발자들이 재미로 본인의 여가시간을 활용하여 시작한 경우가 대부분입니다. 앞으로 조금만 시간을 들여서 유튜브 동영상, 게임하시는 시간 조금 줄이고 간단한 오픈소스 활용부터 하시는 건 어떨까요?
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  이런 소프트웨어 엔지니어가 되선 안되잖아요. ^^
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568500/2.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;</description>
        <pubDate>Thu, 09 Apr 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/04/09/94568500/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/04/09/94568500/</guid>
        
        <category>오픈소스</category>
        
        <category>기여</category>
        
        <category>기여방법</category>
        
        <category>리누스</category>
        
        <category>토발즈</category>
        
        <category>리눅스</category>
        
        <category>오픈소스컨설팅</category>
        
        
      </item>
    
      <item>
        <title>오픈소스에 기여하는 방법에 대하여 - #1 기존 프로젝트 활용하기</title>
        <description>&lt;p&gt;
 &lt;span style=&quot;color: rgb(51,51,51);&quot;&gt;
  오늘은 오픈소스에 기여하는 실제적인 방법이 어떤 것이 있는지에 대해서 설명하도록 하겠습니다.
  &lt;img src=&quot;/assets/images/94568493/0.svg&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(51,51,51);&quot;&gt;
  대표적인 오픈소스인 리눅스만 하더라도 리누스 토발즈가 처음 그 코드를 공개했을 때 세계 최대 규모의 오픈소스 소프트웨어가 될 거라는 생각조차 못했을 것입니다. 여전히 토발즈는 커널의 승인 여부를 혼자 결정하고 있지만 누구나 개선될 수 있는 소스코드를 보내게 되고 그것이 도움이 된다고 판단되면  해당 소스코드의 저자(Author) 항목에 기여자(Contributor)가 되어 다음 릴리즈 되는 버전에 이름이 나오게 되었습니다. 이는 유명해지려는 사람들의 욕구(과시욕)를 충족시켜 주었을 뿐더러 개발자들에게 돈 한푼 주지 않고도 커널의 버그 수정, 드라이버 개발, 기능 추가를 할 수 있는 중요한 원동력이 되었습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(51,51,51);&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
    &lt;img src=&quot;/assets/images/94568493/1.jpeg&quot;/&gt;
   &lt;/span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;
 화끈한 창시자
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  리누스 베네딕트 토발즈(Linus Benedict Torvalds,
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 1969년
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 12월 28일
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  &lt;span&gt;
  &lt;/span&gt;
  ~ )는
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 스웨덴
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  계
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 핀란드
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  인
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 소프트웨어
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  &lt;span&gt;
  &lt;/span&gt;
  개발자이다.
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 &lt;strong&gt;
  리눅스의 아버지
 &lt;/strong&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  로 유명하며, 분산
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 버전 관리 시스템
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  인
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://namu.wiki/w/Git&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot; title=&quot;Git&quot;&gt;
  Git
 &lt;/a&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  &lt;span&gt;
  &lt;/span&gt;
  등을 만들었다. 그의 종특은 맘에 안드는 것은 뭐든지 까는 것으로, 거친 언사도 서슴지 않으며, 일반인들과도 뉴스그룹, 이메일 등지에서 욕설섞인 배틀을 자주 뜨는 현장을 목격 할 수 있
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  다. 특히 리눅스 개발 커뮤니티의 분위기를 살벌하게 만드는 일등 공신이 리누스 본인인데, 오픈소스 개발이라고 하면 누구나 편하게 자신의 코드를 커밋할 수 있을 것 같지만
  &lt;span&gt;
  &lt;/span&gt;
  현실은 시궁창으로, 리눅스에 함부로 손을 댄 사람은 리누스에게 쌍욕을 먹고 멘붕을 하게 되기 일쑤다. 소스 코드 리뷰에서 심각하게 결함이 있는 부분이나 마음에 안드는 부분을 가차없이 까내리는 모습이 거의
  &lt;span&gt;
  &lt;/span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://namu.wiki/w/%EA%B3%A0%EB%93%A0%20%EB%9E%A8%EC%A7%80&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot; title=&quot;고든 램지&quot;&gt;
   고든 램지
  &lt;/a&gt;
  급.
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 기여의 1단계로 보자면 우선 내가 사용하고 있는 오픈소스에 대한 관심과 그것이 가진 기능을 활용해 보는 것이 첫번째일 것입니다. 어떤 업무시스템 또는 소프트웨어를 개발하고자 하는 경우 개발하고자 하는 기능에 대한 충분한 분석을 한 뒤, 이미 존재하는 오픈 소스 소프트웨어 프로젝트들이면 내가 원하는 요구 사항을 만족하는 것이 있는지 확인하는 작업부터가 시작일 것입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-1.기여#1-있는거참여할래!&quot;&gt;
 &lt;strong&gt;
  1.  기여 #1 - 있는거 참여할래!
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-가.오픈소스프로젝트검색&quot;&gt;
 가. 오픈소스 프로젝트 검색
&lt;/h3&gt;
&lt;p&gt;
 현재 오픈소스 프로젝트는 셀 수 없을 정도로 많으며, 해당 프로젝트가 관리되고 있는 저장소도 각각 다릅니다. 이렇게 많은 프로젝트들 중 특정 프로젝트를 찾기 위해 다음과 같은 방법을 사용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h4 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(1)구글링&quot;&gt;
 (1) 구글링
&lt;/h4&gt;
&lt;p&gt;
 잘 알려진 유명한 오픈소스 프로젝트들은 타이틀만으로도 구글링을 통해 충분히 검색할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/2.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-1 구글링을 이용한 프로젝트 검색]
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h4 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(2)오픈소스저장소내검색&quot;&gt;
 (2) 오픈소스 저장소 내 검색
&lt;/h4&gt;
&lt;p&gt;
 GitHub, SourceForge, Bitbucket, Google Code 등 오픈소스 저장소에 접속하여 직접 검색합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/3.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-2 오픈소스 저장소 내 프로젝트 검색] - 아이고 많기도 하여라!
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h4 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(3)오픈소스재단내검색&quot;&gt;
 (3) 오픈소스 재단 내 검색
&lt;/h4&gt;
&lt;p&gt;
 아파치 재단, 리눅스 재단, 모질라 재단 등 오픈소스 재단에 접속하여 직접 검색할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/4.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-3 오픈소스 재단 내 프로젝트 검색]
&lt;/p&gt;
&lt;p&gt;
 그 밖에
 &lt;span&gt;
 &lt;/span&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;http://www.findbestopensource.com/&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot;&gt;
  &lt;u&gt;
   http://www.findbestopensource.com
  &lt;/u&gt;
 &lt;/a&gt;
 ,
 &lt;span&gt;
 &lt;/span&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.openhub.net/&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot;&gt;
  &lt;u&gt;
   https://www.openhub.net/
  &lt;/u&gt;
 &lt;/a&gt;
 &lt;span&gt;
 &lt;/span&gt;
 등의 사이트에서도 검색할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-나.오픈소스프로젝트참여&quot;&gt;
 나. 오픈소스 프로젝트 참여
&lt;/h3&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 오픈소스 프로젝트에 참여하는 방법은 다음과 같이 아주 다양합니다.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  버그 리포트
 &lt;/li&gt;
 &lt;li&gt;
  커뮤니티 활동을 통한 의견 교류
 &lt;/li&gt;
 &lt;li&gt;
  프로젝트 문서 수정 또는 번역
 &lt;/li&gt;
 &lt;li&gt;
  기능 등록 및 수정 요청
 &lt;/li&gt;
 &lt;li&gt;
  패치 요청
 &lt;/li&gt;
 &lt;li&gt;
  커미터 또는 컨트리뷰터 활동
 &lt;/li&gt;
 &lt;li&gt;
  한글 번역
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 * 커미터(Committer) : 프로젝트내에서 직접 코드를 push할 수 있는 권한을 가진 사람
&lt;/p&gt;
&lt;p&gt;
 * 컨트리뷰터(Contributter) : 패치 등의 소스 코드를 제공하는 사람
&lt;/p&gt;
&lt;p&gt;
 즉, 반드시 코드를 수정, 작성해야만 프로젝트에 참여하는 것이 아니고 자신이 할 수 있는 부분에서 꾸준한 관심과 희생정신을 가지고 활동하는 것이 바람직합니다.
&lt;/p&gt;
&lt;p&gt;
 개발자에게 있어 커미터 또는 컨트리뷰터가 되는 것이 가장 이상적인 참여 방법이 될 수 있으며, 일반적인 과정은 다음과 같습니다.
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(1)기술및사용법습득과개발환경구축&quot;&gt;
 (1) 기술 및 사용법 습득과 개발환경 구축
&lt;/h3&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 오픈소스 프로젝트에서 사용하는 언어 및 프레임워크 등의 기술을 습득하고 해당 오픈소스 프로젝트를 활용할 수 있어야 하며 개발가이드를 통한 자신만의 개발 환경을 구축합니다.
&lt;/p&gt;
&lt;p&gt;
 GitHub의 경우 개발환경 구축 시 프로젝트를 개인 저장소로 복제하기 위해 Fork를 수행합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/5.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-4 GitHub 소셜 메뉴]
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Watch, Star, Fork는 GitHub의 소셜 기능으로써 Watch는 해당 프로젝트를 지속적으로 관찰하겠다는 의미로 이 기능을 활성화 시키면 해당 프로젝트가 처리하고 있는 이슈들에 대해서 알림이 오게 됩니다. Star는 해당 프로젝트에 관심을 나타내는 것으로 별점과 비슷하며, Star가 많은 프로젝트들은 월간, 주간, 일간으로 분류하여 인기 프로젝트로 선정되며 Explore 메뉴에서 보여집니다. 마지막으로 Fork는 해당 프로젝트를 내 계정에 그대로 복사하는 기능으로 해당 프로젝트에 Push 권한이 없다면 복제된 프로젝트에 기능을 추가, 수정하고 Pull Request로 변경사항을 적용 요청할 수 있습니다.
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(2)메일링리스트구독및커뮤니티활동&quot;&gt;
 (2) 메일링 리스트 구독 및 커뮤니티 활동
&lt;/h3&gt;
&lt;p&gt;
 메일링 리스트를 구독함으로써 프로젝트 관련 정보를 받아볼 수 있으며, 커뮤니티 활동으로 구성원들과의 의견 교류를 활발히 합니다. 본인이 해당 컴포넌트에 대한 장단점을 파악하고 이에 대한 설명이 가능한 상태에서
 &lt;span&gt;
 &lt;/span&gt;
 &lt;u&gt;
  &lt;strong&gt;
   영어 작문이 능통하다면 StackOverflow를 활용
  &lt;/strong&gt;
 &lt;/u&gt;
 하여 꾸준히 활동하는 방법도 정말 좋습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/6.jpeg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 (아 영어!) - 영어의 중요성!!
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(3)버그리포트&amp;amp;기능제안&quot;&gt;
 (3) 버그 리포트 &amp;amp; 기능 제안
&lt;/h3&gt;
&lt;p&gt;
 재현할 수 있는 버그에 대해 상황과 상태를 자세히 기술하며, JIRA나 GitHub 이슈 등의 공식 이슈 트래커를 사용하여 리포트합니다. 단, 버그 리포트를 등록하기 전 유사한 버그가 있는지 확인하고 이미 존재한다면 기존 내용에 코멘트 등으로 부가 설명 후 vote나 watch 등으로 관심을 표현하는 것이 좋겠죠! 기능 제안도 버그 리포팅과 마찬가지고 이슈 트래커를 사용하며, 유사한 이슈가 있는지 확인 후 등록하면 더욱 좋습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(4)패치등록/PullRequest&quot;&gt;
 (4) 패치 등록 / Pull Request
&lt;/h3&gt;
&lt;p&gt;
 버그, 기능 개선, 신규 기능 등을 위해 등록된 이슈에 패치를 첨부하면 커미터들이 패치를 검토한 후 적용하게 됩니다. GitHub가 사실상 오픈소스 코드 저장소의 표준이 되었기 때문에 요즘은 패치를 보내는 일은 많지 않고 대부분 GitHub의 Pull Request를 이용하면 됩니다. 자세한 설명은 인터넷에 무지하게 널렸으니 참고하여 주셔도 됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/7.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-5 GitHub Pull Request]
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 class=&quot;auto-cursor-target&quot; id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(5)이도저도안되겠다?!&quot;&gt;
 (5) 이도 저도 안되겠다?!
&lt;/h3&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 그러면 우선 번역하는데 참여하겠다로 시작하는 방법도 최고의 시작점이 아닐까 합니다.
&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;
 국내 오픈소스 커미터 현황
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
 &lt;/strong&gt;
 2019년 2월 기준* 총
 &lt;span&gt;
 &lt;/span&gt;
 &lt;strong&gt;
  500여
 &lt;/strong&gt;
 &lt;strong&gt;
  명
 &lt;/strong&gt;
 의 국내 커미터가 OS, Cloud, Mobile, BigData, IoT, AI, Network, Web, Embedded, Development Environment 등의 10개의 분야의 총 1,398 글로벌 오픈소스 프로젝트*에 참여하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 * 글로벌 커미터 현황은 프로젝트의 기여도와 코드의 정성적 평가 등을 거쳐
 &lt;span&gt;
 &lt;/span&gt;
 &lt;u&gt;
  &lt;strong&gt;
   30
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   일
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   ~90
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   일 간격으로 신규 커미터를 추가하며
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   ,
   &lt;span&gt;
   &lt;/span&gt;
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   기존 커미터도 지속적인 소스코드 개발과 기여가 없으면 커미터 자격이 유지되지 않음
  &lt;/strong&gt;
 &lt;/u&gt;
&lt;/p&gt;
&lt;p&gt;
 ㅇ 국내 커미터들이 가장 많이 개발에 참여하고 있는 글로벌 오픈소스 프로젝트는 구글 안드로이드(Google Android)이며, 총 86명의 국내 커미터가 분포되어 있음
&lt;/p&gt;
&lt;p&gt;
 - 구글 안드로이드 다음으로는 Google Chromium 프로젝트에 46명, WebKit 프로젝트와 Rust 프로그래밍 언어에 각각 18명의 국내 커미터가 개발하고 있음
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
 &lt;/strong&gt;
 국내 커미터가 참여하는 글로벌 프로젝트 분야 Top 3는 ① Development Environment* 분야 119명 ② Mobile 분야 105명 ③ Web분야에 80명이 참여하여 Top 3를 형성하고 있음
&lt;/p&gt;
&lt;p&gt;
 * 개발환경 분야는 Programming Language, Testing Tool, Simulator, Compiler, Build system, Library, Framework 등을 포함하고 있음
&lt;/p&gt;</description>
        <pubDate>Thu, 09 Apr 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/04/09/94568493/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/04/09/94568493/</guid>
        
        <category>오픈소스</category>
        
        <category>리누즈</category>
        
        <category>토발즈</category>
        
        <category>리눅스</category>
        
        <category>오픈소스컨설팅</category>
        
        <category>커뮤니티</category>
        
        <category>기여방법</category>
        
        
      </item>
    
      <item>
        <title>Kubernetes상에서 Keycloak과 Jenkins 그리고 Spinnaker 연동하기</title>
        <description>&lt;p&gt;
 keycloak이라는 SSO solution을 이용하여 Jenkins 그리고 Spinnaker를 SAML과 OIDC 방식으로 연동하고
&lt;/p&gt;
&lt;p&gt;
 한번의 로그인으로 각 솔루션을 접근할수 있는 방법에 대하여 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Keycloak이란?&quot;&gt;
 Keycloak이란?
&lt;/h1&gt;
&lt;p&gt;
 우선 Keycloak에 대하여 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현대의 Application과 Service들에 대한 오픈소스 계정 및 접근 관리 솔루션으로 기존에 서비스 되고 있었거나
&lt;/p&gt;
&lt;p&gt;
 새로운 Application을 구현하고자할때 해당 코드의 변경없이(혹은 약간의 수정만으로) 인증과 자원보호의 기능을 제공하는 솔루션입니다.
&lt;/p&gt;
&lt;p&gt;
 해당 솔루션은 오픈소스로 제공되며 Community 버전의 경우 별도의 비용없이 사용이 가능하며 Red Hat Single Sign-On이라는 솔루션으로
&lt;/p&gt;
&lt;p&gt;
 벤더의 지원을 구매하여 사용하실수도 있습니다.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.keycloak.org/about.html&quot; rel=&quot;nofollow&quot;&gt;
   https://www.keycloak.org/about.html
  &lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-기본적으로제공하는기능은다음과같습니다.&quot;&gt;
 기본적으로 제공하는 기능은 다음과 같습니다.
&lt;/h3&gt;
&lt;ul&gt;
 &lt;li&gt;
  SSO (Single Sign On)
 &lt;/li&gt;
 &lt;li&gt;
  ID 중개와 소셜 로그인 (OpenID, SAML, GitHub, facebook, google, twitter 등)
 &lt;/li&gt;
 &lt;li&gt;
  사용자 연합 (LDAP, AD, RDMS와의 연동을 통해 중앙화된 계정통합을 제공)
 &lt;/li&gt;
 &lt;li&gt;
  관리자 / 계정관리 콘솔
 &lt;/li&gt;
 &lt;li&gt;
  표준 프로토콜 지원 (OpenID, SAML, OAuth 2.0)
 &lt;/li&gt;
 &lt;li&gt;
  Client Adapters (다수의 platform과 프로그래밍 언어가 사용가능한 adapter를 가지고 있다.)
 &lt;/li&gt;
 &lt;li&gt;
  권한부여 서비스
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 여기까지는 간단하게 Keycloak이라는 SSO에 대하여 알아보았고 이제부터 Keycloak을 Kubernetes 환경에 배포하고
&lt;/p&gt;
&lt;p&gt;
 배포된 Keycloak을 이용하여 Jenkins, Spinnaker에 SSO 환경을 구성하는 방법에 대하여 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Keycloak배포및구성&quot;&gt;
 Keycloak 배포 및 구성
&lt;/h1&gt;
&lt;p&gt;
 우선 간단하게 helm을 이용하여 Kubernetes환경에서 keycloak을 구성하는 방법에 대하여 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 설치시 helm을 이용할 예정이기에 values.yaml내에 아래와 같은 몇가지 설정을 변경합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@labs-kube-infra001 keycloak]# kubectl create ns keycloak
[root@labs-kube-infra001 keycloak]# helm repo add codecentric https://codecentric.github.io/helm-charts
&quot;codecentric&quot; has been added to your repositories
[root@labs-kube-infra001 keycloak]# mkdir keycloak &amp;amp;&amp;amp; cd keycloak
[root@labs-kube-infra001 keycloak]# helm show values codecentric/keycloak &amp;gt; values.yaml
[root@labs-kube-infra001 keycloak]# cat values.yaml
...
  ## Username for the initial Keycloak admin user
  username: keycloak

  ## Password for the initial Keycloak admin user. Applicable only if existingSecret is not set.
  ## If not set, a random 10 characters password will be used
  password: &quot;Pa55w0rd$#&quot;
...
  service:
    annotations: {}
    # service.beta.kubernetes.io/aws-load-balancer-internal: &quot;0.0.0.0/0&quot;

    labels: {}
    # key: value

    ## ServiceType
    ## ref: https://kubernetes.io/docs/user-guide/services/#publishing-services---service-types
    type: LoadBalancer
...
  persistence:
    # If true, the Postgres chart is deployed
    deployPostgres: true

    # The database vendor. Can be either &quot;postgres&quot;, &quot;mysql&quot;, &quot;mariadb&quot;, or &quot;h2&quot;
    dbVendor: &quot;postgres&quot;
...
postgresql:
...
  persistence:
    ## Enable PostgreSQL persistence using Persistent Volume Claims.
    ##
    enabled: true
...
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 자 이제 설치를 진행해보도록 하겠습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@labs-kube-infra001 keycloak]# helm install --name keycloak -f values.yaml codecentric/keycloak --namespace keycloak
NAME:   keycloak
LAST DEPLOYED: Thu Mar 19 15:33:50 2020
NAMESPACE: keycloak
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/ConfigMap
NAME              DATA  AGE
keycloak-sh       1     2s
keycloak-startup  1     2s
keycloak-test     1     2s

==&amp;gt; v1/Pod(related)
NAME                   READY  STATUS    RESTARTS  AGE
keycloak-0             0/1    Init:0/1  0         1s
keycloak-postgresql-0  0/1    Pending   0         1s

==&amp;gt; v1/Secret
NAME                 TYPE    DATA  AGE
keycloak-http        Opaque  1     3s
keycloak-postgresql  Opaque  1     3s

==&amp;gt; v1/Service
NAME                          TYPE          CLUSTER-IP    EXTERNAL-IP      PORT(S)                      AGE
keycloak-headless             ClusterIP     None          &amp;lt;none&amp;gt;           80/TCP,8443/TCP              2s
keycloak-http                 LoadBalancer  10.233.3.82   192.168.197.141  80:32242/TCP,8443:31190/TCP  2s
keycloak-postgresql           ClusterIP     10.233.7.200  &amp;lt;none&amp;gt;           5432/TCP                     2s
keycloak-postgresql-headless  ClusterIP     None          &amp;lt;none&amp;gt;           5432/TCP                     2s

==&amp;gt; v1/StatefulSet
NAME                 READY  AGE
keycloak             0/1    2s
keycloak-postgresql  0/1    2s


NOTES:

Keycloak can be accessed:

* Within your cluster, at the following DNS name at port 80:

  keycloak-http.keycloak.svc.cluster.local

* From outside the cluster, run these commands in the same shell:

  NOTE:
  It may take a few minutes for the LoadBalancer IP to be available.
  You can watch the status of by running 'kubectl get svc -w keycloak'

  export SERVICE_IP=$(kubectl get svc --namespace keycloak keycloak -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
  echo http://$SERVICE_IP:80

Login with the following credentials:
Username: keycloak

To retrieve the initial user password run:
kubectl get secret --namespace keycloak keycloak-http -o jsonpath=&quot;{.data.password}&quot; | base64 --decode; echo

[root@labs-kube-infra001 keycloak]# k get po -n keycloak
NAME                    READY   STATUS    RESTARTS   AGE
keycloak-0              1/1     Running   0          6m42s
keycloak-postgresql-0   1/1     Running   0          6m42s
[root@labs-kube-infra001 keycloak]# k get svc -n keycloak
NAME                           TYPE           CLUSTER-IP     EXTERNAL-IP       PORT(S)                       AGE
keycloak-headless              ClusterIP      None           &amp;lt;none&amp;gt;            80/TCP,8443/TCP               6m49s
keycloak-http                  LoadBalancer   10.233.3.82    192.168.197.141   80:32242/TCP,8443:31190/TCP   6m49s
keycloak-postgresql            ClusterIP      10.233.7.200   &amp;lt;none&amp;gt;            5432/TCP                      6m49s
keycloak-postgresql-headless   ClusterIP      None           &amp;lt;none&amp;gt;            5432/TCP                      6m49s
[root@labs-kube-infra001 keycloak]# k get statefulset -n keycloak
NAME                  READY   AGE
keycloak              1/1     7m6s
keycloak-postgresql   1/1     7m6s&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 설치가 완료되고 keycloak 서비스에 접근하게 되면 아래와 같은 관리자 화면이 출력됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 로그인 계정은 앞서 helm values.yaml 파일에 설정했던 value를 사용하여 로그인을 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-note conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;note&quot;&gt;
 &lt;p class=&quot;title&quot;&gt;
  참고사항
 &lt;/p&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   docker-compose를 사용할수 있는 예제도 존재하니 테스트를 해보고자 하는 경우 간단히 docker-compose 예제를 다운로드 받아
  &lt;/p&gt;
  &lt;p&gt;
   설치 및 테스트를 수행해보기를 추천드립니다.
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/keycloak/keycloak-containers/tree/master/docker-compose-examples&quot; rel=&quot;nofollow&quot;&gt;
     https://github.com/keycloak/keycloak-containers/tree/master/docker-compose-examples
    &lt;/a&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Keycloak연동하기전에기본적인용어들&quot;&gt;
 Keycloak 연동하기 전에 기본적인 용어들
&lt;/h1&gt;
&lt;p&gt;
 SSO 혹은 Keycloak이 처음이라면 아래의 용어에 우선 친숙해질 필요가 있습니다.
&lt;/p&gt;
&lt;p&gt;
 간단하게 설명된 용어들을 읽어보고 연동을 진행해보기를 추천드립니다.
&lt;/p&gt;
&lt;h5 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Realm&quot;&gt;
 Realm
&lt;/h5&gt;
&lt;ul&gt;
 &lt;li&gt;
  SSO로서 인증 대상의 범위를 지정한다라고 생각하면 됩니다.
 &lt;/li&gt;
 &lt;li&gt;
  Realm을 통해 Namespace 형태로 관리할수 있으며 Metadata와 관련 설정에 대한 모든것을 관리하도록 도와줍니다.
 &lt;/li&gt;
 &lt;li&gt;
  참고로 다수의 realm을 가질수 있고 일반적으로 master(default로 생성된 realm)는 관리자의 목적으로만 사용하고
  &lt;br/&gt;
  다른 realm을 생성하여 사용하기를 권장합니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Client&quot;&gt;
 Client
&lt;/h5&gt;
&lt;ul&gt;
 &lt;li&gt;
  SSO를 사용할 각 Application입니다.
  &lt;br/&gt;
  (즉, 여기서는 Jenkins, Spinnaker가 Client라고 보시면 됩니다.)
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-User&quot;&gt;
 User
&lt;/h5&gt;
&lt;ul&gt;
 &lt;li&gt;
  앞서 설명드린 Client에 실제 로그인할 사용자계정이라 보면됩니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-참고&quot;&gt;
 참고
&lt;/h5&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://jsonobject.tistory.com/445&quot; rel=&quot;nofollow&quot;&gt;
   https://jsonobject.tistory.com/445
  &lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Keycloak과Jenkins연동하기&quot;&gt;
 Keycloak과 Jenkins 연동하기
&lt;/h1&gt;
&lt;p&gt;
 Keycloak과 Jenkins를 연결하여 인증을 Keycloak을 통해서 받을 수 있도록 해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 Keycloak 연동에는 다양한 방식이 있고 역할기반의 제어도 가능하나 여기서는 Jenkins의 경우
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  SAML을 이용한 방식의 로그인만을 연동
 &lt;/strong&gt;
 하는 방법에 대하여 알아볼 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 참고로
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  Jenkins는 jenkins.openlabs:8080 으로 접속되는 환경으로 구성이 이미 완료된 상태입니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-KeycloakSide&quot;&gt;
 Keycloak Side
&lt;/h3&gt;
&lt;p&gt;
 앞서 설명하였던대로 Master가 기본으로 설정되어 있지만 이를 사용하지 않고 새로운 Realm을 생성합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/2.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 생성된 Realm의 Realm Settings로 이동하여 Endpoint를 확인합니다.
&lt;/p&gt;
&lt;p&gt;
 (해당 Endpoint 정보는 Jenkins 의 Keycloak 관련 SAML 설정상에서 사용될 예정입니다.)
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/3.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 클릭해보면 다음과 같은 XML 형태의 문서가 출력되게 됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/4.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 해당 정보를 사전에 복사해둡니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 keycloak를 사용한 인증을 위한 Jenkins Client를 생성합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/5.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 설정은 아래 그림에 체크되어 있는 설정을 추가하여 설정을 마무리 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/6.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 위에 체크된 항목에 대해 추가를 진행한다.
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-note conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;note&quot;&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   만약 설정시 아래와 같은 이슈가 있다면 참고하시기 바랍니다.
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    invalid_redirect_url 에러 관련
    &lt;ul&gt;
     &lt;li&gt;
      Valid Redirect URIs 에 IP 및 domain 정보가 추가되어 있지 않아서 발생된 이슈로 추가시 이슈해결됨.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
   &lt;li&gt;
    로그인후에 자동 로그아웃되는 현상
    &lt;ul&gt;
     &lt;li&gt;
      document signing enable 후에 자동로그아웃되는 현상 사라짐.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-JenkinsSide&quot;&gt;
 Jenkins Side
&lt;/h3&gt;
&lt;p&gt;
 이제 Keycloak SSO를 사용하기 위한 Jenkins의 설정을 추가해 보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 Jenkins의 경우 앞서 Keycloak에서 설정했듯이 SAML을 이용할 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 하여 SAML plugin을 먼저 설치합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/7.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 SAML plugin 설치후 global security 설정에서 아래와 같은 설정을 진행합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/8.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 위에 체크된 항목을 변경하여 설정을 완료합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이제 설정은 완료되었습니다. 아래와 같이 직접 Jenkins UI로 접근을 시도해봅니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/9.gif&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 이제 SSO 연동을 위한 Jenkins 로그인 과정을 완료하였습니다.
&lt;/p&gt;
&lt;p&gt;
 SSO의 경우 한번의 로그인을 통해 다수의 서비스를 사용할수 있는 것이기에 다음 Spinnaker를 SSO와 연동하여 두개의 서비스가
&lt;/p&gt;
&lt;p&gt;
 한번의 로그인으로 이루어질수 있는지 추가로 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-note conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;note&quot;&gt;
 &lt;p class=&quot;title&quot;&gt;
  참고
 &lt;/p&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   Keycloak은 Login Page에 대한 customization을 제공하기 때문에 아래 링크를 활용하여 custom theme를 작성하고
  &lt;/p&gt;
  &lt;p&gt;
   적용하여 자신만의 login page를 구성할수 있습니다.
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://medium.com/@auscunningham/create-a-custom-theme-for-keycloak-8781207be604&quot; rel=&quot;nofollow&quot;&gt;
     https://medium.com/@auscunningham/create-a-custom-theme-for-keycloak-8781207be604
    &lt;/a&gt;
   &lt;/li&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/Alfresco/alfresco-keycloak-theme&quot; rel=&quot;nofollow&quot; style=&quot;letter-spacing: 0.0px;&quot;&gt;
     https://github.com/Alfresco/alfresco-keycloak-theme
    &lt;/a&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Spinnaker와Keycloak&quot;&gt;
 Spinnaker와 Keycloak
&lt;/h1&gt;
&lt;p&gt;
 이번에는 Spinnaker 연동을 해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 앞서 이야기 드렸듯이 Keycloak 연동에는 다양한 방식이 있고 역할기반의 제어도 가능하나 여기서는 spinnaker의 경우
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  OIDC를 이용한 방식의 로그인만을 연동
 &lt;/strong&gt;
 하는 방법에 대하여 알아볼 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 참고로
 &lt;span&gt;
  spinnaker는 spinnaker.openlabs 으로 접속되는 환경으로 구성이 이미 완료된 상태입니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 또한 spinnaker-gate.openlabs:8084로 gate가 접속 가능한 환경입니다.
&lt;/p&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-KeycloakSide.1&quot;&gt;
 Keycloak Side
&lt;/h3&gt;
&lt;p&gt;
 이제 Keycloak에서 spinnaker를 위한 Client를 생성합니다.
&lt;/p&gt;
&lt;p&gt;
 이번에는 keycloak에서 권장하는 OIDC(OpenID Connect)로 설정하여 Client를 생성해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/10.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Jenkins 연동시와 동일하게 Client을 생성합니다.
&lt;/p&gt;
&lt;p&gt;
 (Jenkins 에서 생성했던 Realm을 동일하게 사용하는 것을 가정하였습니다.)
&lt;/p&gt;
&lt;p&gt;
 이후 아래와 같은 설정에 매칭되는 OIDC json 파일의 내용을 확인합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/11.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 실제 Json 내용은 다음과 같습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;{
  &quot;realm&quot;: &quot;Openlabs&quot;,
  &quot;auth-server-url&quot;: &quot;http://keycloak.openlabs/auth/&quot;,
  &quot;ssl-required&quot;: &quot;external&quot;,
  &quot;resource&quot;: &quot;spinnaker&quot;,
  &quot;credentials&quot;: {
    &quot;secret&quot;: &quot;d123150f-2879-4a99-9e22-e40fcaf02bdb&quot;
  },
  &quot;confidential-port&quot;: 0
}&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 여기서 우리는 credentials 정보와 auth-server-url, realm 등을 사용할 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 또한 realm 의 endpoint 정보도 확인해놓습니다.
&lt;/p&gt;
&lt;p&gt;
 아래와 같이 앞서 생성했던 Realm 의 Settings에서 Endpoints 내에 OpenID Endpoint Configuration을 클릭하여 확인이 가능합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/12.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 클릭시 아래와 같은 Json 결과가 출력될 것이고 아래 정보는 spinnaker 설정에서 사용될 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/13.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 실제 사용될 url 정보는 다음과 같습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;authorization_endpoint: &quot;http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/auth&quot;,
token_endpoint: &quot;http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/token&quot;,
userinfo_endpoint: &quot;http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/userinfo&quot;&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-SpinnakerSide&quot;&gt;
 Spinnaker Side
&lt;/h3&gt;
&lt;p&gt;
 이제 spinnaker에서 설정을 진행해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 아시다시피 spinnaker의 경우 halyard pod에 접속하여 (혹은 hal command가 가능한 서버에 접속하여) 설정 변경을 수행해야 합니다.
&lt;/p&gt;
&lt;p&gt;
 하여 halyard pod에 접속하여 hal command를 수행해봅니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;jacob@jacob-laptop:~/workspace$ k get po
NAME                                READY   STATUS      RESTARTS   AGE
spin-clouddriver-5d569c94b8-ffmfs   1/1     Running     0          69d
spin-deck-7754884b55-fq7r4          1/1     Running     0          69d
spin-echo-c57577776-vz8zg           1/1     Running     0          69d
spin-front50-79d4d69b45-klchv       1/1     Running     0          69d
spin-gate-75c76579c4-dxnjp          1/1     Running     0          69d
spin-igor-74d8c59858-zj4bt          1/1     Running     0          69d
spin-orca-f7b8c4676-kfbwp           1/1     Running     0          69d
spin-rosco-7d58898bd6-8h2g5         1/1     Running     0          69d
spinnaker-install-using-hal-x9vds   0/1     Completed   0          70d
spinnaker-minio-5dc587c6f-k9hsx     1/1     Running     0          70d
spinnaker-redis-master-0            1/1     Running     0          70d
spinnaker-redis-slave-0             1/1     Running     0          70d
spinnaker-redis-slave-1             1/1     Running     0          70d
spinnaker-spinnaker-halyard-0       1/1     Running     0          70d
jacob@jacob-laptop:~/workspace$ k exec -it spinnaker-spinnaker-halyard-0 /bin/bash
spinnaker@spinnaker-spinnaker-halyard-0:/workdir$ &lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 실제 halyard pod에서 수행될 명령어들은 다음과 같습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;echo &quot;server:
  tomcat:
    protocolHeader: X-Forwarded-Proto
    remoteIpHeader: X-Forwarded-For
    internalProxies: .*
    httpsServerPort: X-Forwarded-Port
security:
  oauth2:
    enabled: true
    client: 
      clientId: spinnaker
      clientSecret: d123150f-2879-4a99-9e22-e40fcaf02bdb
      userAuthorizationUri: http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/auth
      accessTokenUri: http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/token
      scope: roles,email,profile
    resource:
      userInfoUri: http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/userinfo
    userInfoMapping:
      email: email
      firstName: given_name
      lastName: family_name
      username: preferred_username&quot; &amp;gt; .hal/default/profiles/gate-local.yml
hal config security authn oauth2 edit \
--client-id spinnaker \
--client-secret d123150f-2879-4a99-9e22-e40fcaf02bdb \
--pre-established-redirect-uri http://spinnaker-api.openlabs:8084/login
hal config security authn oauth2 enable
hal config security ui edit --override-base-url http://spinnaker.openlabs:9000
hal config security api edit --override-base-url http://spinnaker-api.openlabs:8084 
hal deploy apply

## 혹은 다음 명령 set 수행
hal config security authn oauth2 edit \
--client-id spinnaker \
--client-secret d123150f-2879-4a99-9e22-e40fcaf02bdb \
--pre-established-redirect-uri http://spinnaker-api.openlabs:8084/login \
--access-token-uri http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/token \
--scope read:roles,email,profile \
--user-authorization-uri http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/auth \
--user-info-mapping-email email \
--user-info-mapping-first-name given_name \
--user-info-mapping-last-name family_name \
--user-info-mapping-username preferred_username \
--user-info-uri http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/userinfo
hal config security authn oauth2 enable
hal config security ui edit --override-base-url http://spinnaker.openlabs:9000
hal config security api edit --override-base-url http://spinnaker-api.openlabs:8084 
hal deploy apply&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 물론 helm chart를 이용한 업그레이드 방법도 가능합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;   additionalProfileConfigMaps:
     create: true
     data:
       gate-local.yml: |-
         server:
           tomcat:
             protocolHeader: X-Forwarded-Proto
             remoteIpHeader: X-Forwarded-For
             internalProxies: .*
             httpsServerPort: X-Forwarded-Port
         security:
           oauth2:
             enabled: true
             client:
               clientId: spinnaker
               clientSecret: xxxx00cc-xxxx-xxxx-xxxx-xxxx2515xxxx
               userAuthorizationUri: http://keycloak.openlabs/auth/realms/openlabs/protocol/openid-connect/auth
               accessTokenUri: http://keycloak.openlabs/auth/realms/openlabs/protocol/openid-connect/token
               scope: roles,email,profile
             resource:
               userInfoUri: http://keycloak.openlabs/auth/realms/openlabs/protocol/openid-connect/userinfo
             userInfoMapping:
               email: email
               firstName: given_name
               lastName: family_name
               username: preferred_username
   additionalScripts:
     create: true
     data: 
       override_baseurls.sh: |-
           $HAL_COMMAND config security api edit --override-base-url http://spinnaker-gate.openlabs:8084/
           $HAL_COMMAND config security ui edit --override-base-url http://spinnaker.openlabs/
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 위 명령 혹은 helm upgrade를 통한 설정 변경을 수행한 후 실제 로그인을 수행해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/14.gif&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 로그인 완료후 아래와 같이 로그인 계정이 확인됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/15.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-확인&quot;&gt;
 확인
&lt;/h1&gt;
&lt;p&gt;
 자 이제 SSO 기능 검증을 위해 두개의 Application을 로그인시도해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/16.gif&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 두개의 Application을 한번의 로그인으로 사용할수 있도록 하는것을 확인할수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-warning conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;warning&quot;&gt;
 &lt;p class=&quot;title&quot;&gt;
  참고사항
 &lt;/p&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-error confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   &lt;strong&gt;
    keycloak에서 권장하는 사항들
   &lt;/strong&gt;
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    SAML을 사용하는 경우
    &lt;ul&gt;
     &lt;li&gt;
      XML 교환방식을 Post Binding 으로 사용하는것을 권장 (보안과 크기제한에 대한 이슈로 인하여)
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
   &lt;li&gt;
    SAML 보다는 OIDC를 권장
    &lt;ul&gt;
     &lt;li&gt;
      &lt;a class=&quot;external-link&quot; href=&quot;https://www.keycloak.org/docs/latest/server_admin/#openid-connect-vs-saml&quot; rel=&quot;nofollow&quot;&gt;
       https://www.keycloak.org/docs/latest/server_admin/#openid-connect-vs-saml
      &lt;/a&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-참고사이트&quot;&gt;
 참고사이트
&lt;/h1&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.keycloak.org/docs/latest/getting_started/index.html&quot; rel=&quot;nofollow&quot;&gt;
   https://www.keycloak.org/docs/latest/getting_started/index.html
  &lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;</description>
        <pubDate>Sat, 04 Apr 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/04/04/91699412/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/04/04/91699412/</guid>
        
        <category>spinnaker</category>
        
        <category>jenkins</category>
        
        <category>keycloak</category>
        
        <category>sso</category>
        
        <category>saml</category>
        
        <category>oidc</category>
        
        
      </item>
    
      <item>
        <title>데이터센터의 클라우드 전환</title>
        <description>&lt;h1 id=&quot;id-데이터센터의클라우드전환-1.클라우드전환개요&quot;&gt;
 &lt;strong&gt;
  1.클라우드 전환 개요
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;p&gt;
 엔터프라이즈 기업의 데이터센터가 변화하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 유닉스 기반의 경직된 시스템 환경에서 스케일 아웃을 통한 확장성 있는 인프라로의 변화를 위하여 많은 기업들이 소프트웨어 정의 데이터센터
 &lt;span&gt;
  (SDDC:Software Defined Data Center)
 &lt;/span&gt;
 를 외치고 있는 실정입니다.
&lt;/p&gt;
&lt;p&gt;
 현재 데이터센터를 자체적으로 보유한 기업들 조차도 신규 서비스 기획 시 사업에 대한 불명확성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 시장 반응들을 살펴볼 수 있는 시스템을 만들기 위하여 하드웨어 박스를 구매하고
 &lt;span&gt;
  ,
 &lt;/span&gt;
 상용 소프트웨어로 도배된 데이터센터 기반 시스템의 사용에 대해 의문을 가지고 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 일부 서비스를 클라우드 서비스 혹은 하이브리드 방식의 클라우드로의 전환을 검토 또는 진행 중에 있습니다.
&lt;/p&gt;
&lt;p&gt;
 퍼블릭 클라우드 인프라 시장도 급속도로 팽창을 하고 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 아래의 표에서도 나타나지만
 &lt;span&gt;
  IaaS, PaaS
 &lt;/span&gt;
 시장은 계속
 &lt;span&gt;
  4
 &lt;/span&gt;
 대 업체로 통합되고 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이들 대형업체는 신규 서비스를 지속적으로 내놓고 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 자신들의 강점 분야를 내세워 데이터센터 고객의 자사 클라우드 유도와 하이브리드 운영 방안에 대한 레퍼런스를 지속적으로 내놓고 있는 상황입니다.
&lt;/p&gt;
&lt;p&gt;
 가트너에 의하면 아마존은 2019년 7월 기준으로 전세계 IaaS 시장의 50% 이상을 여전히 차지하고 있는 것으로 발표하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/91696364/0.jpeg&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 참고
 &lt;span&gt;
  URL:
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.zdnet.co.kr/view/?no=20190730175837&quot; rel=&quot;nofollow&quot;&gt;
   https://www.zdnet.co.kr/view/?no=20190730175837
  &lt;/a&gt;
  (아마존 IaaS 시장 절반 이상 독식)
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  국내의 경우 가장 먼저 진출한 아마존
 &lt;/span&gt;
 &lt;span&gt;
  AWS
 &lt;/span&gt;
 &lt;span&gt;
  가 시장에서 많이 적용되고 있으며
 &lt;/span&gt;
 &lt;span&gt;
  ,
 &lt;/span&gt;
 &lt;span&gt;
  스타트업들에게는 사실상의 표준
 &lt;/span&gt;
 &lt;span&gt;
  (DeFacto Standard)
 &lt;/span&gt;
 &lt;span&gt;
  으로 자리를 잡았습니다
 &lt;/span&gt;
 &lt;span&gt;
  .
 &lt;/span&gt;
 &lt;span&gt;
  본 아티클에서는 엔터프라이즈 관점에서 데이터 센터을 어떻게 퍼블릭 클라우드로 전환하는지에 대해 살펴보려고 합니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  전환의 이유는 무엇인가
  &lt;span&gt;
   ?
  &lt;/span&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 국내 대기업의 데이터센터는 그룹사의
 &lt;span&gt;
  IT
 &lt;/span&gt;
 를 담당하는 회사에서 관리를 주로 하고 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 오픈스택 또는 가상화 기반 하의 클라우드라는 명칭으로 각 그룹 고객사에 서비스 제공하려 많은 노력들을 기울이고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 내부의
 &lt;span&gt;
  IT
 &lt;/span&gt;
 자원의 성능이 훨씬 더 압도적일 것이라 대부분 판단하지만 퍼블릭 클라우드 서비스 업체가 기반 물리 자원에 대한 액세스를 너무나 잘 관리하기 때문에 그 차이가 그렇게 극명하게 나지 않는 것이 일반적입니다.
&lt;/p&gt;
&lt;p&gt;
 또한 내부
 &lt;span&gt;
  ITSM
 &lt;/span&gt;
 시스템의 관제하에 들어가게 되므로 클라우드 컴퓨팅이 제공하는 가치의 많은 부분이 민첩성에서 나온다는 점에서 이를 포기하고 데이터 센터만을 고집하는 것도 좋은 결정은 아닐 것입니다.
 &lt;span&gt;
 &lt;/span&gt;
 이로 인해 퍼블릭 클라우드에 대한 도입 검토와 개념검증
 &lt;span&gt;
  (PoC),
 &lt;/span&gt;
 실제 전환이 활발하게 이루어지고 있는 실정입니다.
&lt;/p&gt;
&lt;p&gt;
 일반적으로 전환 후 록인
 &lt;span&gt;
  (lock-in)
 &lt;/span&gt;
 에 대해서 우려를 하는 기업들도 있겠지만 그러한 록인은 데이터 센터가 훨씬 더 심하며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 기업은 다양한 서버와 운영체제
 &lt;span&gt;
  ,
 &lt;/span&gt;
 애플리케이션
 &lt;span&gt;
  ,
 &lt;/span&gt;
 어플라이언스를 선택하고 원하는 특정 결과를 얻기 위한 과정일 뿐입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  어떻게 전환할 것인가
  &lt;span&gt;
   ?
  &lt;/span&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 클라우드 전환에 있어 중요한 한 가지는 클라우드라는 트렌드에 대한 기업의
 &lt;span&gt;
  ‘
 &lt;/span&gt;
 적응력
 &lt;span&gt;
  ’
 &lt;/span&gt;
 과
 &lt;span&gt;
  ‘
 &lt;/span&gt;
 변화에 대한 의지
 &lt;span&gt;
  ’
 &lt;/span&gt;
 가 가장 클 것입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 쿠팡
 &lt;span&gt;
  (
 &lt;/span&gt;
 쿠팡
 &lt;span&gt;
  , IT
 &lt;/span&gt;
 인프라 전체를
 &lt;span&gt;
  AWS
 &lt;/span&gt;
 클라우드로 이전했다
 &lt;span&gt;
  ,
 &lt;/span&gt;
 기사
 &lt;span&gt;
  :
  &lt;a class=&quot;external-link&quot; href=&quot;https://byline.network/2017/08/10-6/&quot; rel=&quot;nofollow&quot;&gt;
   https://byline.network/2017/08/10-6/
  &lt;/a&gt;
  )
 &lt;/span&gt;
 과 같이 모든 인프라를 퍼블릭 클라우드로 전환하는 경우도 있겠지만
 &lt;span&gt;
  ,
 &lt;/span&gt;
 대부분은 기존에 운영되던 시스템과 고객의 정보
 &lt;span&gt;
  (
 &lt;/span&gt;
 규제를 포함하는
 &lt;span&gt;
  )
 &lt;/span&gt;
 로 인하여
 &lt;span&gt;
  100%
 &lt;/span&gt;
 이전을 못하는 경우가 대다수이다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이로 인해 단계적인 클라우드 전환을 고려하게 되는데
 &lt;span&gt;
  ,
 &lt;/span&gt;
 아래와 같이 데이터 센터와 퍼블릭 클라우드를 연결하여 상호 통신을 할 수 있도록 서비스를 구성하게 됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/91696364/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 데이터센터와 퍼블릭 클라우드
 &lt;span&gt;
  &amp;gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 퍼블릭 클라우드로 전환할 수 있는 단계는 여러가지가 있을 수 있지만 우선 크게
 &lt;span&gt;
  3
 &lt;/span&gt;
 단계에 대한 전환 절차를 고려할 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 첫번째 단계로 대상 시스템 선정 및 기술입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 기존의 내부 시스템에 대한 조사를 통해 퍼블릭 클라우드의 유연성
 &lt;span&gt;
  (
 &lt;/span&gt;
 오토스케일링 같은
 &lt;span&gt;
  )
 &lt;/span&gt;
 을 통해 그 효과를 즉시 확인할 수 있는 시스템들이 그 대상이 될 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이러한 시스템에 대한
 &lt;span&gt;
  AS-IS
 &lt;/span&gt;
 현황 분석을 통해 클라우드 전환 시
 &lt;span&gt;
  TO-BE
 &lt;/span&gt;
 아키텍처를 그릴 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이 때 중요한 것은 전체 업무 대상 시스템이 아니며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 현재 가장 손쉽게 올릴 수 있는
 &lt;span&gt;
  WEB-WAS-DB
 &lt;/span&gt;
 아키텍처를 가진 트래픽의 양 변화가 큰 업무들이 대상이 될 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그 업무 시스템에서 사용하는 기술들이 클라우드로 전환됐을 때
 &lt;span&gt;
  ,
 &lt;/span&gt;
 그대로 옮겨갈 것인지
 &lt;span&gt;
  AWS
 &lt;/span&gt;
 와 같은 클라우드의 네이티브 서비스
 &lt;span&gt;
  (
 &lt;/span&gt;
 예
 &lt;span&gt;
  : ELB, RDS, DynamoDB)
 &lt;/span&gt;
 를 활용할 것인지도 중요한 결정 사항이 될 것입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 두번째 단계로는 시스템 전환입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 대부분의 큰 기업에서는 내부의 데이터센터와 클라우드를 연결하는 것을 기본 전제로 하고 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이 때 서비스를 어떻게 구성할지에 대한 부분의 검토를 하게 되는데
 &lt;span&gt;
  ,
 &lt;/span&gt;
 보통 퍼블릭 클라우드에서는 아래의 방식의 서비스들을 제공하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 기업의 퍼블릭 클라우드 연결 방식
 &lt;span&gt;
  &amp;gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 기업 내의 데이터 센터와의 연결 시 전용선
 &lt;span&gt;
  (
 &lt;/span&gt;
 비용 상승
 &lt;span&gt;
  )
 &lt;/span&gt;
 방식과
 &lt;span&gt;
  VPN
 &lt;/span&gt;
 을 통한 퍼블릭 클라우드 네트워크 연결을 고려할 수 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 비용과 안정성 측면에서 장단점이 존재하므로 전환 시 의사결정이 필요한 부분 중 하나이다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 이후 클라우드 시스템 내의 목표 시스템 설계
 &lt;span&gt;
  ,
 &lt;/span&gt;
 기술 아키텍처를 정의하고 기존의 베어메탈 방식에서 활용되던 개념을 스케일
 &lt;span&gt;
  -
 &lt;/span&gt;
 아웃형 시스템으로 전환 설계 후 전환 작업을 진행한다
 &lt;span&gt;
  .
 &lt;/span&gt;
 전환 단계 상에서 성능
 &lt;span&gt;
  ,
 &lt;/span&gt;
 안정성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 확장성 테스트를 통해 해당 시스템이 처리할 수 있는 능력을 정확하게 파악하고 이를 기준으로 향후 신규 온디맨드 시스템들이 필요한 경우 지표로 삼을 수 있어야 한다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 전환의 방식은 크게 아래와 가지를 들 수 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  Life-and-Shift 방식
  &lt;span&gt;
   :
  &lt;/span&gt;
  기존 시스템의 기능
  &lt;span&gt;
   ,
  &lt;/span&gt;
  소프트웨어 등을 변경하지 않고 그대로 클라우드 이전
 &lt;/li&gt;
 &lt;li&gt;
  Cloud-Native 방식
  &lt;span&gt;
   :
  &lt;/span&gt;
  퍼블릭 클라우드에서 운영할 수 있도록 초기 또는 전환 시점부터 클라우드가 제공하는 서비스 활용에 중점을 두어 이전
 &lt;/li&gt;
 &lt;li&gt;
  오픈소스 전환 방식
  &lt;span&gt;
   :
  &lt;/span&gt;
  클라우드의 이점인 확장성과 비용 효율성을 최대한 살릴 수 있도록 대응 오픈소스로 변경하여 이전
  &lt;span&gt;
   (
  &lt;/span&gt;
  멀티 클라우드 대응
  &lt;span&gt;
   ,
  &lt;/span&gt;
  록인 방지
  &lt;span&gt;
   )
  &lt;/span&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 전환에 대한 목표와 시스템 소프트웨어의 변경에 대한 예시는 다음의 그림과 같습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;img src=&quot;/assets/images/91696364/2.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 클라우드 목표모델 레이어 및 시스템 소프트웨어 변화
 &lt;span&gt;
  &amp;gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 마지막 단계로 운영 서비스로의 이행입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 전환 이후 전체 시스템에 대한 기능
 &lt;span&gt;
  ,
 &lt;/span&gt;
 성능에 대한 상세 모니터링을 진행하고 필요 시 인스턴스 개수 조절
 &lt;span&gt;
  ,
 &lt;/span&gt;
 사이즈 조정 등을 통해 비용최적화를 위한 작업을 진행합니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 이 때의 운영은
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 를 기반으로 한 운영 서비스를 전제로 하고
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 로의 전환
 &lt;span&gt;
  (
 &lt;/span&gt;
 클라우드와
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 툴을 통해 개발자 중심의 자동화 환경 구축
 &lt;span&gt;
  -&amp;gt;
 &lt;/span&gt;
 지속적인 배포
 &lt;span&gt;
  (CD, Continuous Delivery)
 &lt;/span&gt;
 가 가능하게 함으로써 효율성을 확보하고 개발자의 생산성과 비즈니스 민첩성 향상을 위한 기초를 만들 수 있도록 해야 합니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 기업이 가진 시스템에 대한 클라우드 전환은 빅뱅이 되어서는 안됩니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 현재는 차세대 개념의 빅뱅형이 아닌 점진형 방식의 전환을 통해 리스크를 최소화할 수 있는 전략을 구상해야 한다
 &lt;span&gt;
  .
 &lt;/span&gt;
 전환 이후에도 트렌드로 자리잡아가고 있는 마이크로서비스 아키텍처
 &lt;span&gt;
  ,
 &lt;/span&gt;
 컨테이너로의 확장과 자동화를 염두에 둔 전환이 필요한 시점이며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 이를 위한 조직
 &lt;span&gt;
  /
 &lt;/span&gt;
 운영의 관점도 달라져야 할 것입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;h1 id=&quot;id-데이터센터의클라우드전환-2.클라우드기반의컨테이너서비스를활용한PaaS&quot;&gt;
 &lt;strong&gt;
  2. 클라우드 기반의 컨테이너 서비스를 활용한
  &lt;span&gt;
   PaaS
  &lt;/span&gt;
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;p&gt;
 컨테이너 서비스가 대세다
 &lt;span&gt;
  .
 &lt;/span&gt;
 컨테이너는 리소스 격리 프로세스에서 애플리케이션과 종속 항목을 실행하게 해주는 운영 시스템 가상화 방법입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 컨테이너를 사용하면 애플리케이션의 코드
 &lt;span&gt;
  ,
 &lt;/span&gt;
 구성 및 의존성에 대한 사용이 단순한 빌딩 블록 형태로 바로 패키징할 수 있으며 빌딩 블록은 환경 일관성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 운영 효율성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 개발자 생산성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 버전 제어를 제공합니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이를 통해 애플리케이션이 보다 빠르고 안정적으로 배포와 운영이 될 수 있는 환경이 만들어질 수 있는 장점이 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현재 프라이빗
 &lt;span&gt;
  /
 &lt;/span&gt;
 퍼블릭 클라우드 기반의 인프라를 구축하거나 이미 사용하고 있는 엔터프라이즈에서는
 &lt;span&gt;
  DevOps,
 &lt;/span&gt;
 시스템 간의 오케스트레이션을 위하여 적극적으로 컨테이너 서비스에 대한 조사와 도입 검토를 진행하고 있는 상황입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이러한 맥락과 함께 컨테이너 서비스 시장은 현재 엄청난 팽창을 하고 있으며 클라우드와 연계된 기술 영역에서 매년
 &lt;span&gt;
  40%
 &lt;/span&gt;
 이상의 높은 성장률을 통해
 &lt;span&gt;
  2020
 &lt;/span&gt;
 년까지
 &lt;span&gt;
  27
 &lt;/span&gt;
 억 달러 수준으로 커질 것으로 전망하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;img src=&quot;/assets/images/91696364/3.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 애플리케이션 컨테이너 서비스 시장 전망
 &lt;span&gt;
  , 2017. 451 Research’s
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 출처
 &lt;span&gt;
  :
  &lt;a class=&quot;external-link&quot; href=&quot;https://451research.com/images/Marketing/press_releases/Application-container-market-will-reach-2-7bn-in-2020_final_graphic.pdf&quot; rel=&quot;nofollow&quot;&gt;
   https://451research.com/images/Marketing/press_releases/Application-container-market-will-reach-2-7bn-in-2020_final_graphic.pdf
  &lt;/a&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현재 아마존
 &lt;span&gt;
  , IBM,
 &lt;/span&gt;
 마이크로소프트의 퍼블릭 클라우드에서도 이러한 컨테이너 서비스를 통한 애플리케이션 빌딩 블록을 만들 수 있는 서비스를 이미 내놓고 있는 상태이며
 &lt;span&gt;
  , PaaS(Platform as a Service)
 &lt;/span&gt;
 환경을 구축하는 부분에 대해 적극적으로 고객을 유도하고 있는 상황입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현재 컨테이너 서비스들은 대부분 리눅스 환경에서 작동되고
 &lt;span&gt;
  Linux
 &lt;/span&gt;
 컨테이너를 활용하여 개발 팀과 운영 팀 간의 충돌을 줄일 수 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한
 &lt;span&gt;
  , Linux
 &lt;/span&gt;
 컨테이너는
 &lt;span&gt;
 &lt;/span&gt;
 &lt;span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.redhat.com/ko/open-source&quot; rel=&quot;nofollow&quot;&gt;
   오픈소스
  &lt;/a&gt;
 &lt;/span&gt;
 기술을 기반으로 하기 때문에 사용 즉시 최신 기술을 활용하여 회사 내부 인프라 및 애플리케이션에 대한 발전을 시킬 수 있는 특징을 가지고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 &lt;span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;http://thenewstack.io/cri-o-make-kubernetes-center-container-ecosystem/&quot; rel=&quot;nofollow&quot;&gt;
   CRI-O
  &lt;/a&gt;
 &lt;/span&gt;
 ,
 &lt;span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;http://kubernetes.io/&quot; rel=&quot;nofollow&quot;&gt;
   Kubernetes
  &lt;/a&gt;
 &lt;/span&gt;
 및
 &lt;span&gt;
 &lt;/span&gt;
 &lt;span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.redhat.com/ko/topics/containers/what-is-docker&quot; rel=&quot;nofollow&quot;&gt;
   Docker
  &lt;/a&gt;
 &lt;/span&gt;
 등의 컨테이너 기술은 애플리케이션 개발 및 배포를 간소화하고 가속화하는 데 큰 도움이 됩니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  퍼블릭 클라우드의 컨테이너 서비스
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 퍼블릭 클라우드들은 컨테이너를 위한 다양한 서비스를 제공하여 고객들을 자사의 클라우드 서비스로 유도하기 위해 많은 노력을 기울이고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 IBM 클라우드에서는
 &lt;span&gt;
  Blumix Container Service
 &lt;/span&gt;
 를 통해 컨테이너 서비스를 제공하고 있으며,
 &lt;span&gt;
 &lt;/span&gt;
 하위의 인프라 기반은
 &lt;span&gt;
  Kubernetes
 &lt;/span&gt;
 와
 &lt;span&gt;
  Docker
 &lt;/span&gt;
 기반으로 스케줄링
 &lt;span&gt;
  ,
 &lt;/span&gt;
 자체 복구
 &lt;span&gt;
  ,
 &lt;/span&gt;
 스케일
 &lt;span&gt;
  -
 &lt;/span&gt;
 아웃 기능을 제공하고
 &lt;span&gt;
  IBM
 &lt;/span&gt;
 의 인프라에서는 마스터 노드를 관리하며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 사용자들은 자신들의 서비스에 대한 작업 노드를 정의하는 구조로 되어 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 특징적인 부분은
 &lt;span&gt;
  CLI
 &lt;/span&gt;
 기반으로 클러스터 배치 등을 관리하고 강점으로 내세우는 왓슨
 &lt;span&gt;
  (Watson)
 &lt;/span&gt;
 을 활용하여 스토리지
 &lt;span&gt;
  ,
 &lt;/span&gt;
 분석
 &lt;span&gt;
  ,
 &lt;/span&gt;
 액세스 제어 등에 대한 서비스를 통합할 수 있는 기능을 제공하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 아마존은
 &lt;span&gt;
  ECS(Amazon EC2 Container Service)
 &lt;/span&gt;
 서비스를 통해
 &lt;span&gt;
  Docker
 &lt;/span&gt;
 컨테이너를 제공하고 있으며
 &lt;span&gt;
  , EKS(Elastic Kubernetes Service)의
 &lt;/span&gt;
 자체 클러스터 관리 인프라를 구축하여 고객에게 제공하고 있습니다
 &lt;span&gt;
  . SDK
 &lt;/span&gt;
 를 통한
 &lt;span&gt;
  API
 &lt;/span&gt;
 호출을 통해 클러스터 상태관리
 &lt;span&gt;
  ,
 &lt;/span&gt;
 보안
 &lt;span&gt;
  ,
 &lt;/span&gt;
 엘라스틱 로드밸런싱
 &lt;span&gt;
  , EBS
 &lt;/span&gt;
 등에 대한 리소스 연계와 확장을 제공하고 있는 특징이 있으며
 &lt;span&gt;
  , EC2
 &lt;/span&gt;
 서비스 내에 포함되어 컨테이너 서비스에 대한 별도 비용이 필요없다는 특징이 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 마이크로소프트는 애저 컨테이너 서비스를 활용하여 아마치 메소스
 &lt;span&gt;
  , Docker
 &lt;/span&gt;
 등을 함께 사용할 수 있는 서비스를 제공하고 있으며
 &lt;span&gt;
  , 2015
 &lt;/span&gt;
 년에 서비스를 출시했습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 다른 퍼블릭 클라우드와는 다르게
 &lt;span&gt;
  Docker
 &lt;/span&gt;
 를 위한 비주얼 스튜디오
 &lt;span&gt;
  (Visual Studio Tools for Docker)
 &lt;/span&gt;
 를 통해 컨테이너 환경 하에서 윈도우용
 &lt;span&gt;
  .NET
 &lt;/span&gt;
 이나 리눅스용 코어 응용 프로그램을 빌드하여 배포할 수 있는 기능을 제공하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한 비주얼 스튜디오 팀 서비스를 통해 애자일 및
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 를 위한 워크플로우에 컨테이너를 통합할 수 있는 기능을 제공하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Docker
 &lt;/strong&gt;
 &lt;strong&gt;
  를 통한 기술
  &lt;span&gt;
   /
  &lt;/span&gt;
  프로세스 표준화
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 프라이빗과 퍼블릭 클라우드의 방향성은
 &lt;span&gt;
  IaaS
 &lt;/span&gt;
 기반에서 컨테이너 서비스를 통한 플랫폼 유연성을 극대화하는 방법으로도 진화하고 있습니다
 &lt;span&gt;
  . Docker
 &lt;/span&gt;
 는 별도의 게스트
 &lt;span&gt;
  OS
 &lt;/span&gt;
 를 설치하지 않고 커널 레벨에서 격리된 가상의 공간을 제공한다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이의 장점은 호스트 운영체제와의 속도 차이가 거의 없고 가상머신보다 경량화된 상태에서 관리를 할 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/91696364/4.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 클라우드
 &lt;span&gt;
  ,
 &lt;/span&gt;
 컨테이너
 &lt;span&gt;
  ,
 &lt;/span&gt;
 마이크로서비스
 &lt;span&gt;
  , DevOps
 &lt;/span&gt;
 구조
 &lt;span&gt;
  , DZone
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 출처
 &lt;span&gt;
  :
  &lt;a class=&quot;external-link&quot; href=&quot;https://dzone.com/articles/markus-eisele-answers-questions-about-java-ee-and&quot; rel=&quot;nofollow&quot;&gt;
   https://dzone.com/articles/markus-eisele-answers-questions-about-java-ee-and
  &lt;/a&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현재 많은 기업들이 자사의 서비스 기반을 마이크로 아키텍처 서비스로 만들고자 하면서 컨테이너 서비스를 활용하고 이에 대한 내부 기술 표준화를 위한 시도를 많이 하고 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한 개발
 &lt;span&gt;
  /
 &lt;/span&gt;
 배포
 &lt;span&gt;
  /
 &lt;/span&gt;
 운영 프로세스에 대한 부분을 컨테이너 서비스를 통해 일원화하기 위한 노력도 병행하고 있습니다
 &lt;span&gt;
  . MSA(Micro Service Architecture)
 &lt;/span&gt;
 를 컨테이너 기반으로 구성하는데 있어 프로세스화 되어야 하는 부분은
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 영역입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 컨테이너는 이러한
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 영역에 대한 부분을 통합할 수 있도록 하는 좋은 방법 중의 하나입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 컨테이너는 개발과 운영이라는 두 팀간의 장벽을 허무는
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 의 가교 역할을 하게 되며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 두 팀이 함께 협업하여 개발자 생산성과 운영의 안정성이라는 두 마리 토끼를 잡게 해줍니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그러한 관점에서 인프라
 &lt;span&gt;
  ,
 &lt;/span&gt;
 컨테이너
 &lt;span&gt;
  ,
 &lt;/span&gt;
 미들웨어 컴포넌트를 컨테이너화함으로써 클라우드 네이티브 형태의 애플리케이션을 만들 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한 기업이 가진 업무 시스템을 최적화하는 방법으로 컨테이너화된 다양한 오픈소스 기술을 활용하여 비즈니스적인 목표를 달성할 수도 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이를 도식화한 간략한 그림은 아래와 같습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/91696364/5.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 클라우드 네이티브 영역 지도
 &lt;span&gt;
  (
  &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/cncf/landscape&quot; rel=&quot;nofollow&quot;&gt;
   https://github.com/cncf/landscape
  &lt;/a&gt;
 &lt;/span&gt;
 의 도식도를 축약한 것임
 &lt;span&gt;
  )
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그림에서 보는 것처럼 컨테이너 서비스는 그 기반이 퍼블릭과 프라이빗과 상관없이 작동시키며 프로비저닝 자동화
 &lt;span&gt;
  ,
 &lt;/span&gt;
 프로세스 개선
 &lt;span&gt;
  , DevOps
 &lt;/span&gt;
 를 활용할 수 있는 기반을 마련해줍니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한 조직이 소프트웨어 개발과 인프라 관리 프로세스의 자동화 및 간소화를 통해 더 빠르게 혁신할 수 있도록 지원하며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 이를 통한 비즈니스 이익이 극대화될 수 있도록 도와줍니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 컨테이너
 &lt;span&gt;
  , PaaS, DevOps
 &lt;/span&gt;
 는 상호 연결된 밀접한 단어이다
 &lt;span&gt;
  .
 &lt;/span&gt;
 아직
 &lt;span&gt;
  IaaS
 &lt;/span&gt;
 를 기반으로 한 클라우드
 &lt;span&gt;
  (
 &lt;/span&gt;
 퍼블릭
 &lt;span&gt;
  /
 &lt;/span&gt;
 클라우드
 &lt;span&gt;
  )
 &lt;/span&gt;
 에 대한 경험이 없는 상태라 하더라도 기획을 해볼 수 있는 중요한 아이템이 바로 컨테이너 기반
 &lt;span&gt;
  PaaS
 &lt;/span&gt;
 영역이다
 &lt;span&gt;
  .
 &lt;/span&gt;
 인프라 자동화
 &lt;span&gt;
  , DevOps, MSA
 &lt;/span&gt;
 등의 단어를 의식하고 있다면 클라우드 기반의 컨테이너 서비스 대한 적극적 검토를 해보아야 하며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 향후 펼쳐지게 될
 &lt;span&gt;
  IT
 &lt;/span&gt;
 시스템의 변화에 대한 준비를 해야 할 것입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;</description>
        <pubDate>Wed, 25 Mar 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/03/25/91696364/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/03/25/91696364/</guid>
        
        <category>클라우드</category>
        
        <category>docker</category>
        
        <category>cncf</category>
        
        <category>msa</category>
        
        
      </item>
    
      <item>
        <title>[Container 시리즈] 03. Docker File, Docker Image - 도커파일 및 이미지에 대하여</title>
        <description>&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-information conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;info&quot;&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   도커를 설치하고 컨테이너를 실행해봤으니 이제는 도커 이미지를 만들고 서버에 배포해볼 차례!
  &lt;/p&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  도커 개념에서도 다뤄봤듯이, 도커는 도커 파일을 가지고 도커 이미지를 만들게 되는데요,
 &lt;/p&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   다시 한번 말씀드리자면, Docker File이란 Docker Image를 만들기 위한 여러가지 명렁어의 집합입니다.
  &lt;/p&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
  프로페셔널한 엔지니어라면 뚝딱뚝딱 Dockerfile을 만들 수 있지만
 &lt;/p&gt;
 &lt;p&gt;
  저는 초보자이기 때문에 서버에 명령어를 입력하고 버그를 잡아가면서 Dockerfile을 한 땀 한 땀 만듭니다.
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/91695884/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  만약에 여러분이 우분투 서버에서 nginx를 설치해서 실행한다고 가정했을 시
순서는 다음과 같습니다.
 &lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;
   ubuntu 설치
  &lt;/li&gt;
  &lt;li&gt;
   패키지 업데이트
  &lt;/li&gt;
  &lt;li&gt;
   nginx 설치
  &lt;/li&gt;
  &lt;li&gt;
   경로설정 (필요한 경우)
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;p&gt;
  먼저 리눅스 서버에서 한줄한줄 테스트를 해봅니다
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;## 1. ubuntu 설치 &amp;amp; 2. 패키지 업데이트
# 테스트 ubuntu 서버를 사용하였기 때문에 패키지 업데이트를 먼저 합니다.

kbseo@KB-SEO:~$ sudo apt-get update
[sudo] password for kbseo:
Hit:1 http://mirror.kakao.com/ubuntu bionic InRelease
Get:2 http://mirror.kakao.com/ubuntu bionic-updates InRelease [88.7 kB]
Get:3 http://mirror.kakao.com/ubuntu bionic-backports InRelease [74.6 kB]
Get:4 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB]
Get:5 http://mirror.kakao.com/ubuntu bionic-updates/main amd64 Packages [872 kB]
Get:6 http://mirror.kakao.com/ubuntu bionic-updates/main Translation-en [303 kB]
Get:7 http://mirror.kakao.com/ubuntu bionic-updates/restricted amd64 Packages [32.9 kB]
Get:8 http://mirror.kakao.com/ubuntu bionic-updates/restricted Translation-en [8468 B]
Get:9 http://mirror.kakao.com/ubuntu bionic-updates/universe amd64 Packages [1055 kB]
Get:10 http://mirror.kakao.com/ubuntu bionic-updates/universe Translation-en [326 kB]
Get:11 http://mirror.kakao.com/ubuntu bionic-updates/multiverse amd64 Packages [10.1 kB]
Get:12 http://mirror.kakao.com/ubuntu bionic-updates/multiverse Translation-en [4636 B]
Get:13 http://mirror.kakao.com/ubuntu bionic-backports/universe amd64 Packages [4028 B]
Get:14 http://security.ubuntu.com/ubuntu bionic-security/main amd64 Packages [651 kB]
Get:15 http://security.ubuntu.com/ubuntu bionic-security/main Translation-en [211 kB]
Get:16 http://security.ubuntu.com/ubuntu bionic-security/restricted amd64 Packages [23.8 kB]
Get:17 http://security.ubuntu.com/ubuntu bionic-security/restricted Translation-en [6528 B]
Get:18 http://security.ubuntu.com/ubuntu bionic-security/universe amd64 Packages [648 kB]
Get:19 http://security.ubuntu.com/ubuntu bionic-security/universe Translation-en [215 kB]
Get:20 http://security.ubuntu.com/ubuntu bionic-security/multiverse amd64 Packages [6756 B]
Get:21 http://security.ubuntu.com/ubuntu bionic-security/multiverse Translation-en [2700 B]
Fetched 4634 kB in 6s (739 kB/s)
Reading package lists... Done
kbseo@KB-SEO:~$

## 3. nginx 설치
kbseo@KB-SEO:~$ sudo apt-get install nginx
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  fontconfig-config fonts-dejavu-core libfontconfig1 libgd3 libjbig0 libjpeg-turbo8 libjpeg8 libnginx-mod-http-geoip
  libnginx-mod-http-image-filter libnginx-mod-http-xslt-filter libnginx-mod-mail libnginx-mod-stream libtiff5 libwebp6
  libxpm4 nginx-common nginx-core
Suggested packages:
  libgd-tools fcgiwrap nginx-doc ssl-cert
The following NEW packages will be installed:
  fontconfig-config fonts-dejavu-core libfontconfig1 libgd3 libjbig0 libjpeg-turbo8 libjpeg8 libnginx-mod-http-geoip
  libnginx-mod-http-image-filter libnginx-mod-http-xslt-filter libnginx-mod-mail libnginx-mod-stream libtiff5 libwebp6
  libxpm4 nginx nginx-common nginx-core
0 upgraded, 18 newly installed, 0 to remove and 239 not upgraded.
Need to get 2461 kB of archives.
After this operation, 8210 kB of additional disk space will be used.
Do you want to continue? [Y/n] y
...
...
#이하 생략
#설치 확인
kbseo@KB-SEO:~$ nginx -v
nginx version: nginx/1.14.0 (Ubuntu)
kbseo@KB-SEO:~$

# 설치파일 경로
kbseo@KB-SEO:/etc/nginx$ pwd
/etc/nginx

&lt;/code&gt;&lt;/pre&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   여기서 잠깐
  &lt;/p&gt;
  &lt;blockquote&gt;
   &lt;ul&gt;
    &lt;li&gt;
     저희는 nginx를 패키지를 통하여 설치 하였기에 Default directory가 /etc/nginx 아래에 위치하게 됩니다.
    &lt;/li&gt;
    &lt;li&gt;
     직접 compile한 경우에 경로는 /usr/local/nginx/conf 혹은 /use/local/etc/nginx 에 위치하고 있습니다.
    &lt;/li&gt;
    &lt;li&gt;
     그래도 경로가 없다 한다면 다음의 명령어를 통해 찾을 수 있습니다.
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;pre&gt;&lt;code&gt;kbseo@KB-SEO:/etc/nginx$ sudo find / -name nginx.conf
/etc/nginx/nginx.conf
&lt;/code&gt;&lt;/pre&gt;
  &lt;/blockquote&gt;
 &lt;/blockquote&gt;
 &lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;
   경로설정 (필요한 경우)
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;kbseo@KB-SEO:/etc/nginx$ ls
conf.d        fastcgi_params  koi-win     modules-available  nginx.conf    scgi_params      sites-enabled  uwsgi_params
fastcgi.conf  koi-utf         mime.types  modules-enabled    proxy_params  sites-available  snippets       win-utf

# 기본적인 환경 설정 파일 정보는 sites-available/default 이곳에 있습니다.
# 따라서 웹서버의 루트 디렉토리 변경 등의 작업이 필요하다면 이곳에 들어가 작업하시면 됩니다.

kbseo@KB-SEO:/etc/nginx$ vim sites-available/default

&lt;/code&gt;&lt;/pre&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/91695884/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  &lt;em&gt;
   설정하실때 세미콜론(;) 잊지 말아쥬세염
  &lt;/em&gt;
 &lt;/p&gt;
 &lt;p&gt;
  저는 테스트이기 때문에 따로 경로 설정은 안하고 Default로 두었습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;# index.html 를 만든 후 찍어 봅니다.
kbseo@KB-SEO:/var/www/html$ sudo service nginx restart
 * Restarting nginx nginx                                           [ OK ]
kbseo@KB-SEO:/var/www/html$
kbseo@KB-SEO:/var/www/html$ curl 127.0.0.1
Hello KB
&lt;/code&gt;&lt;/pre&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91695884/2.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;hr/&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#이제는-이런-한땀한땀-구축한-명령어를-토대로-docker-file을-만들어-보겠습니다&quot; id=&quot;이제는-이런-한땀한땀-구축한-명령어를-토대로-docker-file을-만들어-보겠습니다&quot;&gt;
   이제는 이런 한땀한땀 구축한 명령어를 토대로 docker file을 만들어 보겠습니다.
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;ol&gt;
  &lt;li&gt;
   ubuntu 설치
  &lt;/li&gt;
  &lt;li&gt;
   패키지 업데이트
  apt-get update
  &lt;/li&gt;
  &lt;li&gt;
   nginx 설치
  apt-get install nginx
  &lt;/li&gt;
  &lt;li&gt;
   경로설정 (필요한 경우)
  cd /etc/nginx
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;br/&gt;
 &lt;p&gt;
  위와 같은 순서로 한줄한줄 수작업을 해 주었는데
Docker file은 어떨까요?
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;FROM ubuntu:14.04 
MAINTAINER Dongbin Na &quot;kbseo@osci.kr&quot; 
RUN apt-get update
RUN apt-get install -y nginx
WORKDIR /etc/nginx 
CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
EXPOSE 80 
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;br/&gt;
  &lt;br/&gt;
  docker file이 거의 흡사하게 작성된 것을 보실 수 있습니다.
아마 도커파일에 있는 내용들이 생소하실 여러분(저를 포함)을 위해 하나하나 뜯어 보도록 할까요?
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   1. FROM ubuntu:14.04
  &lt;/code&gt;
  -&amp;gt; 기반으로 할 이미지를 가져옵니다.
여기에서는 ubuntu 14.04버전의 이미지를 가져오겠습니다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   2. MAINTAINER Dongbin Na &quot;kbseo@osci.kr&quot;
  &lt;/code&gt;
  -&amp;gt; 작성자의 정보를 기입해줍니다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   3. RUN apt-get update
  &lt;/code&gt;
  -&amp;gt; RUN이라는 명령어를 통하여 쉘 스크립트를 실행하여 줍니다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   4. RUN apt-get install -y nginx
  &lt;/code&gt;
  -&amp;gt; 도커 빌드 중에는 키보드를 입력할 수 없기에
  &lt;em&gt;
   [-y]
  &lt;/em&gt;
  옵션을 넣어줍니다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   5. WORKDIR /etc/nginx
  &lt;/code&gt;
  -&amp;gt; 이후 CMD 명령어가 실행 할 경로로 먼저 이동을 해 줍니다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   6. CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
  &lt;/code&gt;
  -&amp;gt; nginx를 백그라운드로 실행합니다
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   7. EXPOSE 80
  &lt;/code&gt;
  -&amp;gt; 80번 포트를 오픈하여 웹서버에 정상적으로 접근할 수 있게 합니다.
  &lt;br/&gt;
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  아직까지 Dockerfile 명령어들이 익숙치 않으시죠?
  &lt;del&gt;
   아니라고 해도
  &lt;/del&gt;
  명령어들은 좀더 나눠서 알아보겠습니다.
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
   &lt;tr&gt;
    &lt;th align=&quot;left&quot;&gt;
     명렁어
    &lt;/th&gt;
    &lt;th align=&quot;center&quot;&gt;
     내용
    &lt;/th&gt;
    &lt;th align=&quot;center&quot;&gt;
     예시
    &lt;/th&gt;
    &lt;th align=&quot;center&quot;&gt;
    &lt;/th&gt;
   &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      FROM
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     - 베이스 이미지를 지정해줍니다.
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     FROM &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     FROM ubuntu:14.04
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  &lt;em&gt;
   -&amp;gt; 베이스 이미지는 반드시 지정해줘야하며, 버전정보는 latest보다는 구체적인 버전을 지정해주는것이 좋습니다.
  &lt;/em&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      RUN
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     - 직접적으로 쉘 스크립트 내에서 실행 될 명령어 앞에 적어줍니다.
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     RUN &amp;lt;command&amp;gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     RUN apt-get update
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  &lt;em&gt;
   -&amp;gt; 실질적으로 가장 많이 쓰이는 명령어 입니다
  &lt;/em&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      CMD
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     - 도커가 실행될 때 실행할 명령어를 정의해줍니다.
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     CMD [&quot;executable&quot;, &quot;param&quot;, &quot;param&quot;]
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  &lt;em&gt;
   -&amp;gt; 도커 빌드시에는 실행되지 않으며, 여러개의 CMD 명령어가 존재할 경우 가장 마지막 명령어만 실행 됩니다.
  &lt;/em&gt;
  &lt;em&gt;
   CMD nginx 라고 입력하면 nginx 서버를 구동시키게 됩니다.
  &lt;/em&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      WORKDIR
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     - 이후 명령어가 작업할 디렉토리로 이동합니다
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     WORKDIR /path
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     WORKDIR /etc/nginx
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  &lt;em&gt;
   -&amp;gt; 명령어(RUN, CMD ) 등이 실행될 디렉토리를 설정합니다.
  &lt;/em&gt;
  &lt;em&gt;
   각 명령어는 줄마다 초기화가 되기 때문에 'RUN cd /path' 로 경로를 잡아줘도 다음줄에선 다시 위치가 초기화가 됩니다.
  &lt;/em&gt;
  &lt;em&gt;
   같은 디렉토리에서 계속 작업하기 위하여 WORKDIR을 사용해줍니다.
  &lt;/em&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      COPY
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     - 파일이나 디렉토리를 이미지로 복사합니다
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     COPY &amp;lt;src&amp;gt; &amp;lt;dst&amp;gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     COPY . /usr/src/app
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  &lt;em&gt;
   -&amp;gt; 일반적으로 소스를 복사하는데 사용합니다
  &lt;/em&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      ADD
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     - COPY와 비슷하게 복사를 위해 사용합니다
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     ADD &amp;lt;src&amp;gt; &amp;lt;dst&amp;gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     ADD . /usr/src/app
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  &lt;em&gt;
   -&amp;gt; COPY명령어와 비슷하게 소스를 복사하는데 사용하지만 차이점은 ADD같은경우 압축파일이 있을 경우 자동으로 압축을 해제하면서 복사됩니다.
  &lt;/em&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      EXPOSE
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     - 공개 하고자 하는 포트를 지정해줍니다
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     EXPOSE &amp;lt;port&amp;gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     EXPOSE 80
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  &lt;em&gt;
   -&amp;gt; 호스트와 연결해줄 포트를 지정해주며, 여러개의 포트를 지정할 수 있습니다.
  &lt;/em&gt;
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  이 밖에 사용되는
  &lt;code&gt;
   ENV
  &lt;/code&gt;
  ,
  &lt;code&gt;
   VOLUME
  &lt;/code&gt;
  같은 명령어는
  &lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot;&gt;
   공식문서
  &lt;/a&gt;
  를 참고 바랍니다
 &lt;/p&gt;
 &lt;p&gt;
  &lt;br/&gt;
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#dockerfile을-만들었으니-build를-해봅시다&quot; id=&quot;dockerfile을-만들었으니-build를-해봅시다&quot;&gt;
   Dockerfile을 만들었으니 Build를 해봅시다.
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;docker build --force-rm --tag mynginx:0.1 .
&lt;/code&gt;&lt;/pre&gt;
 &lt;ul&gt;
  &lt;li&gt;
   --force-rm : 기존에 존재하는 image를 삭제합니다.
  &lt;/li&gt;
  &lt;li&gt;
   --tag : 태그를 설정해줍니다.
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;
[kbseo@ip-172-20-1-221 docker]$ docker build --force-rm --tag mynginx:0.1 .
Sending build context to Docker daemon  2.048kB
Step 1/7 : FROM ubuntu:14.04
14.04: Pulling from library/ubuntu
2e6e20c8e2e6: Pull complete 
30bb187ac3fc: Pull complete 
b7a5bcc4a58a: Pull complete 
Digest: sha256:ffc76f71dd8be8c9e222d420dc96901a07b61616689a44c7b3ef6a10b7213de4
Status: Downloaded newer image for ubuntu:14.04
 ---&amp;gt; 6e4f1fe62ff1
Step 2/7 : MAINTAINER Dongbin Na &quot;kbseo@osci.kr&quot;
 ---&amp;gt; Running in 224535a7dd96
Removing intermediate container 224535a7dd96
 ---&amp;gt; dc0f4b41cf96
Step 3/7 : RUN apt-get update
 ---&amp;gt; Running in 1e6d817f7aa0
...
...
Removing intermediate container 1e6d817f7aa0
 ---&amp;gt; bf2a670332b6
Step 4/7 : RUN apt-get install -y nginx
 ---&amp;gt; Running in b5fe65990ed8
...
...
Removing intermediate container b5fe65990ed8
 ---&amp;gt; 6664b9edcc36
Step 5/7 : WORKDIR /etc/nginx
 ---&amp;gt; Running in 34f5b2fe1f42
Removing intermediate container 34f5b2fe1f42
 ---&amp;gt; bc81d2ba24e1
Step 6/7 : CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
 ---&amp;gt; Running in 45d49d210fea
Removing intermediate container 45d49d210fea
 ---&amp;gt; 44591f5b5a0c
Step 7/7 : EXPOSE 80
 ---&amp;gt; Running in b98221c6597d
Removing intermediate container b98221c6597d
 ---&amp;gt; 747275175211
Successfully built 747275175211
Successfully tagged mynginx:0.1
[kbseo@ip-172-20-1-221 docker]$ 

# 이미지확인
[kbseo@ip-172-20-1-221 docker]$ docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
mynginx                      0.1                 747275175211        12 minutes ago      231MB
registry                     latest              708bc6af7e5e        7 weeks ago         25.8MB
ubuntu                       14.04               6e4f1fe62ff1        2 months ago        197MB
localhost:5000/hello-world   latest              fce289e99eb9        14 months ago       1.84kB
hello-world                  latest              fce289e99eb9        14 months ago       1.84kB
[kbseo@ip-172-20-1-221 docker]$ 

&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;br/&gt;
  &lt;br/&gt;
  빌드가 완료되어 Docker Image가 만들어진 것을 확인할 수 있는데요
이 빌드가 되는 과정들도 또 하나하나 살펴보도록 하겠습니다.
 &lt;/p&gt;
 &lt;p&gt;
  빌드과정을 요약하면 다음과 같습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;Sending build context to Docker daemon  2.048kB               &amp;lt;---   [1]
Step 1/7 : FROM ubuntu:14.04                                  &amp;lt;---   [2]            
14.04: Pulling from library/ubuntu                            &amp;lt;---   [3]
 ---&amp;gt; 6e4f1fe62ff1                                            &amp;lt;---   [4]
Step 2/7 : MAINTAINER Dongbin Na &quot;kbseo@osci.kr&quot;              &amp;lt;---   [5]
 ---&amp;gt; Running in 224535a7dd96                                 &amp;lt;---   [6]
Removing intermediate container 224535a7dd96                  &amp;lt;---   [7]
 ---&amp;gt; dc0f4b41cf96                                            &amp;lt;---   [8]
Step 3/7 : RUN apt-get update                                 &amp;lt;---   [9]
 ---&amp;gt; Running in 1e6d817f7aa0
...
Successfully built 747275175211                               &amp;lt;---   [10]
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [1]
  &lt;/strong&gt;
  &lt;code&gt;
   Sending build context to Docker daemon 2.048kB
  &lt;/code&gt;
  &lt;br/&gt;
  도커는 서버 클라이언트 구조이기 때문에 작업할 도커파일들(build context)을 도커서버(daemon)으로 전송해줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [2]
  &lt;/strong&gt;
  &lt;code&gt;
   Step 1/7 : FROM ubuntu:14.04
  &lt;/code&gt;
  &lt;br/&gt;
  빌드할 도커파일의 제일 윗줄부터 한줄한줄 실행하여 줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [3]
  &lt;/strong&gt;
  &lt;code&gt;
   14.04: Pulling from library/ubuntu
  &lt;/code&gt;
  &lt;br/&gt;
  ubuntu라는 이미지를 repository에서 다운받는 작업을 합니다
기본적으로 DockerHub Repository를 사용하고 있으며 사용자가 별도의 저장소를 지정할 수 있습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [4]
  &lt;/strong&gt;
  &lt;code&gt;
   ---&amp;gt; 6e4f1fe62ff1
  &lt;/code&gt;
  &lt;br/&gt;
  다운받은 ubuntu 이미지의 ID를 출력해줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [5]
  &lt;/strong&gt;
  &lt;code&gt;
   Step 2/7 : MAINTAINER Dongbin Na &quot;kbseo@osci.kr&quot;
  &lt;/code&gt;
  &lt;br/&gt;
  도커파일의 두번째 명령어를 실행해줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [6]
  &lt;/strong&gt;
  &lt;code&gt;
   ---&amp;gt; Running in 224535a7dd96
  &lt;/code&gt;
  &lt;br/&gt;
  도커는 이미지 형태로 저장하기 때문에 바로위에서 실행한 우분투 이미지 '6e4f1fe62ff1'를 기반으로 임시 컨테이너 '224535a7dd96' 를 만듭니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [7],[8]
  &lt;/strong&gt;
  &lt;br/&gt;
  &lt;code&gt;
   Removing intermediate container 224535a7dd96
  &lt;/code&gt;
  &lt;br/&gt;
  &lt;code&gt;
   ---&amp;gt; dc0f4b41cf96
  &lt;/code&gt;
  &lt;br/&gt;
  임시로 실행했던 컨테이너 '224535a7dd96'를 삭제해주고 새로운 이미지 'dc0f4b41cf96'를 만듭니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [9]
  &lt;/strong&gt;
  &lt;code&gt;
   Step 3/7 : RUN apt-get update
  &lt;/code&gt;
  &lt;br/&gt;
  도커파일에 작성하였던 다음줄의 명령어를 실행해줍니다.
이전 단계 에서처럼 _전에 만들어진 이미지를 기반으로 임시 컨테이너를 만들어 명령어를 실행하고 이를 또 다른 이미지로 저장을 한 후 임시 컨테이너는 삭제_하여줍니다.
이러한 과정을 도커파일의 마지막 명령줄까지 반복합니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [10]
  &lt;/strong&gt;
  &lt;code&gt;
   Successfully built 747275175211
  &lt;/code&gt;
  &lt;br/&gt;
  최종적으로 만들어진 이미지ID를 멋지게 출력해줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  좀 전에 빌드했던 도커파일을 다시 빌드하게 되면 처음 빌드했을 때 보다 훨씬 빨라지게 되는데요
그 이유는, 명령어를 실행할 때 이미지 위에 레이어를 추가하는 형태로 저장을 하게 되고 재 빌드를 하게 되면 기존에 저장된 이미지를 그대로 캐시처럼 사용하여 빌드 하기 때문입니다. (변경된 사항이 없다면)
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;# 재빌드
Sending build context to Docker daemon  2.048kB
Step 1/7 : FROM ubuntu:14.04
 ---&amp;gt; 6e4f1fe62ff1
Step 2/7 : MAINTAINER Dongbin Na &quot;kbseo@osci.kr&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; dc0f4b41cf96
Step 3/7 : RUN apt-get update
 ---&amp;gt; Using cache
 ---&amp;gt; bf2a670332b6
Step 4/7 : RUN apt-get install -y nginx
 ---&amp;gt; Using cache
 ---&amp;gt; 6664b9edcc36
Step 5/7 : WORKDIR /etc/nginx
 ---&amp;gt; Using cache
 ---&amp;gt; bc81d2ba24e1
Step 6/7 : CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
 ---&amp;gt; Using cache
 ---&amp;gt; 44591f5b5a0c
Step 7/7 : EXPOSE 80
 ---&amp;gt; Using cache
 ---&amp;gt; 747275175211
Successfully built 747275175211

&lt;/code&gt;&lt;/pre&gt;
 &lt;br/&gt;
 이러한 도커빌드 원리를 이해하고 있으면 도커파일을 만들 때 효과적으로 만드실 수 있습니다.
 &lt;blockquote&gt;
  &lt;p&gt;
   참고로 명렁어를 주르륵 나열하기보단 최대한 간결하고 '&amp;amp;&amp;amp;' 명령어를 이용해 줄여서 적어주는것이 좋습니다! (스토리지 엔진에 따라 이미지 개수가 제한되는 경우도 있기때문)
  &lt;/p&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
  &lt;br/&gt;
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  ###빌드한 이미지는 각 서버에 어떻게 배포할까요?
 &lt;/p&gt;
 &lt;p&gt;
  도커는 이미지를 각각의 서버에 복사하는 방법 대신 저장소(Registry)를 이용합니다.
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/91695884/3.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  여기서 이미지를 저장소에 업로드할때 'puch' 명령어를 사용하고,
각 서버에서 저장소에 올려져있는 이미지를 가져올때 'pull'이라는 명령어를 사용합니다.
 &lt;/p&gt;
 &lt;br/&gt;
 저번시간에 tag에 대하여 스르륵 지나갔었는데
이미지 이야기를 하는김에 같이 다뤄보도록 하겠습니다.
 &lt;br/&gt;
 &lt;h4&gt;
  &lt;a href=&quot;#이미지-태그에-관하여&quot; id=&quot;이미지-태그에-관하여&quot;&gt;
   이미지 태그에 관하여
  &lt;/a&gt;
 &lt;/h4&gt;
 &lt;p&gt;
  'docker tag &amp;lt;옵션&amp;gt; &amp;lt;이미지 이름&amp;gt;:&amp;lt;태그&amp;gt; &amp;lt;저장소 주소, 사용자명&amp;gt;/&amp;lt;이미지이름&amp;gt;:&amp;lt;태그&amp;gt;'
굉장히 복잡해 보입니다...
 &lt;/p&gt;
 &lt;p&gt;
  저장소 주소는 기본적으로 Docker hub를 바라보고 있고, 사용자 ID를 지정해주지 않으면 기본으로 library를 사용합니다.
  &lt;br/&gt;
  즉,
'&amp;lt;저장소 주소, 사용자명&amp;gt;/&amp;lt;이미지이름&amp;gt;:&amp;lt;태그&amp;gt;'는
docker.io/library/nginx = library/nginx = nginx
이렇게 추릴수도 있습니다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;em&gt;
   이미지 이름 변경
  &lt;/em&gt;
 &lt;/p&gt;
 &lt;p&gt;
  'docker tag &amp;lt;reponame&amp;gt;:&amp;lt;old_name&amp;gt; &amp;lt;new_reponame&amp;gt;:&amp;lt;new_name&amp;gt;
-&amp;gt; 이름을 변경한다기 보다는 복제라고 보는게 더 맞습니다.
예시) 'docker tag mynginx:0.2 kbseonginx:0.1'
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;#before
[kbseo@ip-172-20-1-221 docker]$ docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
mynginx                      0.1                 747275175211        25 hours ago        231MB
mynginx                      0.2                 747275175211        25 hours ago        231MB

#after
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
kbseonginx                   0.1                 747275175211        25 hours ago        231MB
mynginx                      0.1                 747275175211        25 hours ago        231MB
mynginx                      0.2                 747275175211        25 hours ago        231MB
 

&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  이렇게 해서 이번 시간에는 Docker File과 Image에 대하여 알아보았는데요
 &lt;/p&gt;
 &lt;p&gt;
  다음번에는 실질적으로 사용하고 있는 application을 어떻게 Dockerized 할 것인가
 &lt;/p&gt;
 &lt;p&gt;
  라는 주제로 다시 찾아뵙도록 하겠습니다.
 &lt;/p&gt;
 &lt;p&gt;
  뿅!
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Mon, 23 Mar 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/03/23/91695884/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/03/23/91695884/</guid>
        
        <category>docker</category>
        
        <category>dockerbasic</category>
        
        <category>dockerfile</category>
        
        <category>dockerimage</category>
        
        <category>container</category>
        
        <category>도커</category>
        
        <category>컨테이너</category>
        
        <category>도커파일</category>
        
        <category>도커이미지</category>
        
        <category>dockercommand</category>
        
        
      </item>
    
  </channel>
</rss>
