<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>오픈소스컨설팅 
기술 블로그
</title>
    <description>기술을 나눕니다. 함께 성장합니다.
Sharing Tech. Growing Together.
</description>
    <link>https://tech.osci.kr/</link>
    <atom:link href="https://tech.osci.kr/rss" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 28 Apr 2020 18:57:03 +0900</pubDate>
    <lastBuildDate>Tue, 28 Apr 2020 18:57:03 +0900</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>오픈소스에 기여하는 방법에 대하여 - #2 새로운 프로젝트 시작하기</title>
        <description>&lt;p&gt;
 이전 편에 이어, 새로운 오픈소스 프로젝트를 시작하는 방법에 대해서 설명하고자 합니다.
&lt;/p&gt;
&lt;p&gt;
 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://tech.osci.kr/2020/04/09/94568493/&quot; rel=&quot;nofollow&quot;&gt;
  오픈소스에 기여하는 방법에 대하여 - #1 기존 프로젝트 활용하기
 &lt;/a&gt;
 보러 가기
&lt;/p&gt;
&lt;h1 class=&quot;auto-cursor-target&quot; id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-2.기여#2-아니야!내가새로만들래!&quot;&gt;
 &lt;strong&gt;
  2. 기여 #2 - 아니야! 내가 새로 만들래!
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;p&gt;
 새로운 오픈소스 소프트웨어 프로젝트의 시작은 요구 사항을 만족하는 기존 프로젝트를 발견하지 못한 경우나 기존의 유사 프로젝트에 새로운 기능에 대한 수용 요구가 받아들여지지 않은 경우 등에 내리는 최후의 선택이라고 볼 수 있습니다. 그 밖에 자주 발생하는 새 프로젝트 시작 요인으로는 개인적 취향에 따른 것인데, 기존 프로젝트에 사용된 개발 언어가 마음에 들지 않는 경우도 많습니다.
&lt;/p&gt;
&lt;p&gt;
 실제 오픈 소스 소프트웨어들은 다양한 라이선스 정책을 가지고 있지만, 거의 대부분은 기존의 코드에서의 브랜치가 문제가 되는 경우는 많이 없습니다. 자신이 순환 구조에의 참여가 어렵다고 느끼는 경우, 프로젝트 결과물의 설계 구조에 전혀 동의 할 수 없는 경우, 마지막으로는 기존 프로젝트의 핵심 개발자, 관리자 그룹을 개인적으로 선호하지 않는 경우 등이 있을 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 일단 여러 동기에 의하여, 새로운 프로젝트가 시작되면, 상용 소프트웨어의 개발과 유사한 과정을 거치게 되는데, 이 과정은 같은 동기와 목표 의식을 가진 핵 심 개발자들로 개발팀을 구성하고, 요구 분석을 더욱 견고하게 한 뒤, 각종 위험 요인 분석, 일정 만들기 등의 절차적인 작업들로 시작됩니다.
&lt;/p&gt;
&lt;p&gt;
 그 가운데 위험 요인 분석에는, 이 새로운 프로젝트가 기존 프로젝트들 에 비하여 경쟁력을 가질 수 있는지, 개발과 추후 관리를 위한 충분한 자원자를 확보할 수 있는지, 개발에 필요한 장비가 확보 가능한지 등을 포함하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 프로젝트의 시작 단계에서부터 소스의 관리, 버그의 관리, 개발자들 간의 원활한 의사소통을 위하여 Github와 같은 오픈소스 소프트웨어 개발자 사이트를 이용할 수 있지만, 많은 초기의 프로젝트의 경우, 프로젝트의 시작 동기, 요구 사항, 설계 등이 기술된 공식적 문서의 부족이나, 다운로드가 가능한 소프트웨어 릴리즈가 없다는 이유로 개발자 지원 사이트에 등록된다 해도 커뮤니티 형성 등의 파급 효과를 기대하기는 어렵긴 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-첫번째할일.프로토타입구현&quot;&gt;
 첫번째 할 일. 프로토타입 구현
&lt;/h3&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 소프트웨어가 커뮤니티의 관심을 끌기 위한 최소한의 작업은 고품질의 프로토타입을 완성하는 일입니다. 프로토타입의 개발은 비교적 소수의 폐쇄적인 핵심 개발자 그룹을 중심으로 이루어집니다. 따라서 개발자들 사이의 의견 교환 및 의사 결정을 위한 시스템의 존재 여부는 크게 문제가 되지 않지만, 프로토타입 구현이 진행되면서, 최초의 요구 사항이 일부 수정되고 그 결과가 설계의 변경을 필요로 하는 경우도 많아, 구성원 사이의 의사소통 방법과 최소한의 문서 화는 노력이 반드시 필요합니다.
&lt;/p&gt;
&lt;p&gt;
 많은 오픈 소스 소프트웨어 프로젝트에서는 상용의 대형 소프트웨어 개발 방식에서 사용되는 소프트웨어 공학적 개발 방법론이 사용되지 않으며, 설계 방식과 참여한 개발자들의 취향에 따른 개발 방식이 사용되는게 일반적입니다. 하지만, 오픈 소스 개발의 가장 중요한 특징인 분산 개발을 효과적으로 수행하고, 소스 코드의 재사용 가능성을 높이기 위하여 모듈화, 계층화된 소프트웨어 설계를 하는 것이 중요합니다.
&lt;/p&gt;
&lt;p&gt;
 설계는 이전에 있던 유사 프로젝트의 설계를 바탕으로 이루어지기도 하며, 더 많은 경우는, 개발자들의 혁신 의지에 따라, 새로운 설계를 추구하게 됩니다. 프로토타입 구현의 완성도와 설계 특징들은, 프로젝트의 동기와 목표에 수긍하는 개발자들을 커뮤니티에 끌어들이고, 그들의 적극적인 피드백을 유도하는 중요한 원동력입니다.
&lt;/p&gt;
&lt;p&gt;
 따라서 프로토타입은 기본적인 기능 요구를 만족하며, 안정적인 동작을 해야 하며, 단순 명료한 소프트웨어 구조를 유지 하는 것이 바람직하며. 또한 기능적인 부분을 포함하여 개선할 여지도 있어야 개발자들이 많이 참여를 하게 될 것입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568500/0.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 프로토타입의 배포 이전에 반드시 거쳐야 하는 단계는 내부 시험입니다. 이 단계는 커뮤니티 참여자를 끌어 들이기 위하여, 최초로 오픈되는 소프트웨어가 그럴 듯하게 보여야할 뿐만 아니라 높은 수준의 안정성도 확보되어야 한다는 관점에서 매우 중요합니다. 대개의 프로젝트에서  별도의  QA, 테스팅 도구나 정교한 방법론은 잘 사용되지 않으며, 최근에는 가상 머신을 이용하여, 다양한 시스템 환경에서의 테스팅을 이전 보다는 더 용이하게 할 수 있다는 특징이  있습니다. 주로 모듈 단위로 설계, 구현되는 소프트웨어 구조 때문에 오픈 소스 프로젝트에서는 기존의 라이브러리들을 적극적으로 활용하게 되며, 많은 경우 각 모듈 또한 라이브러리 형식으로 개발되는 게 일반적입니다.  사실 개발되는 많은 오픈소스 소프트웨어들이 패키지 형태의 완성품보다는 라이브러리 형태의 모듈이 상당히 많습니다.
&lt;/p&gt;
&lt;p&gt;
 프로토타입 개발자들은 오픈 소스 프로젝트로서 성공적인 정착을 위해 배포 전에 호환성, 가이드, 편의성 문제의 해결에 많은 노력을 기울여야 하며,  다양한 빌드도구를 활용하여 개발자들이 손쉽게 우리가 만든 소프트웨어를 개발하고 테스팅할 수 있는 환경을 만들어주는 것이 중요합니다.
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-두번째.결과물배포&quot;&gt;
 두번째. 결과물 배포
&lt;/h3&gt;
&lt;p&gt;
 프로그램 배포는 완성된 프로토타입을 공개함으로써, 프로젝트를 오픈소스 소프트웨어 순환 구조 안에서 발전 하도록 만들기 위한 단계입니다. 프로젝트의 오픈과 소프트웨어의 배포는 BitBucket, GitHub과 같은 오픈소스 프로젝트 사이트를 이용할 수 있습니다. 하지만 GitHub만 따져도
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  &lt;strong&gt;
   &lt;span&gt;
   &lt;/span&gt;
   현재 등록된 프로젝트의 수가 이미 수십만 개를 넘었기 때문에
  &lt;/strong&gt;
 &lt;/span&gt;
 , 초기 단계의 프로젝트가 검색 단계에서 발견되어 커뮤니티의 주목을 받기는 쉽지가 않은 상황입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568500/1.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;createlink&quot; href=&quot;https://wiki.osci.kr/pages/createpage.action?spaceKey=CIS&amp;amp;title=%ED%97%88%EA%B1%B1%21+%EC%88%98%EC%8B%AD%EB%A7%8C%EA%B0%9C%21&amp;amp;linkCreation=true&amp;amp;fromPageId=91696766&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: underline;&quot;&gt;
  허걱! 1억개!
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 배포를 통해 성공적인 커뮤니티 기반 오픈 소스 프로젝트가 되기 위해서는 프로젝트 관리 구조에 대한 프로세스 등의 여러 가지 중대한 결정들이 필요합니다. 프로젝트 관리 구조는 개발자 그룹과 최종적으로 프로젝트의 방향을 결정하는 의사 결정 그룹, 그리고 의사 결정 과정을 의미하는 것입니다. 즉, 배포를 통해서 프로젝트의 소유가 초기의 핵심 개발자 그룹에서 커뮤니티로 바뀐다는 점을 바탕으로, 프로젝트에 더 많은 사람들이 참여할 수 있는 구조와 의사 결정 과정을 만드는 것인데, 이 관리 구조는 프로젝트 결과물의 성격에 따라 다르게 결정되어야 합니다. 예를 들어 운영체제의 커널 또는 그의 일부와 같이 기술적 위험이 수반되는 프로젝트의 경우에는 보수적 관점에서의 관리를 추구하여야 합니다.
&lt;/p&gt;
&lt;p&gt;
 새로운 기능의 수용, 소스 코드의 수정 등에 매우 신중한 결정을 해야 하며, 시험 및 새로운 릴리즈에 관한 중앙집중형 통제권을 유지하는 것이 바람직합니다. 반면에 GUI와 같은 사용자 편의 위주의 프로젝트는 다양한 기능적 요구를 빠르게 수용하기 위한 관리 스타일이 좋다. 초기의 프로젝트에서는 메일링 리스트, 뉴스그룹, 포럼 등을 이용 한 의견 교환과 묵시적인 합의에 의하여 프로젝트가 진행될 수 있으나, 프로젝트가 점차 명성을 얻어 커뮤니티가 커지면, 공개적이면서도 좀 더 명확한 의사 결정 구조를 요구합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 여러 관리 스타일에도 불구하고 커뮤니티를 기반으로 발전하는 오픈 소스 프로젝트에서는 개발자, 사용자들의 모든 형태의 기여(기능 추가, 버그 수정, 버그 리포팅, 새로운 기능 요구, 등)가 반드시 권장되야 하며, 개발자들의 기여 내용이 빠르게 프로젝트에 반영되어야 합니다. 배포 전에 결정해야 할 또 다른 중요한 사항은 공개될 소스의 라이선스를 결정하는 것입니다.
&lt;/p&gt;
&lt;p&gt;
 OSI(Open Source Initiative)의 오픈 소스 정의는 오픈 소스 에 대한 명확한 가이드라인으로 사용되고 있으며, 라이선스가 이 가이드라인을 만족하면, 오픈소스 소프트웨어라고 할 수 있습니다. 많은 오픈 소스 소프트웨어들이 GPL(Generic Public Licence) 또는 LGPL(Lesser GPL) 라이선스를 가지고 있지만, GPL 버전들 사이의 차이를 비롯하여, OSI에 등록된 다양한 오픈소스 라이선스들의 미묘한 차이점은 오픈소스 개발자 들이 프로젝트에의 참여 여부를 결정하는 한 요인이 되기도 합니다.
&lt;/p&gt;
&lt;p&gt;
 기타 결정 사항에는 커뮤니티 참여자들의 주 통신 방법과 소스 코드로의 접근방법 등이 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-세번째!개발자간의사소통&quot;&gt;
 세번째! 개발자간 의사소통
&lt;/h3&gt;
&lt;p&gt;
 개발자간 소통 방법에는 커뮤니티 참여자의 성격(개발자, 관리자, 사용자 등)에 따른 메일링 리스트, 포럼과 그들의 아카이브, 버그 리포트, 프로젝트 관련 문서, FAQ 등이 있습니다. 버그 리포트는 사용자와 개발자의 공식적인 통신 방법으로, 오픈 소스 소프트웨어 개발자 사이트들이 공통으로 제공하는 버그 트래킹 시스템을 이용합니다. 별도의 홈페이지를 이용하여 프로젝트를 공개한다면, Bugzilla, Trac, Redmine과 같은 버그 트래킹 시스템을 설치하여 이용할 수 있으며,
 &lt;span&gt;
 &lt;/span&gt;
 &lt;u&gt;
  &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
   &lt;strong&gt;
    아틀라시안의 JIRA를 오픈소스 개발자용 버전으로 받아 사용하는 방법도 있습니다.(아틀라시안 강추!!)
   &lt;/strong&gt;
  &lt;/span&gt;
 &lt;/u&gt;
&lt;/p&gt;
&lt;p&gt;
 버그 트래킹 시스템은 버그를 등록 하고, 누가 그것을 담당하여 수정할 지를 할당하고, 현재 처리 상태는 어떤지, 그리고 그 버그에 대한 의견 교환을 하는 등, 버그의 발생부터 해결까지의 전 과정에 대한 체계적인 관리 방법을 제공합니다. 소스 코드의 경우 안정된 배포 버전, 흔히 베타 버전라고 하는 외부용 시험 버전, 그리고 현재 개발이 진행 중인 소스 코드 스냅샷, 세 가지를 모두 공개하는 것이 보통입니다.
&lt;/p&gt;
&lt;p&gt;
 소스 코드 스냅샷 공개는 개발자들 이 소스의 버전 관리를 위하여 사용하고 있는 소스 코드 버전 관리 서버에 로그인하여 소스에 읽을 수 있도록 하는 것입니다. 소스 코드의 공개는 오픈소스 소프트웨어의 가장 큰 미덕으로 누구나 쉽게 다운로드, 리뷰, 빌드를 할 수 있도록 하고, 궁극적으로 패치를 만들어 프로젝트 관리자에게 보낼 수 있어야 합니다.
&lt;/p&gt;
&lt;p&gt;
 많은 오픈 소스 프로젝트들은 홈페이지 또는 배포된 소스에 프로젝트 컨트리뷰터(기여자)와 커미터들을 나열함으로써, 그들의 기여에 감사하고, 동시에 그 목록에 없는 개발자, 사용자들에게 동기를 부여하고 있으며 커리어 개발의 도구로도 활용되고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-네번째,커뮤니티기반개발&quot;&gt;
 네번째, 커뮤니티 기반 개발
&lt;/h3&gt;
&lt;p&gt;
 일단 프로젝트의 프로토타입, 소스가 공개되어, 점차 알려지고, 사용자,  개발자 등의 관심을 끌어, 커뮤니티가 형성되면 오픈소스 순환 구조에 의해 프로젝트는 진화하는 게 일반적입니다. 공개에 앞서 결정된 의사 결정 구조 등에 의거하여 수정 버전의 릴리즈, 기능이 대폭 강화된 버전업 등이 이루어지며, 사용 중에 발생하는 버그의 리포팅 및 수정, 기능 추가 요구 등이 커뮤니티 측에서도 이루어지며, 그 결과가 프로젝트 관리자 그룹에 의해 반영됩니다.
&lt;/p&gt;
&lt;p&gt;
 이 순환 구조가 얼마나 원활하게 운영되는지가 결국 오픈소스 소프트웨어 프로젝트의 성패를 결정하게 되며, 이 구조의 원활한 순환과 효율성은 모든 참여자 사이의 의사소통 및 의사 결정 과정 등, 배포 전에 내려진 여러 결정에 의해 좌우됩니다. 오픈소스 소프트웨어가 커뮤니티에 의해 진화한다는 일반적인 인식에도 불구하고, 그 프로젝트를 처음 시작하고, 많은 경우 결국 관리하게 되는 코어 개발자 그룹의 지속적인 관심과 개선 의지는 프로젝트 성공의 가장 중요한 요인이 됩니다.
&lt;/p&gt;
&lt;p&gt;
 많은 오픈 소스 소프트웨어 프로젝트 참여의 동기가 ‘재미’로 시작되는 경우입니다. 하지만, 오픈소스 순환 구조에 안정적으로 들어선 아주 성공적인 프로젝트들(예: 빅데이터 프로젝트, NoSQL 등)은 그 결과가 상업적인 활동에 점차 많이 적용되면서, 기술 지원과 새로운 기능 요구에 대하여 시기적절한 대응이 요구되며, 프로젝트의 핵심 개발자, 관리자 그룹에게는 더 빠른 진화를 할 수 있는 추가적인 동력이 필요하게 되고, 이 과정에서 많은 경우 기술 지원에 대한 대가로서 금전적 보상이 따르는 경우가 많아져 많은 개발자들이 이러한 오픈소스 개발에 관심을 가지게 되었습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 간략하게나마 오픈소스에 기여하는 방법에 대해 살펴보았는데 읽을만 하셨나요? 사실 바쁘게 업무 시스템관리하면서 오픈소스하기가 쉽지 않습니다. 대부분의 오픈소스 개발자들이 재미로 본인의 여가시간을 활용하여 시작한 경우가 대부분입니다. 앞으로 조금만 시간을 들여서 유튜브 동영상, 게임하시는 시간 조금 줄이고 간단한 오픈소스 활용부터 하시는 건 어떨까요?
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  이런 소프트웨어 엔지니어가 되선 안되잖아요. ^^
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568500/2.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;</description>
        <pubDate>Thu, 09 Apr 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/04/09/94568500/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/04/09/94568500/</guid>
        
        <category>오픈소스</category>
        
        <category>기여</category>
        
        <category>기여방법</category>
        
        <category>리누스</category>
        
        <category>토발즈</category>
        
        <category>리눅스</category>
        
        <category>오픈소스컨설팅</category>
        
        
      </item>
    
      <item>
        <title>오픈소스에 기여하는 방법에 대하여 - #1 기존 프로젝트 활용하기</title>
        <description>&lt;p&gt;
 &lt;span style=&quot;color: rgb(51,51,51);&quot;&gt;
  오늘은 오픈소스에 기여하는 실제적인 방법이 어떤 것이 있는지에 대해서 설명하도록 하겠습니다.
  &lt;img src=&quot;/assets/images/94568493/0.svg&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(51,51,51);&quot;&gt;
  대표적인 오픈소스인 리눅스만 하더라도 리누스 토발즈가 처음 그 코드를 공개했을 때 세계 최대 규모의 오픈소스 소프트웨어가 될 거라는 생각조차 못했을 것입니다. 여전히 토발즈는 커널의 승인 여부를 혼자 결정하고 있지만 누구나 개선될 수 있는 소스코드를 보내게 되고 그것이 도움이 된다고 판단되면  해당 소스코드의 저자(Author) 항목에 기여자(Contributor)가 되어 다음 릴리즈 되는 버전에 이름이 나오게 되었습니다. 이는 유명해지려는 사람들의 욕구(과시욕)를 충족시켜 주었을 뿐더러 개발자들에게 돈 한푼 주지 않고도 커널의 버그 수정, 드라이버 개발, 기능 추가를 할 수 있는 중요한 원동력이 되었습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(51,51,51);&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
    &lt;img src=&quot;/assets/images/94568493/1.jpeg&quot;/&gt;
   &lt;/span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;
 화끈한 창시자
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  리누스 베네딕트 토발즈(Linus Benedict Torvalds,
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 1969년
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 12월 28일
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  &lt;span&gt;
  &lt;/span&gt;
  ~ )는
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 스웨덴
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  계
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 핀란드
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  인
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 소프트웨어
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  &lt;span&gt;
  &lt;/span&gt;
  개발자이다.
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 &lt;strong&gt;
  리눅스의 아버지
 &lt;/strong&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  로 유명하며, 분산
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 버전 관리 시스템
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  인
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://namu.wiki/w/Git&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot; title=&quot;Git&quot;&gt;
  Git
 &lt;/a&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  &lt;span&gt;
  &lt;/span&gt;
  등을 만들었다. 그의 종특은 맘에 안드는 것은 뭐든지 까는 것으로, 거친 언사도 서슴지 않으며, 일반인들과도 뉴스그룹, 이메일 등지에서 욕설섞인 배틀을 자주 뜨는 현장을 목격 할 수 있
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  다. 특히 리눅스 개발 커뮤니티의 분위기를 살벌하게 만드는 일등 공신이 리누스 본인인데, 오픈소스 개발이라고 하면 누구나 편하게 자신의 코드를 커밋할 수 있을 것 같지만
  &lt;span&gt;
  &lt;/span&gt;
  현실은 시궁창으로, 리눅스에 함부로 손을 댄 사람은 리누스에게 쌍욕을 먹고 멘붕을 하게 되기 일쑤다. 소스 코드 리뷰에서 심각하게 결함이 있는 부분이나 마음에 안드는 부분을 가차없이 까내리는 모습이 거의
  &lt;span&gt;
  &lt;/span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://namu.wiki/w/%EA%B3%A0%EB%93%A0%20%EB%9E%A8%EC%A7%80&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot; title=&quot;고든 램지&quot;&gt;
   고든 램지
  &lt;/a&gt;
  급.
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 기여의 1단계로 보자면 우선 내가 사용하고 있는 오픈소스에 대한 관심과 그것이 가진 기능을 활용해 보는 것이 첫번째일 것입니다. 어떤 업무시스템 또는 소프트웨어를 개발하고자 하는 경우 개발하고자 하는 기능에 대한 충분한 분석을 한 뒤, 이미 존재하는 오픈 소스 소프트웨어 프로젝트들이면 내가 원하는 요구 사항을 만족하는 것이 있는지 확인하는 작업부터가 시작일 것입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-1.기여#1-있는거참여할래!&quot;&gt;
 &lt;strong&gt;
  1.  기여 #1 - 있는거 참여할래!
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-가.오픈소스프로젝트검색&quot;&gt;
 가. 오픈소스 프로젝트 검색
&lt;/h3&gt;
&lt;p&gt;
 현재 오픈소스 프로젝트는 셀 수 없을 정도로 많으며, 해당 프로젝트가 관리되고 있는 저장소도 각각 다릅니다. 이렇게 많은 프로젝트들 중 특정 프로젝트를 찾기 위해 다음과 같은 방법을 사용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h4 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(1)구글링&quot;&gt;
 (1) 구글링
&lt;/h4&gt;
&lt;p&gt;
 잘 알려진 유명한 오픈소스 프로젝트들은 타이틀만으로도 구글링을 통해 충분히 검색할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/2.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-1 구글링을 이용한 프로젝트 검색]
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h4 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(2)오픈소스저장소내검색&quot;&gt;
 (2) 오픈소스 저장소 내 검색
&lt;/h4&gt;
&lt;p&gt;
 GitHub, SourceForge, Bitbucket, Google Code 등 오픈소스 저장소에 접속하여 직접 검색합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/3.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-2 오픈소스 저장소 내 프로젝트 검색] - 아이고 많기도 하여라!
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h4 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(3)오픈소스재단내검색&quot;&gt;
 (3) 오픈소스 재단 내 검색
&lt;/h4&gt;
&lt;p&gt;
 아파치 재단, 리눅스 재단, 모질라 재단 등 오픈소스 재단에 접속하여 직접 검색할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/4.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-3 오픈소스 재단 내 프로젝트 검색]
&lt;/p&gt;
&lt;p&gt;
 그 밖에
 &lt;span&gt;
 &lt;/span&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;http://www.findbestopensource.com/&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot;&gt;
  &lt;u&gt;
   http://www.findbestopensource.com
  &lt;/u&gt;
 &lt;/a&gt;
 ,
 &lt;span&gt;
 &lt;/span&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.openhub.net/&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot;&gt;
  &lt;u&gt;
   https://www.openhub.net/
  &lt;/u&gt;
 &lt;/a&gt;
 &lt;span&gt;
 &lt;/span&gt;
 등의 사이트에서도 검색할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-나.오픈소스프로젝트참여&quot;&gt;
 나. 오픈소스 프로젝트 참여
&lt;/h3&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 오픈소스 프로젝트에 참여하는 방법은 다음과 같이 아주 다양합니다.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  버그 리포트
 &lt;/li&gt;
 &lt;li&gt;
  커뮤니티 활동을 통한 의견 교류
 &lt;/li&gt;
 &lt;li&gt;
  프로젝트 문서 수정 또는 번역
 &lt;/li&gt;
 &lt;li&gt;
  기능 등록 및 수정 요청
 &lt;/li&gt;
 &lt;li&gt;
  패치 요청
 &lt;/li&gt;
 &lt;li&gt;
  커미터 또는 컨트리뷰터 활동
 &lt;/li&gt;
 &lt;li&gt;
  한글 번역
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 * 커미터(Committer) : 프로젝트내에서 직접 코드를 push할 수 있는 권한을 가진 사람
&lt;/p&gt;
&lt;p&gt;
 * 컨트리뷰터(Contributter) : 패치 등의 소스 코드를 제공하는 사람
&lt;/p&gt;
&lt;p&gt;
 즉, 반드시 코드를 수정, 작성해야만 프로젝트에 참여하는 것이 아니고 자신이 할 수 있는 부분에서 꾸준한 관심과 희생정신을 가지고 활동하는 것이 바람직합니다.
&lt;/p&gt;
&lt;p&gt;
 개발자에게 있어 커미터 또는 컨트리뷰터가 되는 것이 가장 이상적인 참여 방법이 될 수 있으며, 일반적인 과정은 다음과 같습니다.
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(1)기술및사용법습득과개발환경구축&quot;&gt;
 (1) 기술 및 사용법 습득과 개발환경 구축
&lt;/h3&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 오픈소스 프로젝트에서 사용하는 언어 및 프레임워크 등의 기술을 습득하고 해당 오픈소스 프로젝트를 활용할 수 있어야 하며 개발가이드를 통한 자신만의 개발 환경을 구축합니다.
&lt;/p&gt;
&lt;p&gt;
 GitHub의 경우 개발환경 구축 시 프로젝트를 개인 저장소로 복제하기 위해 Fork를 수행합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/5.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-4 GitHub 소셜 메뉴]
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Watch, Star, Fork는 GitHub의 소셜 기능으로써 Watch는 해당 프로젝트를 지속적으로 관찰하겠다는 의미로 이 기능을 활성화 시키면 해당 프로젝트가 처리하고 있는 이슈들에 대해서 알림이 오게 됩니다. Star는 해당 프로젝트에 관심을 나타내는 것으로 별점과 비슷하며, Star가 많은 프로젝트들은 월간, 주간, 일간으로 분류하여 인기 프로젝트로 선정되며 Explore 메뉴에서 보여집니다. 마지막으로 Fork는 해당 프로젝트를 내 계정에 그대로 복사하는 기능으로 해당 프로젝트에 Push 권한이 없다면 복제된 프로젝트에 기능을 추가, 수정하고 Pull Request로 변경사항을 적용 요청할 수 있습니다.
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(2)메일링리스트구독및커뮤니티활동&quot;&gt;
 (2) 메일링 리스트 구독 및 커뮤니티 활동
&lt;/h3&gt;
&lt;p&gt;
 메일링 리스트를 구독함으로써 프로젝트 관련 정보를 받아볼 수 있으며, 커뮤니티 활동으로 구성원들과의 의견 교류를 활발히 합니다. 본인이 해당 컴포넌트에 대한 장단점을 파악하고 이에 대한 설명이 가능한 상태에서
 &lt;span&gt;
 &lt;/span&gt;
 &lt;u&gt;
  &lt;strong&gt;
   영어 작문이 능통하다면 StackOverflow를 활용
  &lt;/strong&gt;
 &lt;/u&gt;
 하여 꾸준히 활동하는 방법도 정말 좋습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/6.jpeg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 (아 영어!) - 영어의 중요성!!
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(3)버그리포트&amp;amp;기능제안&quot;&gt;
 (3) 버그 리포트 &amp;amp; 기능 제안
&lt;/h3&gt;
&lt;p&gt;
 재현할 수 있는 버그에 대해 상황과 상태를 자세히 기술하며, JIRA나 GitHub 이슈 등의 공식 이슈 트래커를 사용하여 리포트합니다. 단, 버그 리포트를 등록하기 전 유사한 버그가 있는지 확인하고 이미 존재한다면 기존 내용에 코멘트 등으로 부가 설명 후 vote나 watch 등으로 관심을 표현하는 것이 좋겠죠! 기능 제안도 버그 리포팅과 마찬가지고 이슈 트래커를 사용하며, 유사한 이슈가 있는지 확인 후 등록하면 더욱 좋습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(4)패치등록/PullRequest&quot;&gt;
 (4) 패치 등록 / Pull Request
&lt;/h3&gt;
&lt;p&gt;
 버그, 기능 개선, 신규 기능 등을 위해 등록된 이슈에 패치를 첨부하면 커미터들이 패치를 검토한 후 적용하게 됩니다. GitHub가 사실상 오픈소스 코드 저장소의 표준이 되었기 때문에 요즘은 패치를 보내는 일은 많지 않고 대부분 GitHub의 Pull Request를 이용하면 됩니다. 자세한 설명은 인터넷에 무지하게 널렸으니 참고하여 주셔도 됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/7.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-5 GitHub Pull Request]
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 class=&quot;auto-cursor-target&quot; id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(5)이도저도안되겠다?!&quot;&gt;
 (5) 이도 저도 안되겠다?!
&lt;/h3&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 그러면 우선 번역하는데 참여하겠다로 시작하는 방법도 최고의 시작점이 아닐까 합니다.
&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;
 국내 오픈소스 커미터 현황
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
 &lt;/strong&gt;
 2019년 2월 기준* 총
 &lt;span&gt;
 &lt;/span&gt;
 &lt;strong&gt;
  500여
 &lt;/strong&gt;
 &lt;strong&gt;
  명
 &lt;/strong&gt;
 의 국내 커미터가 OS, Cloud, Mobile, BigData, IoT, AI, Network, Web, Embedded, Development Environment 등의 10개의 분야의 총 1,398 글로벌 오픈소스 프로젝트*에 참여하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 * 글로벌 커미터 현황은 프로젝트의 기여도와 코드의 정성적 평가 등을 거쳐
 &lt;span&gt;
 &lt;/span&gt;
 &lt;u&gt;
  &lt;strong&gt;
   30
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   일
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   ~90
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   일 간격으로 신규 커미터를 추가하며
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   ,
   &lt;span&gt;
   &lt;/span&gt;
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   기존 커미터도 지속적인 소스코드 개발과 기여가 없으면 커미터 자격이 유지되지 않음
  &lt;/strong&gt;
 &lt;/u&gt;
&lt;/p&gt;
&lt;p&gt;
 ㅇ 국내 커미터들이 가장 많이 개발에 참여하고 있는 글로벌 오픈소스 프로젝트는 구글 안드로이드(Google Android)이며, 총 86명의 국내 커미터가 분포되어 있음
&lt;/p&gt;
&lt;p&gt;
 - 구글 안드로이드 다음으로는 Google Chromium 프로젝트에 46명, WebKit 프로젝트와 Rust 프로그래밍 언어에 각각 18명의 국내 커미터가 개발하고 있음
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
 &lt;/strong&gt;
 국내 커미터가 참여하는 글로벌 프로젝트 분야 Top 3는 ① Development Environment* 분야 119명 ② Mobile 분야 105명 ③ Web분야에 80명이 참여하여 Top 3를 형성하고 있음
&lt;/p&gt;
&lt;p&gt;
 * 개발환경 분야는 Programming Language, Testing Tool, Simulator, Compiler, Build system, Library, Framework 등을 포함하고 있음
&lt;/p&gt;</description>
        <pubDate>Thu, 09 Apr 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/04/09/94568493/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/04/09/94568493/</guid>
        
        <category>오픈소스</category>
        
        <category>리누즈</category>
        
        <category>토발즈</category>
        
        <category>리눅스</category>
        
        <category>오픈소스컨설팅</category>
        
        <category>커뮤니티</category>
        
        <category>기여방법</category>
        
        
      </item>
    
      <item>
        <title>Kubernetes상에서 Keycloak과 Jenkins 그리고 Spinnaker 연동하기</title>
        <description>&lt;p&gt;
 keycloak이라는 SSO solution을 이용하여 Jenkins 그리고 Spinnaker를 SAML과 OIDC 방식으로 연동하고
&lt;/p&gt;
&lt;p&gt;
 한번의 로그인으로 각 솔루션을 접근할수 있는 방법에 대하여 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Keycloak이란?&quot;&gt;
 Keycloak이란?
&lt;/h1&gt;
&lt;p&gt;
 우선 Keycloak에 대하여 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현대의 Application과 Service들에 대한 오픈소스 계정 및 접근 관리 솔루션으로 기존에 서비스 되고 있었거나
&lt;/p&gt;
&lt;p&gt;
 새로운 Application을 구현하고자할때 해당 코드의 변경없이(혹은 약간의 수정만으로) 인증과 자원보호의 기능을 제공하는 솔루션입니다.
&lt;/p&gt;
&lt;p&gt;
 해당 솔루션은 오픈소스로 제공되며 Community 버전의 경우 별도의 비용없이 사용이 가능하며 Red Hat Single Sign-On이라는 솔루션으로
&lt;/p&gt;
&lt;p&gt;
 벤더의 지원을 구매하여 사용하실수도 있습니다.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.keycloak.org/about.html&quot; rel=&quot;nofollow&quot;&gt;
   https://www.keycloak.org/about.html
  &lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-기본적으로제공하는기능은다음과같습니다.&quot;&gt;
 기본적으로 제공하는 기능은 다음과 같습니다.
&lt;/h3&gt;
&lt;ul&gt;
 &lt;li&gt;
  SSO (Single Sign On)
 &lt;/li&gt;
 &lt;li&gt;
  ID 중개와 소셜 로그인 (OpenID, SAML, GitHub, facebook, google, twitter 등)
 &lt;/li&gt;
 &lt;li&gt;
  사용자 연합 (LDAP, AD, RDMS와의 연동을 통해 중앙화된 계정통합을 제공)
 &lt;/li&gt;
 &lt;li&gt;
  관리자 / 계정관리 콘솔
 &lt;/li&gt;
 &lt;li&gt;
  표준 프로토콜 지원 (OpenID, SAML, OAuth 2.0)
 &lt;/li&gt;
 &lt;li&gt;
  Client Adapters (다수의 platform과 프로그래밍 언어가 사용가능한 adapter를 가지고 있다.)
 &lt;/li&gt;
 &lt;li&gt;
  권한부여 서비스
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 여기까지는 간단하게 Keycloak이라는 SSO에 대하여 알아보았고 이제부터 Keycloak을 Kubernetes 환경에 배포하고
&lt;/p&gt;
&lt;p&gt;
 배포된 Keycloak을 이용하여 Jenkins, Spinnaker에 SSO 환경을 구성하는 방법에 대하여 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Keycloak배포및구성&quot;&gt;
 Keycloak 배포 및 구성
&lt;/h1&gt;
&lt;p&gt;
 우선 간단하게 helm을 이용하여 Kubernetes환경에서 keycloak을 구성하는 방법에 대하여 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 설치시 helm을 이용할 예정이기에 values.yaml내에 아래와 같은 몇가지 설정을 변경합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@labs-kube-infra001 keycloak]# kubectl create ns keycloak
[root@labs-kube-infra001 keycloak]# helm repo add codecentric https://codecentric.github.io/helm-charts
&quot;codecentric&quot; has been added to your repositories
[root@labs-kube-infra001 keycloak]# mkdir keycloak &amp;amp;&amp;amp; cd keycloak
[root@labs-kube-infra001 keycloak]# helm show values codecentric/keycloak &amp;gt; values.yaml
[root@labs-kube-infra001 keycloak]# cat values.yaml
...
  ## Username for the initial Keycloak admin user
  username: keycloak

  ## Password for the initial Keycloak admin user. Applicable only if existingSecret is not set.
  ## If not set, a random 10 characters password will be used
  password: &quot;Pa55w0rd$#&quot;
...
  service:
    annotations: {}
    # service.beta.kubernetes.io/aws-load-balancer-internal: &quot;0.0.0.0/0&quot;

    labels: {}
    # key: value

    ## ServiceType
    ## ref: https://kubernetes.io/docs/user-guide/services/#publishing-services---service-types
    type: LoadBalancer
...
  persistence:
    # If true, the Postgres chart is deployed
    deployPostgres: true

    # The database vendor. Can be either &quot;postgres&quot;, &quot;mysql&quot;, &quot;mariadb&quot;, or &quot;h2&quot;
    dbVendor: &quot;postgres&quot;
...
postgresql:
...
  persistence:
    ## Enable PostgreSQL persistence using Persistent Volume Claims.
    ##
    enabled: true
...
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 자 이제 설치를 진행해보도록 하겠습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@labs-kube-infra001 keycloak]# helm install --name keycloak -f values.yaml codecentric/keycloak --namespace keycloak
NAME:   keycloak
LAST DEPLOYED: Thu Mar 19 15:33:50 2020
NAMESPACE: keycloak
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/ConfigMap
NAME              DATA  AGE
keycloak-sh       1     2s
keycloak-startup  1     2s
keycloak-test     1     2s

==&amp;gt; v1/Pod(related)
NAME                   READY  STATUS    RESTARTS  AGE
keycloak-0             0/1    Init:0/1  0         1s
keycloak-postgresql-0  0/1    Pending   0         1s

==&amp;gt; v1/Secret
NAME                 TYPE    DATA  AGE
keycloak-http        Opaque  1     3s
keycloak-postgresql  Opaque  1     3s

==&amp;gt; v1/Service
NAME                          TYPE          CLUSTER-IP    EXTERNAL-IP      PORT(S)                      AGE
keycloak-headless             ClusterIP     None          &amp;lt;none&amp;gt;           80/TCP,8443/TCP              2s
keycloak-http                 LoadBalancer  10.233.3.82   192.168.197.141  80:32242/TCP,8443:31190/TCP  2s
keycloak-postgresql           ClusterIP     10.233.7.200  &amp;lt;none&amp;gt;           5432/TCP                     2s
keycloak-postgresql-headless  ClusterIP     None          &amp;lt;none&amp;gt;           5432/TCP                     2s

==&amp;gt; v1/StatefulSet
NAME                 READY  AGE
keycloak             0/1    2s
keycloak-postgresql  0/1    2s


NOTES:

Keycloak can be accessed:

* Within your cluster, at the following DNS name at port 80:

  keycloak-http.keycloak.svc.cluster.local

* From outside the cluster, run these commands in the same shell:

  NOTE:
  It may take a few minutes for the LoadBalancer IP to be available.
  You can watch the status of by running 'kubectl get svc -w keycloak'

  export SERVICE_IP=$(kubectl get svc --namespace keycloak keycloak -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
  echo http://$SERVICE_IP:80

Login with the following credentials:
Username: keycloak

To retrieve the initial user password run:
kubectl get secret --namespace keycloak keycloak-http -o jsonpath=&quot;{.data.password}&quot; | base64 --decode; echo

[root@labs-kube-infra001 keycloak]# k get po -n keycloak
NAME                    READY   STATUS    RESTARTS   AGE
keycloak-0              1/1     Running   0          6m42s
keycloak-postgresql-0   1/1     Running   0          6m42s
[root@labs-kube-infra001 keycloak]# k get svc -n keycloak
NAME                           TYPE           CLUSTER-IP     EXTERNAL-IP       PORT(S)                       AGE
keycloak-headless              ClusterIP      None           &amp;lt;none&amp;gt;            80/TCP,8443/TCP               6m49s
keycloak-http                  LoadBalancer   10.233.3.82    192.168.197.141   80:32242/TCP,8443:31190/TCP   6m49s
keycloak-postgresql            ClusterIP      10.233.7.200   &amp;lt;none&amp;gt;            5432/TCP                      6m49s
keycloak-postgresql-headless   ClusterIP      None           &amp;lt;none&amp;gt;            5432/TCP                      6m49s
[root@labs-kube-infra001 keycloak]# k get statefulset -n keycloak
NAME                  READY   AGE
keycloak              1/1     7m6s
keycloak-postgresql   1/1     7m6s&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 설치가 완료되고 keycloak 서비스에 접근하게 되면 아래와 같은 관리자 화면이 출력됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 로그인 계정은 앞서 helm values.yaml 파일에 설정했던 value를 사용하여 로그인을 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-note conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;note&quot;&gt;
 &lt;p class=&quot;title&quot;&gt;
  참고사항
 &lt;/p&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   docker-compose를 사용할수 있는 예제도 존재하니 테스트를 해보고자 하는 경우 간단히 docker-compose 예제를 다운로드 받아
  &lt;/p&gt;
  &lt;p&gt;
   설치 및 테스트를 수행해보기를 추천드립니다.
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/keycloak/keycloak-containers/tree/master/docker-compose-examples&quot; rel=&quot;nofollow&quot;&gt;
     https://github.com/keycloak/keycloak-containers/tree/master/docker-compose-examples
    &lt;/a&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Keycloak연동하기전에기본적인용어들&quot;&gt;
 Keycloak 연동하기 전에 기본적인 용어들
&lt;/h1&gt;
&lt;p&gt;
 SSO 혹은 Keycloak이 처음이라면 아래의 용어에 우선 친숙해질 필요가 있습니다.
&lt;/p&gt;
&lt;p&gt;
 간단하게 설명된 용어들을 읽어보고 연동을 진행해보기를 추천드립니다.
&lt;/p&gt;
&lt;h5 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Realm&quot;&gt;
 Realm
&lt;/h5&gt;
&lt;ul&gt;
 &lt;li&gt;
  SSO로서 인증 대상의 범위를 지정한다라고 생각하면 됩니다.
 &lt;/li&gt;
 &lt;li&gt;
  Realm을 통해 Namespace 형태로 관리할수 있으며 Metadata와 관련 설정에 대한 모든것을 관리하도록 도와줍니다.
 &lt;/li&gt;
 &lt;li&gt;
  참고로 다수의 realm을 가질수 있고 일반적으로 master(default로 생성된 realm)는 관리자의 목적으로만 사용하고
  &lt;br/&gt;
  다른 realm을 생성하여 사용하기를 권장합니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Client&quot;&gt;
 Client
&lt;/h5&gt;
&lt;ul&gt;
 &lt;li&gt;
  SSO를 사용할 각 Application입니다.
  &lt;br/&gt;
  (즉, 여기서는 Jenkins, Spinnaker가 Client라고 보시면 됩니다.)
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-User&quot;&gt;
 User
&lt;/h5&gt;
&lt;ul&gt;
 &lt;li&gt;
  앞서 설명드린 Client에 실제 로그인할 사용자계정이라 보면됩니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-참고&quot;&gt;
 참고
&lt;/h5&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://jsonobject.tistory.com/445&quot; rel=&quot;nofollow&quot;&gt;
   https://jsonobject.tistory.com/445
  &lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Keycloak과Jenkins연동하기&quot;&gt;
 Keycloak과 Jenkins 연동하기
&lt;/h1&gt;
&lt;p&gt;
 Keycloak과 Jenkins를 연결하여 인증을 Keycloak을 통해서 받을 수 있도록 해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 Keycloak 연동에는 다양한 방식이 있고 역할기반의 제어도 가능하나 여기서는 Jenkins의 경우
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  SAML을 이용한 방식의 로그인만을 연동
 &lt;/strong&gt;
 하는 방법에 대하여 알아볼 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 참고로
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  Jenkins는 jenkins.openlabs:8080 으로 접속되는 환경으로 구성이 이미 완료된 상태입니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-KeycloakSide&quot;&gt;
 Keycloak Side
&lt;/h3&gt;
&lt;p&gt;
 앞서 설명하였던대로 Master가 기본으로 설정되어 있지만 이를 사용하지 않고 새로운 Realm을 생성합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/2.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 생성된 Realm의 Realm Settings로 이동하여 Endpoint를 확인합니다.
&lt;/p&gt;
&lt;p&gt;
 (해당 Endpoint 정보는 Jenkins 의 Keycloak 관련 SAML 설정상에서 사용될 예정입니다.)
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/3.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 클릭해보면 다음과 같은 XML 형태의 문서가 출력되게 됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/4.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 해당 정보를 사전에 복사해둡니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 keycloak를 사용한 인증을 위한 Jenkins Client를 생성합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/5.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 설정은 아래 그림에 체크되어 있는 설정을 추가하여 설정을 마무리 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/6.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 위에 체크된 항목에 대해 추가를 진행한다.
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-note conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;note&quot;&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   만약 설정시 아래와 같은 이슈가 있다면 참고하시기 바랍니다.
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    invalid_redirect_url 에러 관련
    &lt;ul&gt;
     &lt;li&gt;
      Valid Redirect URIs 에 IP 및 domain 정보가 추가되어 있지 않아서 발생된 이슈로 추가시 이슈해결됨.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
   &lt;li&gt;
    로그인후에 자동 로그아웃되는 현상
    &lt;ul&gt;
     &lt;li&gt;
      document signing enable 후에 자동로그아웃되는 현상 사라짐.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-JenkinsSide&quot;&gt;
 Jenkins Side
&lt;/h3&gt;
&lt;p&gt;
 이제 Keycloak SSO를 사용하기 위한 Jenkins의 설정을 추가해 보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 Jenkins의 경우 앞서 Keycloak에서 설정했듯이 SAML을 이용할 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 하여 SAML plugin을 먼저 설치합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/7.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 SAML plugin 설치후 global security 설정에서 아래와 같은 설정을 진행합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/8.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 위에 체크된 항목을 변경하여 설정을 완료합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이제 설정은 완료되었습니다. 아래와 같이 직접 Jenkins UI로 접근을 시도해봅니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/9.gif&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 이제 SSO 연동을 위한 Jenkins 로그인 과정을 완료하였습니다.
&lt;/p&gt;
&lt;p&gt;
 SSO의 경우 한번의 로그인을 통해 다수의 서비스를 사용할수 있는 것이기에 다음 Spinnaker를 SSO와 연동하여 두개의 서비스가
&lt;/p&gt;
&lt;p&gt;
 한번의 로그인으로 이루어질수 있는지 추가로 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-note conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;note&quot;&gt;
 &lt;p class=&quot;title&quot;&gt;
  참고
 &lt;/p&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   Keycloak은 Login Page에 대한 customization을 제공하기 때문에 아래 링크를 활용하여 custom theme를 작성하고
  &lt;/p&gt;
  &lt;p&gt;
   적용하여 자신만의 login page를 구성할수 있습니다.
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://medium.com/@auscunningham/create-a-custom-theme-for-keycloak-8781207be604&quot; rel=&quot;nofollow&quot;&gt;
     https://medium.com/@auscunningham/create-a-custom-theme-for-keycloak-8781207be604
    &lt;/a&gt;
   &lt;/li&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/Alfresco/alfresco-keycloak-theme&quot; rel=&quot;nofollow&quot; style=&quot;letter-spacing: 0.0px;&quot;&gt;
     https://github.com/Alfresco/alfresco-keycloak-theme
    &lt;/a&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Spinnaker와Keycloak&quot;&gt;
 Spinnaker와 Keycloak
&lt;/h1&gt;
&lt;p&gt;
 이번에는 Spinnaker 연동을 해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 앞서 이야기 드렸듯이 Keycloak 연동에는 다양한 방식이 있고 역할기반의 제어도 가능하나 여기서는 spinnaker의 경우
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  OIDC를 이용한 방식의 로그인만을 연동
 &lt;/strong&gt;
 하는 방법에 대하여 알아볼 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 참고로
 &lt;span&gt;
  spinnaker는 spinnaker.openlabs 으로 접속되는 환경으로 구성이 이미 완료된 상태입니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 또한 spinnaker-gate.openlabs:8084로 gate가 접속 가능한 환경입니다.
&lt;/p&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-KeycloakSide.1&quot;&gt;
 Keycloak Side
&lt;/h3&gt;
&lt;p&gt;
 이제 Keycloak에서 spinnaker를 위한 Client를 생성합니다.
&lt;/p&gt;
&lt;p&gt;
 이번에는 keycloak에서 권장하는 OIDC(OpenID Connect)로 설정하여 Client를 생성해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/10.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Jenkins 연동시와 동일하게 Client을 생성합니다.
&lt;/p&gt;
&lt;p&gt;
 (Jenkins 에서 생성했던 Realm을 동일하게 사용하는 것을 가정하였습니다.)
&lt;/p&gt;
&lt;p&gt;
 이후 아래와 같은 설정에 매칭되는 OIDC json 파일의 내용을 확인합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/11.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 실제 Json 내용은 다음과 같습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;{
  &quot;realm&quot;: &quot;Openlabs&quot;,
  &quot;auth-server-url&quot;: &quot;http://keycloak.openlabs/auth/&quot;,
  &quot;ssl-required&quot;: &quot;external&quot;,
  &quot;resource&quot;: &quot;spinnaker&quot;,
  &quot;credentials&quot;: {
    &quot;secret&quot;: &quot;d123150f-2879-4a99-9e22-e40fcaf02bdb&quot;
  },
  &quot;confidential-port&quot;: 0
}&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 여기서 우리는 credentials 정보와 auth-server-url, realm 등을 사용할 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 또한 realm 의 endpoint 정보도 확인해놓습니다.
&lt;/p&gt;
&lt;p&gt;
 아래와 같이 앞서 생성했던 Realm 의 Settings에서 Endpoints 내에 OpenID Endpoint Configuration을 클릭하여 확인이 가능합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/12.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 클릭시 아래와 같은 Json 결과가 출력될 것이고 아래 정보는 spinnaker 설정에서 사용될 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/13.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 실제 사용될 url 정보는 다음과 같습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;authorization_endpoint: &quot;http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/auth&quot;,
token_endpoint: &quot;http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/token&quot;,
userinfo_endpoint: &quot;http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/userinfo&quot;&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-SpinnakerSide&quot;&gt;
 Spinnaker Side
&lt;/h3&gt;
&lt;p&gt;
 이제 spinnaker에서 설정을 진행해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 아시다시피 spinnaker의 경우 halyard pod에 접속하여 (혹은 hal command가 가능한 서버에 접속하여) 설정 변경을 수행해야 합니다.
&lt;/p&gt;
&lt;p&gt;
 하여 halyard pod에 접속하여 hal command를 수행해봅니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;jacob@jacob-laptop:~/workspace$ k get po
NAME                                READY   STATUS      RESTARTS   AGE
spin-clouddriver-5d569c94b8-ffmfs   1/1     Running     0          69d
spin-deck-7754884b55-fq7r4          1/1     Running     0          69d
spin-echo-c57577776-vz8zg           1/1     Running     0          69d
spin-front50-79d4d69b45-klchv       1/1     Running     0          69d
spin-gate-75c76579c4-dxnjp          1/1     Running     0          69d
spin-igor-74d8c59858-zj4bt          1/1     Running     0          69d
spin-orca-f7b8c4676-kfbwp           1/1     Running     0          69d
spin-rosco-7d58898bd6-8h2g5         1/1     Running     0          69d
spinnaker-install-using-hal-x9vds   0/1     Completed   0          70d
spinnaker-minio-5dc587c6f-k9hsx     1/1     Running     0          70d
spinnaker-redis-master-0            1/1     Running     0          70d
spinnaker-redis-slave-0             1/1     Running     0          70d
spinnaker-redis-slave-1             1/1     Running     0          70d
spinnaker-spinnaker-halyard-0       1/1     Running     0          70d
jacob@jacob-laptop:~/workspace$ k exec -it spinnaker-spinnaker-halyard-0 /bin/bash
spinnaker@spinnaker-spinnaker-halyard-0:/workdir$ &lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 실제 halyard pod에서 수행될 명령어들은 다음과 같습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;echo &quot;server:
  tomcat:
    protocolHeader: X-Forwarded-Proto
    remoteIpHeader: X-Forwarded-For
    internalProxies: .*
    httpsServerPort: X-Forwarded-Port
security:
  oauth2:
    enabled: true
    client: 
      clientId: spinnaker
      clientSecret: d123150f-2879-4a99-9e22-e40fcaf02bdb
      userAuthorizationUri: http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/auth
      accessTokenUri: http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/token
      scope: roles,email,profile
    resource:
      userInfoUri: http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/userinfo
    userInfoMapping:
      email: email
      firstName: given_name
      lastName: family_name
      username: preferred_username&quot; &amp;gt; .hal/default/profiles/gate-local.yml
hal config security authn oauth2 edit \
--client-id spinnaker \
--client-secret d123150f-2879-4a99-9e22-e40fcaf02bdb \
--pre-established-redirect-uri http://spinnaker-api.openlabs:8084/login
hal config security authn oauth2 enable
hal config security ui edit --override-base-url http://spinnaker.openlabs:9000
hal config security api edit --override-base-url http://spinnaker-api.openlabs:8084 
hal deploy apply

## 혹은 다음 명령 set 수행
hal config security authn oauth2 edit \
--client-id spinnaker \
--client-secret d123150f-2879-4a99-9e22-e40fcaf02bdb \
--pre-established-redirect-uri http://spinnaker-api.openlabs:8084/login \
--access-token-uri http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/token \
--scope read:roles,email,profile \
--user-authorization-uri http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/auth \
--user-info-mapping-email email \
--user-info-mapping-first-name given_name \
--user-info-mapping-last-name family_name \
--user-info-mapping-username preferred_username \
--user-info-uri http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/userinfo
hal config security authn oauth2 enable
hal config security ui edit --override-base-url http://spinnaker.openlabs:9000
hal config security api edit --override-base-url http://spinnaker-api.openlabs:8084 
hal deploy apply&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 물론 helm chart를 이용한 업그레이드 방법도 가능합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;   additionalProfileConfigMaps:
     create: true
     data:
       gate-local.yml: |-
         server:
           tomcat:
             protocolHeader: X-Forwarded-Proto
             remoteIpHeader: X-Forwarded-For
             internalProxies: .*
             httpsServerPort: X-Forwarded-Port
         security:
           oauth2:
             enabled: true
             client:
               clientId: spinnaker
               clientSecret: xxxx00cc-xxxx-xxxx-xxxx-xxxx2515xxxx
               userAuthorizationUri: http://keycloak.openlabs/auth/realms/openlabs/protocol/openid-connect/auth
               accessTokenUri: http://keycloak.openlabs/auth/realms/openlabs/protocol/openid-connect/token
               scope: roles,email,profile
             resource:
               userInfoUri: http://keycloak.openlabs/auth/realms/openlabs/protocol/openid-connect/userinfo
             userInfoMapping:
               email: email
               firstName: given_name
               lastName: family_name
               username: preferred_username
   additionalScripts:
     create: true
     data: 
       override_baseurls.sh: |-
           $HAL_COMMAND config security api edit --override-base-url http://spinnaker-gate.openlabs:8084/
           $HAL_COMMAND config security ui edit --override-base-url http://spinnaker.openlabs/
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 위 명령 혹은 helm upgrade를 통한 설정 변경을 수행한 후 실제 로그인을 수행해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/14.gif&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 로그인 완료후 아래와 같이 로그인 계정이 확인됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/15.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-확인&quot;&gt;
 확인
&lt;/h1&gt;
&lt;p&gt;
 자 이제 SSO 기능 검증을 위해 두개의 Application을 로그인시도해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/16.gif&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 두개의 Application을 한번의 로그인으로 사용할수 있도록 하는것을 확인할수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-warning conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;warning&quot;&gt;
 &lt;p class=&quot;title&quot;&gt;
  참고사항
 &lt;/p&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-error confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   &lt;strong&gt;
    keycloak에서 권장하는 사항들
   &lt;/strong&gt;
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    SAML을 사용하는 경우
    &lt;ul&gt;
     &lt;li&gt;
      XML 교환방식을 Post Binding 으로 사용하는것을 권장 (보안과 크기제한에 대한 이슈로 인하여)
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
   &lt;li&gt;
    SAML 보다는 OIDC를 권장
    &lt;ul&gt;
     &lt;li&gt;
      &lt;a class=&quot;external-link&quot; href=&quot;https://www.keycloak.org/docs/latest/server_admin/#openid-connect-vs-saml&quot; rel=&quot;nofollow&quot;&gt;
       https://www.keycloak.org/docs/latest/server_admin/#openid-connect-vs-saml
      &lt;/a&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-참고사이트&quot;&gt;
 참고사이트
&lt;/h1&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.keycloak.org/docs/latest/getting_started/index.html&quot; rel=&quot;nofollow&quot;&gt;
   https://www.keycloak.org/docs/latest/getting_started/index.html
  &lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;</description>
        <pubDate>Sat, 04 Apr 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/04/04/91699412/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/04/04/91699412/</guid>
        
        <category>spinnaker</category>
        
        <category>jenkins</category>
        
        <category>keycloak</category>
        
        <category>sso</category>
        
        <category>saml</category>
        
        <category>oidc</category>
        
        
      </item>
    
      <item>
        <title>데이터센터의 클라우드 전환</title>
        <description>&lt;h1 id=&quot;id-데이터센터의클라우드전환-1.클라우드전환개요&quot;&gt;
 &lt;strong&gt;
  1.클라우드 전환 개요
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;p&gt;
 엔터프라이즈 기업의 데이터센터가 변화하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 유닉스 기반의 경직된 시스템 환경에서 스케일 아웃을 통한 확장성 있는 인프라로의 변화를 위하여 많은 기업들이 소프트웨어 정의 데이터센터
 &lt;span&gt;
  (SDDC:Software Defined Data Center)
 &lt;/span&gt;
 를 외치고 있는 실정입니다.
&lt;/p&gt;
&lt;p&gt;
 현재 데이터센터를 자체적으로 보유한 기업들 조차도 신규 서비스 기획 시 사업에 대한 불명확성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 시장 반응들을 살펴볼 수 있는 시스템을 만들기 위하여 하드웨어 박스를 구매하고
 &lt;span&gt;
  ,
 &lt;/span&gt;
 상용 소프트웨어로 도배된 데이터센터 기반 시스템의 사용에 대해 의문을 가지고 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 일부 서비스를 클라우드 서비스 혹은 하이브리드 방식의 클라우드로의 전환을 검토 또는 진행 중에 있습니다.
&lt;/p&gt;
&lt;p&gt;
 퍼블릭 클라우드 인프라 시장도 급속도로 팽창을 하고 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 아래의 표에서도 나타나지만
 &lt;span&gt;
  IaaS, PaaS
 &lt;/span&gt;
 시장은 계속
 &lt;span&gt;
  4
 &lt;/span&gt;
 대 업체로 통합되고 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이들 대형업체는 신규 서비스를 지속적으로 내놓고 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 자신들의 강점 분야를 내세워 데이터센터 고객의 자사 클라우드 유도와 하이브리드 운영 방안에 대한 레퍼런스를 지속적으로 내놓고 있는 상황입니다.
&lt;/p&gt;
&lt;p&gt;
 가트너에 의하면 아마존은 2019년 7월 기준으로 전세계 IaaS 시장의 50% 이상을 여전히 차지하고 있는 것으로 발표하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/91696364/0.jpeg&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 참고
 &lt;span&gt;
  URL:
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.zdnet.co.kr/view/?no=20190730175837&quot; rel=&quot;nofollow&quot;&gt;
   https://www.zdnet.co.kr/view/?no=20190730175837
  &lt;/a&gt;
  (아마존 IaaS 시장 절반 이상 독식)
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  국내의 경우 가장 먼저 진출한 아마존
 &lt;/span&gt;
 &lt;span&gt;
  AWS
 &lt;/span&gt;
 &lt;span&gt;
  가 시장에서 많이 적용되고 있으며
 &lt;/span&gt;
 &lt;span&gt;
  ,
 &lt;/span&gt;
 &lt;span&gt;
  스타트업들에게는 사실상의 표준
 &lt;/span&gt;
 &lt;span&gt;
  (DeFacto Standard)
 &lt;/span&gt;
 &lt;span&gt;
  으로 자리를 잡았습니다
 &lt;/span&gt;
 &lt;span&gt;
  .
 &lt;/span&gt;
 &lt;span&gt;
  본 아티클에서는 엔터프라이즈 관점에서 데이터 센터을 어떻게 퍼블릭 클라우드로 전환하는지에 대해 살펴보려고 합니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  전환의 이유는 무엇인가
  &lt;span&gt;
   ?
  &lt;/span&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 국내 대기업의 데이터센터는 그룹사의
 &lt;span&gt;
  IT
 &lt;/span&gt;
 를 담당하는 회사에서 관리를 주로 하고 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 오픈스택 또는 가상화 기반 하의 클라우드라는 명칭으로 각 그룹 고객사에 서비스 제공하려 많은 노력들을 기울이고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 내부의
 &lt;span&gt;
  IT
 &lt;/span&gt;
 자원의 성능이 훨씬 더 압도적일 것이라 대부분 판단하지만 퍼블릭 클라우드 서비스 업체가 기반 물리 자원에 대한 액세스를 너무나 잘 관리하기 때문에 그 차이가 그렇게 극명하게 나지 않는 것이 일반적입니다.
&lt;/p&gt;
&lt;p&gt;
 또한 내부
 &lt;span&gt;
  ITSM
 &lt;/span&gt;
 시스템의 관제하에 들어가게 되므로 클라우드 컴퓨팅이 제공하는 가치의 많은 부분이 민첩성에서 나온다는 점에서 이를 포기하고 데이터 센터만을 고집하는 것도 좋은 결정은 아닐 것입니다.
 &lt;span&gt;
 &lt;/span&gt;
 이로 인해 퍼블릭 클라우드에 대한 도입 검토와 개념검증
 &lt;span&gt;
  (PoC),
 &lt;/span&gt;
 실제 전환이 활발하게 이루어지고 있는 실정입니다.
&lt;/p&gt;
&lt;p&gt;
 일반적으로 전환 후 록인
 &lt;span&gt;
  (lock-in)
 &lt;/span&gt;
 에 대해서 우려를 하는 기업들도 있겠지만 그러한 록인은 데이터 센터가 훨씬 더 심하며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 기업은 다양한 서버와 운영체제
 &lt;span&gt;
  ,
 &lt;/span&gt;
 애플리케이션
 &lt;span&gt;
  ,
 &lt;/span&gt;
 어플라이언스를 선택하고 원하는 특정 결과를 얻기 위한 과정일 뿐입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  어떻게 전환할 것인가
  &lt;span&gt;
   ?
  &lt;/span&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 클라우드 전환에 있어 중요한 한 가지는 클라우드라는 트렌드에 대한 기업의
 &lt;span&gt;
  ‘
 &lt;/span&gt;
 적응력
 &lt;span&gt;
  ’
 &lt;/span&gt;
 과
 &lt;span&gt;
  ‘
 &lt;/span&gt;
 변화에 대한 의지
 &lt;span&gt;
  ’
 &lt;/span&gt;
 가 가장 클 것입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 쿠팡
 &lt;span&gt;
  (
 &lt;/span&gt;
 쿠팡
 &lt;span&gt;
  , IT
 &lt;/span&gt;
 인프라 전체를
 &lt;span&gt;
  AWS
 &lt;/span&gt;
 클라우드로 이전했다
 &lt;span&gt;
  ,
 &lt;/span&gt;
 기사
 &lt;span&gt;
  :
  &lt;a class=&quot;external-link&quot; href=&quot;https://byline.network/2017/08/10-6/&quot; rel=&quot;nofollow&quot;&gt;
   https://byline.network/2017/08/10-6/
  &lt;/a&gt;
  )
 &lt;/span&gt;
 과 같이 모든 인프라를 퍼블릭 클라우드로 전환하는 경우도 있겠지만
 &lt;span&gt;
  ,
 &lt;/span&gt;
 대부분은 기존에 운영되던 시스템과 고객의 정보
 &lt;span&gt;
  (
 &lt;/span&gt;
 규제를 포함하는
 &lt;span&gt;
  )
 &lt;/span&gt;
 로 인하여
 &lt;span&gt;
  100%
 &lt;/span&gt;
 이전을 못하는 경우가 대다수이다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이로 인해 단계적인 클라우드 전환을 고려하게 되는데
 &lt;span&gt;
  ,
 &lt;/span&gt;
 아래와 같이 데이터 센터와 퍼블릭 클라우드를 연결하여 상호 통신을 할 수 있도록 서비스를 구성하게 됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/91696364/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 데이터센터와 퍼블릭 클라우드
 &lt;span&gt;
  &amp;gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 퍼블릭 클라우드로 전환할 수 있는 단계는 여러가지가 있을 수 있지만 우선 크게
 &lt;span&gt;
  3
 &lt;/span&gt;
 단계에 대한 전환 절차를 고려할 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 첫번째 단계로 대상 시스템 선정 및 기술입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 기존의 내부 시스템에 대한 조사를 통해 퍼블릭 클라우드의 유연성
 &lt;span&gt;
  (
 &lt;/span&gt;
 오토스케일링 같은
 &lt;span&gt;
  )
 &lt;/span&gt;
 을 통해 그 효과를 즉시 확인할 수 있는 시스템들이 그 대상이 될 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이러한 시스템에 대한
 &lt;span&gt;
  AS-IS
 &lt;/span&gt;
 현황 분석을 통해 클라우드 전환 시
 &lt;span&gt;
  TO-BE
 &lt;/span&gt;
 아키텍처를 그릴 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이 때 중요한 것은 전체 업무 대상 시스템이 아니며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 현재 가장 손쉽게 올릴 수 있는
 &lt;span&gt;
  WEB-WAS-DB
 &lt;/span&gt;
 아키텍처를 가진 트래픽의 양 변화가 큰 업무들이 대상이 될 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그 업무 시스템에서 사용하는 기술들이 클라우드로 전환됐을 때
 &lt;span&gt;
  ,
 &lt;/span&gt;
 그대로 옮겨갈 것인지
 &lt;span&gt;
  AWS
 &lt;/span&gt;
 와 같은 클라우드의 네이티브 서비스
 &lt;span&gt;
  (
 &lt;/span&gt;
 예
 &lt;span&gt;
  : ELB, RDS, DynamoDB)
 &lt;/span&gt;
 를 활용할 것인지도 중요한 결정 사항이 될 것입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 두번째 단계로는 시스템 전환입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 대부분의 큰 기업에서는 내부의 데이터센터와 클라우드를 연결하는 것을 기본 전제로 하고 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이 때 서비스를 어떻게 구성할지에 대한 부분의 검토를 하게 되는데
 &lt;span&gt;
  ,
 &lt;/span&gt;
 보통 퍼블릭 클라우드에서는 아래의 방식의 서비스들을 제공하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 기업의 퍼블릭 클라우드 연결 방식
 &lt;span&gt;
  &amp;gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 기업 내의 데이터 센터와의 연결 시 전용선
 &lt;span&gt;
  (
 &lt;/span&gt;
 비용 상승
 &lt;span&gt;
  )
 &lt;/span&gt;
 방식과
 &lt;span&gt;
  VPN
 &lt;/span&gt;
 을 통한 퍼블릭 클라우드 네트워크 연결을 고려할 수 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 비용과 안정성 측면에서 장단점이 존재하므로 전환 시 의사결정이 필요한 부분 중 하나이다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 이후 클라우드 시스템 내의 목표 시스템 설계
 &lt;span&gt;
  ,
 &lt;/span&gt;
 기술 아키텍처를 정의하고 기존의 베어메탈 방식에서 활용되던 개념을 스케일
 &lt;span&gt;
  -
 &lt;/span&gt;
 아웃형 시스템으로 전환 설계 후 전환 작업을 진행한다
 &lt;span&gt;
  .
 &lt;/span&gt;
 전환 단계 상에서 성능
 &lt;span&gt;
  ,
 &lt;/span&gt;
 안정성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 확장성 테스트를 통해 해당 시스템이 처리할 수 있는 능력을 정확하게 파악하고 이를 기준으로 향후 신규 온디맨드 시스템들이 필요한 경우 지표로 삼을 수 있어야 한다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 전환의 방식은 크게 아래와 가지를 들 수 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  Life-and-Shift 방식
  &lt;span&gt;
   :
  &lt;/span&gt;
  기존 시스템의 기능
  &lt;span&gt;
   ,
  &lt;/span&gt;
  소프트웨어 등을 변경하지 않고 그대로 클라우드 이전
 &lt;/li&gt;
 &lt;li&gt;
  Cloud-Native 방식
  &lt;span&gt;
   :
  &lt;/span&gt;
  퍼블릭 클라우드에서 운영할 수 있도록 초기 또는 전환 시점부터 클라우드가 제공하는 서비스 활용에 중점을 두어 이전
 &lt;/li&gt;
 &lt;li&gt;
  오픈소스 전환 방식
  &lt;span&gt;
   :
  &lt;/span&gt;
  클라우드의 이점인 확장성과 비용 효율성을 최대한 살릴 수 있도록 대응 오픈소스로 변경하여 이전
  &lt;span&gt;
   (
  &lt;/span&gt;
  멀티 클라우드 대응
  &lt;span&gt;
   ,
  &lt;/span&gt;
  록인 방지
  &lt;span&gt;
   )
  &lt;/span&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 전환에 대한 목표와 시스템 소프트웨어의 변경에 대한 예시는 다음의 그림과 같습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;img src=&quot;/assets/images/91696364/2.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 클라우드 목표모델 레이어 및 시스템 소프트웨어 변화
 &lt;span&gt;
  &amp;gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 마지막 단계로 운영 서비스로의 이행입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 전환 이후 전체 시스템에 대한 기능
 &lt;span&gt;
  ,
 &lt;/span&gt;
 성능에 대한 상세 모니터링을 진행하고 필요 시 인스턴스 개수 조절
 &lt;span&gt;
  ,
 &lt;/span&gt;
 사이즈 조정 등을 통해 비용최적화를 위한 작업을 진행합니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 이 때의 운영은
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 를 기반으로 한 운영 서비스를 전제로 하고
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 로의 전환
 &lt;span&gt;
  (
 &lt;/span&gt;
 클라우드와
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 툴을 통해 개발자 중심의 자동화 환경 구축
 &lt;span&gt;
  -&amp;gt;
 &lt;/span&gt;
 지속적인 배포
 &lt;span&gt;
  (CD, Continuous Delivery)
 &lt;/span&gt;
 가 가능하게 함으로써 효율성을 확보하고 개발자의 생산성과 비즈니스 민첩성 향상을 위한 기초를 만들 수 있도록 해야 합니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 기업이 가진 시스템에 대한 클라우드 전환은 빅뱅이 되어서는 안됩니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 현재는 차세대 개념의 빅뱅형이 아닌 점진형 방식의 전환을 통해 리스크를 최소화할 수 있는 전략을 구상해야 한다
 &lt;span&gt;
  .
 &lt;/span&gt;
 전환 이후에도 트렌드로 자리잡아가고 있는 마이크로서비스 아키텍처
 &lt;span&gt;
  ,
 &lt;/span&gt;
 컨테이너로의 확장과 자동화를 염두에 둔 전환이 필요한 시점이며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 이를 위한 조직
 &lt;span&gt;
  /
 &lt;/span&gt;
 운영의 관점도 달라져야 할 것입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;h1 id=&quot;id-데이터센터의클라우드전환-2.클라우드기반의컨테이너서비스를활용한PaaS&quot;&gt;
 &lt;strong&gt;
  2. 클라우드 기반의 컨테이너 서비스를 활용한
  &lt;span&gt;
   PaaS
  &lt;/span&gt;
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;p&gt;
 컨테이너 서비스가 대세다
 &lt;span&gt;
  .
 &lt;/span&gt;
 컨테이너는 리소스 격리 프로세스에서 애플리케이션과 종속 항목을 실행하게 해주는 운영 시스템 가상화 방법입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 컨테이너를 사용하면 애플리케이션의 코드
 &lt;span&gt;
  ,
 &lt;/span&gt;
 구성 및 의존성에 대한 사용이 단순한 빌딩 블록 형태로 바로 패키징할 수 있으며 빌딩 블록은 환경 일관성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 운영 효율성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 개발자 생산성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 버전 제어를 제공합니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이를 통해 애플리케이션이 보다 빠르고 안정적으로 배포와 운영이 될 수 있는 환경이 만들어질 수 있는 장점이 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현재 프라이빗
 &lt;span&gt;
  /
 &lt;/span&gt;
 퍼블릭 클라우드 기반의 인프라를 구축하거나 이미 사용하고 있는 엔터프라이즈에서는
 &lt;span&gt;
  DevOps,
 &lt;/span&gt;
 시스템 간의 오케스트레이션을 위하여 적극적으로 컨테이너 서비스에 대한 조사와 도입 검토를 진행하고 있는 상황입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이러한 맥락과 함께 컨테이너 서비스 시장은 현재 엄청난 팽창을 하고 있으며 클라우드와 연계된 기술 영역에서 매년
 &lt;span&gt;
  40%
 &lt;/span&gt;
 이상의 높은 성장률을 통해
 &lt;span&gt;
  2020
 &lt;/span&gt;
 년까지
 &lt;span&gt;
  27
 &lt;/span&gt;
 억 달러 수준으로 커질 것으로 전망하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;img src=&quot;/assets/images/91696364/3.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 애플리케이션 컨테이너 서비스 시장 전망
 &lt;span&gt;
  , 2017. 451 Research’s
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 출처
 &lt;span&gt;
  :
  &lt;a class=&quot;external-link&quot; href=&quot;https://451research.com/images/Marketing/press_releases/Application-container-market-will-reach-2-7bn-in-2020_final_graphic.pdf&quot; rel=&quot;nofollow&quot;&gt;
   https://451research.com/images/Marketing/press_releases/Application-container-market-will-reach-2-7bn-in-2020_final_graphic.pdf
  &lt;/a&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현재 아마존
 &lt;span&gt;
  , IBM,
 &lt;/span&gt;
 마이크로소프트의 퍼블릭 클라우드에서도 이러한 컨테이너 서비스를 통한 애플리케이션 빌딩 블록을 만들 수 있는 서비스를 이미 내놓고 있는 상태이며
 &lt;span&gt;
  , PaaS(Platform as a Service)
 &lt;/span&gt;
 환경을 구축하는 부분에 대해 적극적으로 고객을 유도하고 있는 상황입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현재 컨테이너 서비스들은 대부분 리눅스 환경에서 작동되고
 &lt;span&gt;
  Linux
 &lt;/span&gt;
 컨테이너를 활용하여 개발 팀과 운영 팀 간의 충돌을 줄일 수 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한
 &lt;span&gt;
  , Linux
 &lt;/span&gt;
 컨테이너는
 &lt;span&gt;
 &lt;/span&gt;
 &lt;span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.redhat.com/ko/open-source&quot; rel=&quot;nofollow&quot;&gt;
   오픈소스
  &lt;/a&gt;
 &lt;/span&gt;
 기술을 기반으로 하기 때문에 사용 즉시 최신 기술을 활용하여 회사 내부 인프라 및 애플리케이션에 대한 발전을 시킬 수 있는 특징을 가지고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 &lt;span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;http://thenewstack.io/cri-o-make-kubernetes-center-container-ecosystem/&quot; rel=&quot;nofollow&quot;&gt;
   CRI-O
  &lt;/a&gt;
 &lt;/span&gt;
 ,
 &lt;span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;http://kubernetes.io/&quot; rel=&quot;nofollow&quot;&gt;
   Kubernetes
  &lt;/a&gt;
 &lt;/span&gt;
 및
 &lt;span&gt;
 &lt;/span&gt;
 &lt;span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.redhat.com/ko/topics/containers/what-is-docker&quot; rel=&quot;nofollow&quot;&gt;
   Docker
  &lt;/a&gt;
 &lt;/span&gt;
 등의 컨테이너 기술은 애플리케이션 개발 및 배포를 간소화하고 가속화하는 데 큰 도움이 됩니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  퍼블릭 클라우드의 컨테이너 서비스
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 퍼블릭 클라우드들은 컨테이너를 위한 다양한 서비스를 제공하여 고객들을 자사의 클라우드 서비스로 유도하기 위해 많은 노력을 기울이고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 IBM 클라우드에서는
 &lt;span&gt;
  Blumix Container Service
 &lt;/span&gt;
 를 통해 컨테이너 서비스를 제공하고 있으며,
 &lt;span&gt;
 &lt;/span&gt;
 하위의 인프라 기반은
 &lt;span&gt;
  Kubernetes
 &lt;/span&gt;
 와
 &lt;span&gt;
  Docker
 &lt;/span&gt;
 기반으로 스케줄링
 &lt;span&gt;
  ,
 &lt;/span&gt;
 자체 복구
 &lt;span&gt;
  ,
 &lt;/span&gt;
 스케일
 &lt;span&gt;
  -
 &lt;/span&gt;
 아웃 기능을 제공하고
 &lt;span&gt;
  IBM
 &lt;/span&gt;
 의 인프라에서는 마스터 노드를 관리하며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 사용자들은 자신들의 서비스에 대한 작업 노드를 정의하는 구조로 되어 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 특징적인 부분은
 &lt;span&gt;
  CLI
 &lt;/span&gt;
 기반으로 클러스터 배치 등을 관리하고 강점으로 내세우는 왓슨
 &lt;span&gt;
  (Watson)
 &lt;/span&gt;
 을 활용하여 스토리지
 &lt;span&gt;
  ,
 &lt;/span&gt;
 분석
 &lt;span&gt;
  ,
 &lt;/span&gt;
 액세스 제어 등에 대한 서비스를 통합할 수 있는 기능을 제공하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 아마존은
 &lt;span&gt;
  ECS(Amazon EC2 Container Service)
 &lt;/span&gt;
 서비스를 통해
 &lt;span&gt;
  Docker
 &lt;/span&gt;
 컨테이너를 제공하고 있으며
 &lt;span&gt;
  , EKS(Elastic Kubernetes Service)의
 &lt;/span&gt;
 자체 클러스터 관리 인프라를 구축하여 고객에게 제공하고 있습니다
 &lt;span&gt;
  . SDK
 &lt;/span&gt;
 를 통한
 &lt;span&gt;
  API
 &lt;/span&gt;
 호출을 통해 클러스터 상태관리
 &lt;span&gt;
  ,
 &lt;/span&gt;
 보안
 &lt;span&gt;
  ,
 &lt;/span&gt;
 엘라스틱 로드밸런싱
 &lt;span&gt;
  , EBS
 &lt;/span&gt;
 등에 대한 리소스 연계와 확장을 제공하고 있는 특징이 있으며
 &lt;span&gt;
  , EC2
 &lt;/span&gt;
 서비스 내에 포함되어 컨테이너 서비스에 대한 별도 비용이 필요없다는 특징이 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 마이크로소프트는 애저 컨테이너 서비스를 활용하여 아마치 메소스
 &lt;span&gt;
  , Docker
 &lt;/span&gt;
 등을 함께 사용할 수 있는 서비스를 제공하고 있으며
 &lt;span&gt;
  , 2015
 &lt;/span&gt;
 년에 서비스를 출시했습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 다른 퍼블릭 클라우드와는 다르게
 &lt;span&gt;
  Docker
 &lt;/span&gt;
 를 위한 비주얼 스튜디오
 &lt;span&gt;
  (Visual Studio Tools for Docker)
 &lt;/span&gt;
 를 통해 컨테이너 환경 하에서 윈도우용
 &lt;span&gt;
  .NET
 &lt;/span&gt;
 이나 리눅스용 코어 응용 프로그램을 빌드하여 배포할 수 있는 기능을 제공하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한 비주얼 스튜디오 팀 서비스를 통해 애자일 및
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 를 위한 워크플로우에 컨테이너를 통합할 수 있는 기능을 제공하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Docker
 &lt;/strong&gt;
 &lt;strong&gt;
  를 통한 기술
  &lt;span&gt;
   /
  &lt;/span&gt;
  프로세스 표준화
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 프라이빗과 퍼블릭 클라우드의 방향성은
 &lt;span&gt;
  IaaS
 &lt;/span&gt;
 기반에서 컨테이너 서비스를 통한 플랫폼 유연성을 극대화하는 방법으로도 진화하고 있습니다
 &lt;span&gt;
  . Docker
 &lt;/span&gt;
 는 별도의 게스트
 &lt;span&gt;
  OS
 &lt;/span&gt;
 를 설치하지 않고 커널 레벨에서 격리된 가상의 공간을 제공한다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이의 장점은 호스트 운영체제와의 속도 차이가 거의 없고 가상머신보다 경량화된 상태에서 관리를 할 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/91696364/4.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 클라우드
 &lt;span&gt;
  ,
 &lt;/span&gt;
 컨테이너
 &lt;span&gt;
  ,
 &lt;/span&gt;
 마이크로서비스
 &lt;span&gt;
  , DevOps
 &lt;/span&gt;
 구조
 &lt;span&gt;
  , DZone
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 출처
 &lt;span&gt;
  :
  &lt;a class=&quot;external-link&quot; href=&quot;https://dzone.com/articles/markus-eisele-answers-questions-about-java-ee-and&quot; rel=&quot;nofollow&quot;&gt;
   https://dzone.com/articles/markus-eisele-answers-questions-about-java-ee-and
  &lt;/a&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현재 많은 기업들이 자사의 서비스 기반을 마이크로 아키텍처 서비스로 만들고자 하면서 컨테이너 서비스를 활용하고 이에 대한 내부 기술 표준화를 위한 시도를 많이 하고 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한 개발
 &lt;span&gt;
  /
 &lt;/span&gt;
 배포
 &lt;span&gt;
  /
 &lt;/span&gt;
 운영 프로세스에 대한 부분을 컨테이너 서비스를 통해 일원화하기 위한 노력도 병행하고 있습니다
 &lt;span&gt;
  . MSA(Micro Service Architecture)
 &lt;/span&gt;
 를 컨테이너 기반으로 구성하는데 있어 프로세스화 되어야 하는 부분은
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 영역입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 컨테이너는 이러한
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 영역에 대한 부분을 통합할 수 있도록 하는 좋은 방법 중의 하나입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 컨테이너는 개발과 운영이라는 두 팀간의 장벽을 허무는
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 의 가교 역할을 하게 되며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 두 팀이 함께 협업하여 개발자 생산성과 운영의 안정성이라는 두 마리 토끼를 잡게 해줍니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그러한 관점에서 인프라
 &lt;span&gt;
  ,
 &lt;/span&gt;
 컨테이너
 &lt;span&gt;
  ,
 &lt;/span&gt;
 미들웨어 컴포넌트를 컨테이너화함으로써 클라우드 네이티브 형태의 애플리케이션을 만들 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한 기업이 가진 업무 시스템을 최적화하는 방법으로 컨테이너화된 다양한 오픈소스 기술을 활용하여 비즈니스적인 목표를 달성할 수도 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이를 도식화한 간략한 그림은 아래와 같습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/91696364/5.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 클라우드 네이티브 영역 지도
 &lt;span&gt;
  (
  &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/cncf/landscape&quot; rel=&quot;nofollow&quot;&gt;
   https://github.com/cncf/landscape
  &lt;/a&gt;
 &lt;/span&gt;
 의 도식도를 축약한 것임
 &lt;span&gt;
  )
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그림에서 보는 것처럼 컨테이너 서비스는 그 기반이 퍼블릭과 프라이빗과 상관없이 작동시키며 프로비저닝 자동화
 &lt;span&gt;
  ,
 &lt;/span&gt;
 프로세스 개선
 &lt;span&gt;
  , DevOps
 &lt;/span&gt;
 를 활용할 수 있는 기반을 마련해줍니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한 조직이 소프트웨어 개발과 인프라 관리 프로세스의 자동화 및 간소화를 통해 더 빠르게 혁신할 수 있도록 지원하며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 이를 통한 비즈니스 이익이 극대화될 수 있도록 도와줍니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 컨테이너
 &lt;span&gt;
  , PaaS, DevOps
 &lt;/span&gt;
 는 상호 연결된 밀접한 단어이다
 &lt;span&gt;
  .
 &lt;/span&gt;
 아직
 &lt;span&gt;
  IaaS
 &lt;/span&gt;
 를 기반으로 한 클라우드
 &lt;span&gt;
  (
 &lt;/span&gt;
 퍼블릭
 &lt;span&gt;
  /
 &lt;/span&gt;
 클라우드
 &lt;span&gt;
  )
 &lt;/span&gt;
 에 대한 경험이 없는 상태라 하더라도 기획을 해볼 수 있는 중요한 아이템이 바로 컨테이너 기반
 &lt;span&gt;
  PaaS
 &lt;/span&gt;
 영역이다
 &lt;span&gt;
  .
 &lt;/span&gt;
 인프라 자동화
 &lt;span&gt;
  , DevOps, MSA
 &lt;/span&gt;
 등의 단어를 의식하고 있다면 클라우드 기반의 컨테이너 서비스 대한 적극적 검토를 해보아야 하며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 향후 펼쳐지게 될
 &lt;span&gt;
  IT
 &lt;/span&gt;
 시스템의 변화에 대한 준비를 해야 할 것입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;</description>
        <pubDate>Wed, 25 Mar 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/03/25/91696364/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/03/25/91696364/</guid>
        
        <category>클라우드</category>
        
        <category>docker</category>
        
        <category>cncf</category>
        
        <category>msa</category>
        
        
      </item>
    
      <item>
        <title>[Container 시리즈] 03. Docker File, Docker Image - 도커파일 및 이미지에 대하여</title>
        <description>&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-information conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;info&quot;&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   도커를 설치하고 컨테이너를 실행해봤으니 이제는 도커 이미지를 만들고 서버에 배포해볼 차례!
  &lt;/p&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  도커 개념에서도 다뤄봤듯이, 도커는 도커 파일을 가지고 도커 이미지를 만들게 되는데요,
 &lt;/p&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   다시 한번 말씀드리자면, Docker File이란 Docker Image를 만들기 위한 여러가지 명렁어의 집합입니다.
  &lt;/p&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
  프로페셔널한 엔지니어라면 뚝딱뚝딱 Dockerfile을 만들 수 있지만
 &lt;/p&gt;
 &lt;p&gt;
  저는 초보자이기 때문에 서버에 명령어를 입력하고 버그를 잡아가면서 Dockerfile을 한 땀 한 땀 만듭니다.
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/91695884/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  만약에 여러분이 우분투 서버에서 nginx를 설치해서 실행한다고 가정했을 시
순서는 다음과 같습니다.
 &lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;
   ubuntu 설치
  &lt;/li&gt;
  &lt;li&gt;
   패키지 업데이트
  &lt;/li&gt;
  &lt;li&gt;
   nginx 설치
  &lt;/li&gt;
  &lt;li&gt;
   경로설정 (필요한 경우)
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;p&gt;
  먼저 리눅스 서버에서 한줄한줄 테스트를 해봅니다
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;## 1. ubuntu 설치 &amp;amp; 2. 패키지 업데이트
# 테스트 ubuntu 서버를 사용하였기 때문에 패키지 업데이트를 먼저 합니다.

kbseo@KB-SEO:~$ sudo apt-get update
[sudo] password for kbseo:
Hit:1 http://mirror.kakao.com/ubuntu bionic InRelease
Get:2 http://mirror.kakao.com/ubuntu bionic-updates InRelease [88.7 kB]
Get:3 http://mirror.kakao.com/ubuntu bionic-backports InRelease [74.6 kB]
Get:4 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB]
Get:5 http://mirror.kakao.com/ubuntu bionic-updates/main amd64 Packages [872 kB]
Get:6 http://mirror.kakao.com/ubuntu bionic-updates/main Translation-en [303 kB]
Get:7 http://mirror.kakao.com/ubuntu bionic-updates/restricted amd64 Packages [32.9 kB]
Get:8 http://mirror.kakao.com/ubuntu bionic-updates/restricted Translation-en [8468 B]
Get:9 http://mirror.kakao.com/ubuntu bionic-updates/universe amd64 Packages [1055 kB]
Get:10 http://mirror.kakao.com/ubuntu bionic-updates/universe Translation-en [326 kB]
Get:11 http://mirror.kakao.com/ubuntu bionic-updates/multiverse amd64 Packages [10.1 kB]
Get:12 http://mirror.kakao.com/ubuntu bionic-updates/multiverse Translation-en [4636 B]
Get:13 http://mirror.kakao.com/ubuntu bionic-backports/universe amd64 Packages [4028 B]
Get:14 http://security.ubuntu.com/ubuntu bionic-security/main amd64 Packages [651 kB]
Get:15 http://security.ubuntu.com/ubuntu bionic-security/main Translation-en [211 kB]
Get:16 http://security.ubuntu.com/ubuntu bionic-security/restricted amd64 Packages [23.8 kB]
Get:17 http://security.ubuntu.com/ubuntu bionic-security/restricted Translation-en [6528 B]
Get:18 http://security.ubuntu.com/ubuntu bionic-security/universe amd64 Packages [648 kB]
Get:19 http://security.ubuntu.com/ubuntu bionic-security/universe Translation-en [215 kB]
Get:20 http://security.ubuntu.com/ubuntu bionic-security/multiverse amd64 Packages [6756 B]
Get:21 http://security.ubuntu.com/ubuntu bionic-security/multiverse Translation-en [2700 B]
Fetched 4634 kB in 6s (739 kB/s)
Reading package lists... Done
kbseo@KB-SEO:~$

## 3. nginx 설치
kbseo@KB-SEO:~$ sudo apt-get install nginx
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  fontconfig-config fonts-dejavu-core libfontconfig1 libgd3 libjbig0 libjpeg-turbo8 libjpeg8 libnginx-mod-http-geoip
  libnginx-mod-http-image-filter libnginx-mod-http-xslt-filter libnginx-mod-mail libnginx-mod-stream libtiff5 libwebp6
  libxpm4 nginx-common nginx-core
Suggested packages:
  libgd-tools fcgiwrap nginx-doc ssl-cert
The following NEW packages will be installed:
  fontconfig-config fonts-dejavu-core libfontconfig1 libgd3 libjbig0 libjpeg-turbo8 libjpeg8 libnginx-mod-http-geoip
  libnginx-mod-http-image-filter libnginx-mod-http-xslt-filter libnginx-mod-mail libnginx-mod-stream libtiff5 libwebp6
  libxpm4 nginx nginx-common nginx-core
0 upgraded, 18 newly installed, 0 to remove and 239 not upgraded.
Need to get 2461 kB of archives.
After this operation, 8210 kB of additional disk space will be used.
Do you want to continue? [Y/n] y
...
...
#이하 생략
#설치 확인
kbseo@KB-SEO:~$ nginx -v
nginx version: nginx/1.14.0 (Ubuntu)
kbseo@KB-SEO:~$

# 설치파일 경로
kbseo@KB-SEO:/etc/nginx$ pwd
/etc/nginx

&lt;/code&gt;&lt;/pre&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   여기서 잠깐
  &lt;/p&gt;
  &lt;blockquote&gt;
   &lt;ul&gt;
    &lt;li&gt;
     저희는 nginx를 패키지를 통하여 설치 하였기에 Default directory가 /etc/nginx 아래에 위치하게 됩니다.
    &lt;/li&gt;
    &lt;li&gt;
     직접 compile한 경우에 경로는 /usr/local/nginx/conf 혹은 /use/local/etc/nginx 에 위치하고 있습니다.
    &lt;/li&gt;
    &lt;li&gt;
     그래도 경로가 없다 한다면 다음의 명령어를 통해 찾을 수 있습니다.
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;pre&gt;&lt;code&gt;kbseo@KB-SEO:/etc/nginx$ sudo find / -name nginx.conf
/etc/nginx/nginx.conf
&lt;/code&gt;&lt;/pre&gt;
  &lt;/blockquote&gt;
 &lt;/blockquote&gt;
 &lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;
   경로설정 (필요한 경우)
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;kbseo@KB-SEO:/etc/nginx$ ls
conf.d        fastcgi_params  koi-win     modules-available  nginx.conf    scgi_params      sites-enabled  uwsgi_params
fastcgi.conf  koi-utf         mime.types  modules-enabled    proxy_params  sites-available  snippets       win-utf

# 기본적인 환경 설정 파일 정보는 sites-available/default 이곳에 있습니다.
# 따라서 웹서버의 루트 디렉토리 변경 등의 작업이 필요하다면 이곳에 들어가 작업하시면 됩니다.

kbseo@KB-SEO:/etc/nginx$ vim sites-available/default

&lt;/code&gt;&lt;/pre&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/91695884/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  &lt;em&gt;
   설정하실때 세미콜론(;) 잊지 말아쥬세염
  &lt;/em&gt;
 &lt;/p&gt;
 &lt;p&gt;
  저는 테스트이기 때문에 따로 경로 설정은 안하고 Default로 두었습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;# index.html 를 만든 후 찍어 봅니다.
kbseo@KB-SEO:/var/www/html$ sudo service nginx restart
 * Restarting nginx nginx                                           [ OK ]
kbseo@KB-SEO:/var/www/html$
kbseo@KB-SEO:/var/www/html$ curl 127.0.0.1
Hello KB
&lt;/code&gt;&lt;/pre&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91695884/2.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;hr/&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#이제는-이런-한땀한땀-구축한-명령어를-토대로-docker-file을-만들어-보겠습니다&quot; id=&quot;이제는-이런-한땀한땀-구축한-명령어를-토대로-docker-file을-만들어-보겠습니다&quot;&gt;
   이제는 이런 한땀한땀 구축한 명령어를 토대로 docker file을 만들어 보겠습니다.
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;ol&gt;
  &lt;li&gt;
   ubuntu 설치
  &lt;/li&gt;
  &lt;li&gt;
   패키지 업데이트
  apt-get update
  &lt;/li&gt;
  &lt;li&gt;
   nginx 설치
  apt-get install nginx
  &lt;/li&gt;
  &lt;li&gt;
   경로설정 (필요한 경우)
  cd /etc/nginx
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;br/&gt;
 &lt;p&gt;
  위와 같은 순서로 한줄한줄 수작업을 해 주었는데
Docker file은 어떨까요?
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;FROM ubuntu:14.04 
MAINTAINER Dongbin Na &quot;kbseo@osci.kr&quot; 
RUN apt-get update
RUN apt-get install -y nginx
WORKDIR /etc/nginx 
CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
EXPOSE 80 
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;br/&gt;
  &lt;br/&gt;
  docker file이 거의 흡사하게 작성된 것을 보실 수 있습니다.
아마 도커파일에 있는 내용들이 생소하실 여러분(저를 포함)을 위해 하나하나 뜯어 보도록 할까요?
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   1. FROM ubuntu:14.04
  &lt;/code&gt;
  -&amp;gt; 기반으로 할 이미지를 가져옵니다.
여기에서는 ubuntu 14.04버전의 이미지를 가져오겠습니다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   2. MAINTAINER Dongbin Na &quot;kbseo@osci.kr&quot;
  &lt;/code&gt;
  -&amp;gt; 작성자의 정보를 기입해줍니다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   3. RUN apt-get update
  &lt;/code&gt;
  -&amp;gt; RUN이라는 명령어를 통하여 쉘 스크립트를 실행하여 줍니다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   4. RUN apt-get install -y nginx
  &lt;/code&gt;
  -&amp;gt; 도커 빌드 중에는 키보드를 입력할 수 없기에
  &lt;em&gt;
   [-y]
  &lt;/em&gt;
  옵션을 넣어줍니다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   5. WORKDIR /etc/nginx
  &lt;/code&gt;
  -&amp;gt; 이후 CMD 명령어가 실행 할 경로로 먼저 이동을 해 줍니다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   6. CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
  &lt;/code&gt;
  -&amp;gt; nginx를 백그라운드로 실행합니다
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   7. EXPOSE 80
  &lt;/code&gt;
  -&amp;gt; 80번 포트를 오픈하여 웹서버에 정상적으로 접근할 수 있게 합니다.
  &lt;br/&gt;
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  아직까지 Dockerfile 명령어들이 익숙치 않으시죠?
  &lt;del&gt;
   아니라고 해도
  &lt;/del&gt;
  명령어들은 좀더 나눠서 알아보겠습니다.
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
   &lt;tr&gt;
    &lt;th align=&quot;left&quot;&gt;
     명렁어
    &lt;/th&gt;
    &lt;th align=&quot;center&quot;&gt;
     내용
    &lt;/th&gt;
    &lt;th align=&quot;center&quot;&gt;
     예시
    &lt;/th&gt;
    &lt;th align=&quot;center&quot;&gt;
    &lt;/th&gt;
   &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      FROM
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     - 베이스 이미지를 지정해줍니다.
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     FROM &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     FROM ubuntu:14.04
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  &lt;em&gt;
   -&amp;gt; 베이스 이미지는 반드시 지정해줘야하며, 버전정보는 latest보다는 구체적인 버전을 지정해주는것이 좋습니다.
  &lt;/em&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      RUN
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     - 직접적으로 쉘 스크립트 내에서 실행 될 명령어 앞에 적어줍니다.
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     RUN &amp;lt;command&amp;gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     RUN apt-get update
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  &lt;em&gt;
   -&amp;gt; 실질적으로 가장 많이 쓰이는 명령어 입니다
  &lt;/em&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      CMD
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     - 도커가 실행될 때 실행할 명령어를 정의해줍니다.
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     CMD [&quot;executable&quot;, &quot;param&quot;, &quot;param&quot;]
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  &lt;em&gt;
   -&amp;gt; 도커 빌드시에는 실행되지 않으며, 여러개의 CMD 명령어가 존재할 경우 가장 마지막 명령어만 실행 됩니다.
  &lt;/em&gt;
  &lt;em&gt;
   CMD nginx 라고 입력하면 nginx 서버를 구동시키게 됩니다.
  &lt;/em&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      WORKDIR
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     - 이후 명령어가 작업할 디렉토리로 이동합니다
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     WORKDIR /path
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     WORKDIR /etc/nginx
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  &lt;em&gt;
   -&amp;gt; 명령어(RUN, CMD ) 등이 실행될 디렉토리를 설정합니다.
  &lt;/em&gt;
  &lt;em&gt;
   각 명령어는 줄마다 초기화가 되기 때문에 'RUN cd /path' 로 경로를 잡아줘도 다음줄에선 다시 위치가 초기화가 됩니다.
  &lt;/em&gt;
  &lt;em&gt;
   같은 디렉토리에서 계속 작업하기 위하여 WORKDIR을 사용해줍니다.
  &lt;/em&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      COPY
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     - 파일이나 디렉토리를 이미지로 복사합니다
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     COPY &amp;lt;src&amp;gt; &amp;lt;dst&amp;gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     COPY . /usr/src/app
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  &lt;em&gt;
   -&amp;gt; 일반적으로 소스를 복사하는데 사용합니다
  &lt;/em&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      ADD
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     - COPY와 비슷하게 복사를 위해 사용합니다
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     ADD &amp;lt;src&amp;gt; &amp;lt;dst&amp;gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     ADD . /usr/src/app
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  &lt;em&gt;
   -&amp;gt; COPY명령어와 비슷하게 소스를 복사하는데 사용하지만 차이점은 ADD같은경우 압축파일이 있을 경우 자동으로 압축을 해제하면서 복사됩니다.
  &lt;/em&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      EXPOSE
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     - 공개 하고자 하는 포트를 지정해줍니다
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     EXPOSE &amp;lt;port&amp;gt;
    &lt;/td&gt;
    &lt;td align=&quot;center&quot;&gt;
     EXPOSE 80
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  &lt;em&gt;
   -&amp;gt; 호스트와 연결해줄 포트를 지정해주며, 여러개의 포트를 지정할 수 있습니다.
  &lt;/em&gt;
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  이 밖에 사용되는
  &lt;code&gt;
   ENV
  &lt;/code&gt;
  ,
  &lt;code&gt;
   VOLUME
  &lt;/code&gt;
  같은 명령어는
  &lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot;&gt;
   공식문서
  &lt;/a&gt;
  를 참고 바랍니다
 &lt;/p&gt;
 &lt;p&gt;
  &lt;br/&gt;
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#dockerfile을-만들었으니-build를-해봅시다&quot; id=&quot;dockerfile을-만들었으니-build를-해봅시다&quot;&gt;
   Dockerfile을 만들었으니 Build를 해봅시다.
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;docker build --force-rm --tag mynginx:0.1 .
&lt;/code&gt;&lt;/pre&gt;
 &lt;ul&gt;
  &lt;li&gt;
   --force-rm : 기존에 존재하는 image를 삭제합니다.
  &lt;/li&gt;
  &lt;li&gt;
   --tag : 태그를 설정해줍니다.
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;
[kbseo@ip-172-20-1-221 docker]$ docker build --force-rm --tag mynginx:0.1 .
Sending build context to Docker daemon  2.048kB
Step 1/7 : FROM ubuntu:14.04
14.04: Pulling from library/ubuntu
2e6e20c8e2e6: Pull complete 
30bb187ac3fc: Pull complete 
b7a5bcc4a58a: Pull complete 
Digest: sha256:ffc76f71dd8be8c9e222d420dc96901a07b61616689a44c7b3ef6a10b7213de4
Status: Downloaded newer image for ubuntu:14.04
 ---&amp;gt; 6e4f1fe62ff1
Step 2/7 : MAINTAINER Dongbin Na &quot;kbseo@osci.kr&quot;
 ---&amp;gt; Running in 224535a7dd96
Removing intermediate container 224535a7dd96
 ---&amp;gt; dc0f4b41cf96
Step 3/7 : RUN apt-get update
 ---&amp;gt; Running in 1e6d817f7aa0
...
...
Removing intermediate container 1e6d817f7aa0
 ---&amp;gt; bf2a670332b6
Step 4/7 : RUN apt-get install -y nginx
 ---&amp;gt; Running in b5fe65990ed8
...
...
Removing intermediate container b5fe65990ed8
 ---&amp;gt; 6664b9edcc36
Step 5/7 : WORKDIR /etc/nginx
 ---&amp;gt; Running in 34f5b2fe1f42
Removing intermediate container 34f5b2fe1f42
 ---&amp;gt; bc81d2ba24e1
Step 6/7 : CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
 ---&amp;gt; Running in 45d49d210fea
Removing intermediate container 45d49d210fea
 ---&amp;gt; 44591f5b5a0c
Step 7/7 : EXPOSE 80
 ---&amp;gt; Running in b98221c6597d
Removing intermediate container b98221c6597d
 ---&amp;gt; 747275175211
Successfully built 747275175211
Successfully tagged mynginx:0.1
[kbseo@ip-172-20-1-221 docker]$ 

# 이미지확인
[kbseo@ip-172-20-1-221 docker]$ docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
mynginx                      0.1                 747275175211        12 minutes ago      231MB
registry                     latest              708bc6af7e5e        7 weeks ago         25.8MB
ubuntu                       14.04               6e4f1fe62ff1        2 months ago        197MB
localhost:5000/hello-world   latest              fce289e99eb9        14 months ago       1.84kB
hello-world                  latest              fce289e99eb9        14 months ago       1.84kB
[kbseo@ip-172-20-1-221 docker]$ 

&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;br/&gt;
  &lt;br/&gt;
  빌드가 완료되어 Docker Image가 만들어진 것을 확인할 수 있는데요
이 빌드가 되는 과정들도 또 하나하나 살펴보도록 하겠습니다.
 &lt;/p&gt;
 &lt;p&gt;
  빌드과정을 요약하면 다음과 같습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;Sending build context to Docker daemon  2.048kB               &amp;lt;---   [1]
Step 1/7 : FROM ubuntu:14.04                                  &amp;lt;---   [2]            
14.04: Pulling from library/ubuntu                            &amp;lt;---   [3]
 ---&amp;gt; 6e4f1fe62ff1                                            &amp;lt;---   [4]
Step 2/7 : MAINTAINER Dongbin Na &quot;kbseo@osci.kr&quot;              &amp;lt;---   [5]
 ---&amp;gt; Running in 224535a7dd96                                 &amp;lt;---   [6]
Removing intermediate container 224535a7dd96                  &amp;lt;---   [7]
 ---&amp;gt; dc0f4b41cf96                                            &amp;lt;---   [8]
Step 3/7 : RUN apt-get update                                 &amp;lt;---   [9]
 ---&amp;gt; Running in 1e6d817f7aa0
...
Successfully built 747275175211                               &amp;lt;---   [10]
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [1]
  &lt;/strong&gt;
  &lt;code&gt;
   Sending build context to Docker daemon 2.048kB
  &lt;/code&gt;
  &lt;br/&gt;
  도커는 서버 클라이언트 구조이기 때문에 작업할 도커파일들(build context)을 도커서버(daemon)으로 전송해줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [2]
  &lt;/strong&gt;
  &lt;code&gt;
   Step 1/7 : FROM ubuntu:14.04
  &lt;/code&gt;
  &lt;br/&gt;
  빌드할 도커파일의 제일 윗줄부터 한줄한줄 실행하여 줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [3]
  &lt;/strong&gt;
  &lt;code&gt;
   14.04: Pulling from library/ubuntu
  &lt;/code&gt;
  &lt;br/&gt;
  ubuntu라는 이미지를 repository에서 다운받는 작업을 합니다
기본적으로 DockerHub Repository를 사용하고 있으며 사용자가 별도의 저장소를 지정할 수 있습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [4]
  &lt;/strong&gt;
  &lt;code&gt;
   ---&amp;gt; 6e4f1fe62ff1
  &lt;/code&gt;
  &lt;br/&gt;
  다운받은 ubuntu 이미지의 ID를 출력해줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [5]
  &lt;/strong&gt;
  &lt;code&gt;
   Step 2/7 : MAINTAINER Dongbin Na &quot;kbseo@osci.kr&quot;
  &lt;/code&gt;
  &lt;br/&gt;
  도커파일의 두번째 명령어를 실행해줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [6]
  &lt;/strong&gt;
  &lt;code&gt;
   ---&amp;gt; Running in 224535a7dd96
  &lt;/code&gt;
  &lt;br/&gt;
  도커는 이미지 형태로 저장하기 때문에 바로위에서 실행한 우분투 이미지 '6e4f1fe62ff1'를 기반으로 임시 컨테이너 '224535a7dd96' 를 만듭니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [7],[8]
  &lt;/strong&gt;
  &lt;br/&gt;
  &lt;code&gt;
   Removing intermediate container 224535a7dd96
  &lt;/code&gt;
  &lt;br/&gt;
  &lt;code&gt;
   ---&amp;gt; dc0f4b41cf96
  &lt;/code&gt;
  &lt;br/&gt;
  임시로 실행했던 컨테이너 '224535a7dd96'를 삭제해주고 새로운 이미지 'dc0f4b41cf96'를 만듭니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [9]
  &lt;/strong&gt;
  &lt;code&gt;
   Step 3/7 : RUN apt-get update
  &lt;/code&gt;
  &lt;br/&gt;
  도커파일에 작성하였던 다음줄의 명령어를 실행해줍니다.
이전 단계 에서처럼 _전에 만들어진 이미지를 기반으로 임시 컨테이너를 만들어 명령어를 실행하고 이를 또 다른 이미지로 저장을 한 후 임시 컨테이너는 삭제_하여줍니다.
이러한 과정을 도커파일의 마지막 명령줄까지 반복합니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   [10]
  &lt;/strong&gt;
  &lt;code&gt;
   Successfully built 747275175211
  &lt;/code&gt;
  &lt;br/&gt;
  최종적으로 만들어진 이미지ID를 멋지게 출력해줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  좀 전에 빌드했던 도커파일을 다시 빌드하게 되면 처음 빌드했을 때 보다 훨씬 빨라지게 되는데요
그 이유는, 명령어를 실행할 때 이미지 위에 레이어를 추가하는 형태로 저장을 하게 되고 재 빌드를 하게 되면 기존에 저장된 이미지를 그대로 캐시처럼 사용하여 빌드 하기 때문입니다. (변경된 사항이 없다면)
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;# 재빌드
Sending build context to Docker daemon  2.048kB
Step 1/7 : FROM ubuntu:14.04
 ---&amp;gt; 6e4f1fe62ff1
Step 2/7 : MAINTAINER Dongbin Na &quot;kbseo@osci.kr&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; dc0f4b41cf96
Step 3/7 : RUN apt-get update
 ---&amp;gt; Using cache
 ---&amp;gt; bf2a670332b6
Step 4/7 : RUN apt-get install -y nginx
 ---&amp;gt; Using cache
 ---&amp;gt; 6664b9edcc36
Step 5/7 : WORKDIR /etc/nginx
 ---&amp;gt; Using cache
 ---&amp;gt; bc81d2ba24e1
Step 6/7 : CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
 ---&amp;gt; Using cache
 ---&amp;gt; 44591f5b5a0c
Step 7/7 : EXPOSE 80
 ---&amp;gt; Using cache
 ---&amp;gt; 747275175211
Successfully built 747275175211

&lt;/code&gt;&lt;/pre&gt;
 &lt;br/&gt;
 이러한 도커빌드 원리를 이해하고 있으면 도커파일을 만들 때 효과적으로 만드실 수 있습니다.
 &lt;blockquote&gt;
  &lt;p&gt;
   참고로 명렁어를 주르륵 나열하기보단 최대한 간결하고 '&amp;amp;&amp;amp;' 명령어를 이용해 줄여서 적어주는것이 좋습니다! (스토리지 엔진에 따라 이미지 개수가 제한되는 경우도 있기때문)
  &lt;/p&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
  &lt;br/&gt;
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  ###빌드한 이미지는 각 서버에 어떻게 배포할까요?
 &lt;/p&gt;
 &lt;p&gt;
  도커는 이미지를 각각의 서버에 복사하는 방법 대신 저장소(Registry)를 이용합니다.
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/91695884/3.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  여기서 이미지를 저장소에 업로드할때 'puch' 명령어를 사용하고,
각 서버에서 저장소에 올려져있는 이미지를 가져올때 'pull'이라는 명령어를 사용합니다.
 &lt;/p&gt;
 &lt;br/&gt;
 저번시간에 tag에 대하여 스르륵 지나갔었는데
이미지 이야기를 하는김에 같이 다뤄보도록 하겠습니다.
 &lt;br/&gt;
 &lt;h4&gt;
  &lt;a href=&quot;#이미지-태그에-관하여&quot; id=&quot;이미지-태그에-관하여&quot;&gt;
   이미지 태그에 관하여
  &lt;/a&gt;
 &lt;/h4&gt;
 &lt;p&gt;
  'docker tag &amp;lt;옵션&amp;gt; &amp;lt;이미지 이름&amp;gt;:&amp;lt;태그&amp;gt; &amp;lt;저장소 주소, 사용자명&amp;gt;/&amp;lt;이미지이름&amp;gt;:&amp;lt;태그&amp;gt;'
굉장히 복잡해 보입니다...
 &lt;/p&gt;
 &lt;p&gt;
  저장소 주소는 기본적으로 Docker hub를 바라보고 있고, 사용자 ID를 지정해주지 않으면 기본으로 library를 사용합니다.
  &lt;br/&gt;
  즉,
'&amp;lt;저장소 주소, 사용자명&amp;gt;/&amp;lt;이미지이름&amp;gt;:&amp;lt;태그&amp;gt;'는
docker.io/library/nginx = library/nginx = nginx
이렇게 추릴수도 있습니다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;em&gt;
   이미지 이름 변경
  &lt;/em&gt;
 &lt;/p&gt;
 &lt;p&gt;
  'docker tag &amp;lt;reponame&amp;gt;:&amp;lt;old_name&amp;gt; &amp;lt;new_reponame&amp;gt;:&amp;lt;new_name&amp;gt;
-&amp;gt; 이름을 변경한다기 보다는 복제라고 보는게 더 맞습니다.
예시) 'docker tag mynginx:0.2 kbseonginx:0.1'
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;#before
[kbseo@ip-172-20-1-221 docker]$ docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
mynginx                      0.1                 747275175211        25 hours ago        231MB
mynginx                      0.2                 747275175211        25 hours ago        231MB

#after
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
kbseonginx                   0.1                 747275175211        25 hours ago        231MB
mynginx                      0.1                 747275175211        25 hours ago        231MB
mynginx                      0.2                 747275175211        25 hours ago        231MB
 

&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  이렇게 해서 이번 시간에는 Docker File과 Image에 대하여 알아보았는데요
 &lt;/p&gt;
 &lt;p&gt;
  다음번에는 실질적으로 사용하고 있는 application을 어떻게 Dockerized 할 것인가
 &lt;/p&gt;
 &lt;p&gt;
  라는 주제로 다시 찾아뵙도록 하겠습니다.
 &lt;/p&gt;
 &lt;p&gt;
  뿅!
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Mon, 23 Mar 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/03/23/91695884/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/03/23/91695884/</guid>
        
        <category>docker</category>
        
        <category>dockerbasic</category>
        
        <category>dockerfile</category>
        
        <category>dockerimage</category>
        
        <category>container</category>
        
        <category>도커</category>
        
        <category>컨테이너</category>
        
        <category>도커파일</category>
        
        <category>도커이미지</category>
        
        <category>dockercommand</category>
        
        
      </item>
    
      <item>
        <title>Kubernetes1.17 Hard Way using docker,flannel</title>
        <description>&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#kubernetes117-hard-way-libvirt-using-dockerflannel&quot; id=&quot;kubernetes117-hard-way-libvirt-using-dockerflannel&quot;&gt;
   Kubernetes1.17 Hard Way (Libvirt) using docker,flannel
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;p&gt;
  해당 문서는
  &lt;a href=&quot;https://github.com/alosadagrande/kubernetes-the-hard-way-libvirt-kvm/blob/master/docs/01-prerequisites.md&quot;&gt;
   https://github.com/alosadagrande/kubernetes-the-hard-way-libvirt-kvm/blob/master/docs/01-prerequisites.md
  &lt;/a&gt;
  ,
  &lt;a href=&quot;https://veerendra2.github.io/kubernetes-the-hard-way-3/&quot;&gt;
   https://veerendra2.github.io/kubernetes-the-hard-way-3/
  &lt;/a&gt;
  를 기반으로 테스트된 문서 입니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#prerequisites&quot; id=&quot;prerequisites&quot;&gt;
   Prerequisites
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;p&gt;
  호스트 서버에서 설정되어 있는 인스턴스는 아래와 같이 배포를 위한 서버기반으로 master 인스턴스3개와 worker 인스턴스 3개로 구성된다.
 &lt;/p&gt;
 &lt;p&gt;
  이중 master 인스턴스틑 worker의 역할과 같이 진행 할 수 있도록 한다.
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91695235/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  kubernetes  배포를 위한 인증서 및 kubeconfg 파일의 설정은 kube-hard-deploy 호스트에서 진행 된다.
 &lt;/p&gt;
 &lt;p&gt;
  master와 woker로 각 설정의 편의를 위하여 kube-hard-deploy  인스턴스에서 ansible로 진행 하도록 한다.
 &lt;/p&gt;
 &lt;p&gt;
  /opt/kubernetes 디렉토리를 생성하여 ansible inventory파일을 설정 한다. 해당 디렉토리에서 인증서 생성 및 kubeconfig 파일을 생성하는 작업을 진행 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ mkdir /opt/kubernetes
$ cd /opt/kubernetes/
$ yum install ansible -y
$ cat &amp;lt;&amp;lt;EOF | tee ansible.cfg
[defaults]
forks = 20
host_key_checking = false
deprecation_warnings = false
log_path=/var/log/ansible.log
EOF

$ cat &amp;lt;&amp;lt;EOF | tee hosts
[kube_master]
kube-hard-master001  ansible_host=10.15.10.21
kube-hard-master002  ansible_host=10.15.10.22
kube-hard-master003  ansible_host=10.15.10.23
 
[kube_worker]
kube-hard-worker001  ansible_host=10.15.10.31
kube-hard-worker002  ansible_host=10.15.10.32
kube-hard-worker003  ansible_host=10.15.10.33
 
[all:children]
kube_master
kube_worker

[all:vars]
ansible_user=centos
EOF
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  ping module을 이용하여 ansible 으로 ssh 통신이 되는지 확인 한다. 만약, 통신이 안될경우
  &lt;code&gt;
   ssh-copy-id
  &lt;/code&gt;
  명령을 이용하여 key를 복사 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ ansible -i /opt/kubernetes/hosts  -m ping  all
&lt;/code&gt;&lt;/pre&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#installing-the-client-tools&quot; id=&quot;installing-the-client-tools&quot;&gt;
   Installing the Client Tools
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;p&gt;
  완료하는 데 필요한 명령 줄 유틸리티 인
  &lt;code&gt;
   cfssl
  &lt;/code&gt;
  ,
  &lt;code&gt;
   cfssljson
  &lt;/code&gt;
  및
  &lt;code&gt;
   kubectl
  &lt;/code&gt;
  을 설치한다.
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#install-cfssl&quot; id=&quot;install-cfssl&quot;&gt;
   Install CFSSL
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  &lt;code&gt;
   cfssl
  &lt;/code&gt;
  및
  &lt;code&gt;
   cfssljson
  &lt;/code&gt;
  명령 줄 유틸리티는 PKI 인프라를 프로비저닝하고 TLS 인증서를 생성하는 데 사용된다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   cfssl
  &lt;/code&gt;
  및
  &lt;code&gt;
   cfssljson
  &lt;/code&gt;
  다운로드 및 설치:
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cd /opt/kubernetes/
$ yum install wget -y
$ wget -q --timestamping \
   https://storage.googleapis.com/kubernetes-the-hard-way/cfssl/linux/cfssl \
  https://storage.googleapis.com/kubernetes-the-hard-way/cfssl/linux/cfssljson
$ ls -al  cfssl*
-rw-r--r--. 1 root root 20574840 Sep 15  2019 cfssl
-rw-r--r--. 1 root root 12670032 Sep 15  2019 cfssljson
$ chmod +x cfssl*
$ sudo mv cfssl cfssljson /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#verification&quot; id=&quot;verification&quot;&gt;
   Verification
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  &lt;code&gt;
   cfssl
  &lt;/code&gt;
  및
  &lt;code&gt;
   cfssljson
  &lt;/code&gt;
  버전 1.3.4 이상이 설치되어 있는지 확인한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cfssl version
Version: 1.3.4
Revision: dev
Runtime: go1.13

$ cfssljson --version
Version: 1.3.4
Revision: dev
Runtime: go1.13
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#install-kubectl&quot; id=&quot;install-kubectl&quot;&gt;
   Install kubectl
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  &lt;code&gt;
   kubectl
  &lt;/code&gt;
  명령 줄 유틸리티는 Kubernetes API Server와 상호 작용하는 데 사용된다. 공식 릴리스 바이너리에서
  &lt;code&gt;
   kubectl
  &lt;/code&gt;
  을 다운로드하여 설치한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ wget https://storage.googleapis.com/kubernetes-release/release/v1.17.4/bin/linux/amd64/kubectl
$ chmod +x kubectl
$ sudo mv kubectl /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#verification-1&quot; id=&quot;verification-1&quot;&gt;
   Verification
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  kubectl 버전 1.17.4 이상이 설치 되어 있는지 확인한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ kubectl version --client
Client Version: version.Info{Major:&quot;1&quot;, Minor:&quot;17&quot;, GitVersion:&quot;v1.17.4&quot;, GitCommit:&quot;8d8aa39598534325ad77120c120a22b3a990b5ea&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2020-03-12T21:03:42Z&quot;, GoVersion:&quot;go1.13.8&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;}
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#load-balancer-service&quot; id=&quot;load-balancer-service&quot;&gt;
   Load balancer service
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  인스턴스에서 HAProxy를 사용하여 로드 밸런서 서비스를 설치하는 방법을 보여준다.
 &lt;/p&gt;
 &lt;p&gt;
  Install and configure HAProxy
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ sudo su -
$ yum install -y haproxy
$ tee /etc/haproxy/haproxy.cfg &amp;lt;&amp;lt; EOF
global
    log         127.0.0.1 local2
    chroot      /var/lib/haproxy
    pidfile     /var/run/haproxy.pid
    maxconn     4000
    user        haproxy
    group       haproxy
    daemon
    stats socket /var/lib/haproxy/stats

defaults
    log                     global
    option                  httplog
    option                  dontlognull
    option                  http-server-close
    option                  redispatch
    retries                 3
    timeout http-request    10s
    timeout queue           1m
    timeout connect         10s
    timeout client          1m
    timeout server          1m
    timeout http-keep-alive 10s
    timeout check           10s
    maxconn                 3000

listen stats :9000
    stats enable
    stats realm Haproxy\ Statistics
    stats uri /haproxy_stats
    stats auth admin:password
    stats refresh 30
    mode http

frontend  main *:6443
    default_backend mgmt6443
    option tcplog

backend mgmt6443
    balance source
    mode tcp
    # MASTERS 6443
    server kube-hard-master001 10.15.10.21:6443 check
    server kube-hard-master002 10.15.10.22:6443 check
    server kube-hard-master003 10.15.10.23:6443 check
EOF
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  Kubernetes 포트가 6443이므로 selinux 정책을 수정하여 haproxy가 해당 특정 포트에서 청취 할 수 있도록 해야 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ sudo semanage port --add --type http_port_t --proto tcp 6443
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  모든 것이 올바르게 구성 되었는지 확인한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ haproxy -c -V -f /etc/haproxy/haproxy.cfg
Configuration file is valid
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  구성이 확인되면 서비스를 실행 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ systemctl enable haproxy --now
Created symlink from /etc/systemd/system/multi-user.target.wants/haproxy.service to /usr/lib/systemd/system/haproxy.service.
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#provisioning-a-ca-and-generating-tls-certificates&quot; id=&quot;provisioning-a-ca-and-generating-tls-certificates&quot;&gt;
   Provisioning a CA and Generating TLS Certificates
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  CloudFlare의 PKI 툴킷 인 cfssl을 사용하여 PKI 인프라를 프로비저닝 한 다음이를 사용하여 인증 기관을 부트 스트랩하고 다음 구성 요소에 대한 TLS 인증서를 생성한다.
 &lt;/p&gt;
 &lt;p&gt;
  아래의 총 6개의 인증서를 생성 해야 한다.
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   API 서버에 클러스터 관리자(admin) 인증을 위한 클라이언트 인증서
  &lt;/li&gt;
  &lt;li&gt;
   API 서버에서 kubelet과 통신을 위한 클라이언트 인증서
  &lt;/li&gt;
  &lt;li&gt;
   컨트롤러 매니저와 API 서버 간의 통신을 위한 클라이언트 인증서/kubeconfig
  &lt;/li&gt;
  &lt;li&gt;
   kube-proxy를 위한 클라이언트 인증서
  &lt;/li&gt;
  &lt;li&gt;
   스케줄러와 API 서버간 통신을 위한 클라이언트 인증서/kubeconfig
  &lt;/li&gt;
  &lt;li&gt;
   API 서버 엔드포인트를 위한 서버 인증서
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#certificate-authority&quot; id=&quot;certificate-authority&quot;&gt;
   Certificate Authority
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  추가 TLS 인증서를 생성하는 데 사용할 수있는 인증 기관을 제공합니다. CA 구성 파일, 인증서 및 개인 키를 생성한다.
 &lt;/p&gt;
 &lt;p&gt;
  CloudFlare의 PKI 툴킷인 cfssl을 사용하여 PKI 인프라를 구축한 다음 이를 사용하여 CA(인증 기관)을 부트스트랩 한다.
 &lt;/p&gt;
 &lt;p&gt;
  C : ISO 국가 코드 KR, US, CN, JP (대문자)
ST : 시,도
L : 구,군
O : 기관명, 회사명
OU : 조직명
CN : 도메인명, 일반이름. IP 주소는 CN 으로 사용할수 없다
위 항목은 모두 영문입력을 해야 합니다. 특수문자를 사용하면 안된다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ 
{
cat &amp;gt; ca-config.json &amp;lt;&amp;lt;EOF
{
  &quot;signing&quot;: {
    &quot;default&quot;: {
      &quot;expiry&quot;: &quot;8760h&quot;
    },
    &quot;profiles&quot;: {
      &quot;kubernetes&quot;: {
        &quot;usages&quot;: [&quot;signing&quot;, &quot;key encipherment&quot;, &quot;server auth&quot;, &quot;client auth&quot;],
        &quot;expiry&quot;: &quot;8760h&quot;
      }
    }
  }
}
EOF

cat &amp;gt; ca-csr.json &amp;lt;&amp;lt;EOF
{
  &quot;CN&quot;: &quot;Kubernetes&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [
    {
      &quot;C&quot;: &quot;KR&quot;,
      &quot;L&quot;: &quot;Seoul&quot;,
      &quot;O&quot;: &quot;HARD&quot;,
      &quot;OU&quot;: &quot;CA&quot;,
      &quot;ST&quot;: &quot;Korea&quot;
    }
  ]
}
EOF

cfssl gencert -initca ca-csr.json | cfssljson -bare ca

}
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#client-and-server-certificates&quot; id=&quot;client-and-server-certificates&quot;&gt;
   Client and Server Certificates
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  각 Kubernetes 구성 요소에 대한 클라이언트 및 서버 인증서와 Kubernetes  admin에  대한 클라이언트 인증서를 생성한다.
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-admin-client-certificate&quot; id=&quot;the-admin-client-certificate&quot;&gt;
   The Admin Client Certificate
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  API 서버에 클러스터 admin 인증을 위한 클라이언트 인증서 및 개인 키를 생성
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$
{

cat &amp;gt; admin-csr.json &amp;lt;&amp;lt;EOF
{
  &quot;CN&quot;: &quot;admin&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [
    {
      &quot;C&quot;: &quot;KR&quot;,
      &quot;L&quot;: &quot;Seoul&quot;,
      &quot;O&quot;: &quot;system:masters&quot;,
      &quot;OU&quot;: &quot;Kubernetes The Hard Way&quot;,
      &quot;ST&quot;: &quot;Korea&quot;
    }
  ]
}
EOF

cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -profile=kubernetes \
  admin-csr.json | cfssljson -bare admin

}

$ ls -al admin.pem
-rw-r--r--. 1 root root 1407 Mar 21 08:41 admin.pem

$ ls -al admin-key.pem
-rw-------. 1 root root 1675 Mar 21 08:41 admin-key.pem
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-kubelet-client-certificates&quot; id=&quot;the-kubelet-client-certificates&quot;&gt;
   The Kubelet Client Certificates
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  Kubernetes는
  &lt;code&gt;
   Node Authorizer
  &lt;/code&gt;
  (
  &lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/node/&quot;&gt;
   https://kubernetes.io/docs/reference/access-authn-authz/node/
  &lt;/a&gt;
  )라는 특수 목적의 권한 부여 모드를 사용한다.
 &lt;/p&gt;
 &lt;p&gt;
  이 모드는 Kubelets의 API 요청을 구체적으로 승인한다. 노드 인증 자에 의해 권한을 부여하기 위해 Kubelets는 사용자 이름이
  &lt;code&gt;
   system:node :&amp;lt;nodeName&amp;gt;
  &lt;/code&gt;
  인
  &lt;code&gt;
   system :nodes
  &lt;/code&gt;
  그룹에 있는 것으로 식별하는 자격 증명을 사용해야 한다.  노드 권한 부 여자 요구 사항을 충족하는 각 Kubernetes 작업자 노드에 대한 인증서를 만든다.
 &lt;/p&gt;
 &lt;p&gt;
  각 Kubernetes 작업자 노드에 대한 인증서 및 개인 키를 생성한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ for instance in kube-hard-worker001 kube-hard-worker002 kube-hard-worker003  kube-hard-master003   kube-hard-master002  kube-hard-master001; do
cat &amp;gt; ${instance}-csr.json &amp;lt;&amp;lt;EOF
{
  &quot;CN&quot;: &quot;system:node:${instance}&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [
    {
      &quot;C&quot;: &quot;KR&quot;,
      &quot;L&quot;: &quot;Seoul&quot;,
      &quot;O&quot;: &quot;system:nodes&quot;,
      &quot;OU&quot;: &quot;Kubernetes The Hard Way&quot;,
      &quot;ST&quot;: &quot;Korea&quot;
    }
  ]
}
EOF

NODE_IP=$( cat /etc/hosts| grep ${instance} | awk '{print $1}')

cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -hostname=${instance},${instance},${NODE_IP} \
  -profile=kubernetes \
  ${instance}-csr.json | cfssljson -bare ${instance}
done

$ ls -al kube-hard-wor ker0*.pem
-rw-------. 1 root root 1679 Mar 21 08:42 kube-hard-worker001-key.pem
-rw-r--r--. 1 root root 1525 Mar 21 08:42 kube-hard-worker001.pem
-rw-------. 1 root root 1679 Mar 21 08:42 kube-hard-worker002-key.pem
-rw-r--r--. 1 root root 1525 Mar 21 08:42 kube-hard-worker002.pem
-rw-------. 1 root root 1679 Mar 21 08:42 kube-hard-worker003-key.pem
-rw-r--r--. 1 root root 1525 Mar 21 08:42 kube-hard-worker003.pem
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-controller-manager-client-certificate&quot; id=&quot;the-controller-manager-client-certificate&quot;&gt;
   The Controller Manager Client Certificate
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  kube-controller-manager 클라이언트 인증서 및 개인 키를 생성
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ {

cat &amp;gt; kube-controller-manager-csr.json &amp;lt;&amp;lt;EOF
{
  &quot;CN&quot;: &quot;system:kube-controller-manager&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [
    {
      &quot;C&quot;: &quot;KR&quot;,
      &quot;L&quot;: &quot;Seoul&quot;,
      &quot;O&quot;: &quot;system:kube-controller-manager&quot;,
      &quot;OU&quot;: &quot;Kubernetes The Hard Way&quot;,
      &quot;ST&quot;: &quot;Korea&quot;
    }
  ]
}
EOF

cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -profile=kubernetes \
  kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager

}

$ ls -al kube-controller-manage*.pem
-rw-------. 1 root root 1679 Mar 21 08:43 kube-controller-manager-key.pem
-rw-r--r--. 1 root root 1464 Mar 21 08:43 kube-controller-manager.pem
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-kube-proxy-client-certificate&quot; id=&quot;the-kube-proxy-client-certificate&quot;&gt;
   The Kube Proxy Client Certificate
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  kube-proxy 클라이언트 인증서 및 개인 키를 생성
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$
{

cat &amp;gt; kube-proxy-csr.json &amp;lt;&amp;lt;EOF
{
  &quot;CN&quot;: &quot;system:kube-proxy&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [
    {
      &quot;C&quot;: &quot;KR&quot;,
      &quot;L&quot;: &quot;Seoul&quot;,
      &quot;O&quot;: &quot;system:node-proxier&quot;,
      &quot;OU&quot;: &quot;Kubernetes The Hard Way&quot;,
      &quot;ST&quot;: &quot;Korea&quot;
    }
  ]
}
EOF

cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -profile=kubernetes \
  kube-proxy-csr.json | cfssljson -bare kube-proxy

}

$ ls -al kube-proxy*.pem
-rw-------. 1 root root 1679 Mar 21 08:43 kube-proxy-key.pem
-rw-r--r--. 1 root root 1432 Mar 21 08:43 kube-proxy.pem
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-scheduler-client-certificate&quot; id=&quot;the-scheduler-client-certificate&quot;&gt;
   The Scheduler Client Certificate
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  kube-scheduler 클라이언트 인증서 및 개인 키를 생성
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$
{

cat &amp;gt; kube-scheduler-csr.json &amp;lt;&amp;lt;EOF
{
  &quot;CN&quot;: &quot;system:kube-scheduler&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [
    {
      &quot;C&quot;: &quot;KR&quot;,
      &quot;L&quot;: &quot;Seoul&quot;,
      &quot;O&quot;: &quot;system:kube-scheduler&quot;,
      &quot;OU&quot;: &quot;Kubernetes The Hard Way&quot;,
      &quot;ST&quot;: &quot;Korea&quot;
    }
  ]
}
EOF

cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -profile=kubernetes \
  kube-scheduler-csr.json | cfssljson -bare kube-scheduler

}

$ ls -al kube-scheduler*.pem
-rw-------. 1 root root 1675 Mar 21 08:43 kube-scheduler-key.pem
-rw-r--r--. 1 root root 1440 Mar 21 08:43 kube-scheduler.pem
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-kubernetes-api-server-certificate&quot; id=&quot;the-kubernetes-api-server-certificate&quot;&gt;
   The Kubernetes API Server Certificate
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  &lt;code&gt;
   kubernetes-the-hard-way
  &lt;/code&gt;
  고정 IP 주소는 Kubernetes API Server 인증서의
  &lt;code&gt;
   hostname
  &lt;/code&gt;
  목록에 포함 된다. 이렇게 하면 원격 클라이언트가 인증서를 확인할 수 있다.
 &lt;/p&gt;
 &lt;p&gt;
  Kubernetes API Server 인증서 및 개인 키를 생성한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$
{

KUBERNETES_HOSTNAMES=kubernetes,kubernetes.default,kubernetes.default.svc,kubernetes.default.svc.cluster,kubernetes.svc.cluster.local

cat &amp;gt; kubernetes-csr.json &amp;lt;&amp;lt;EOF
{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [
    {
      &quot;C&quot;: &quot;KR&quot;,
      &quot;L&quot;: &quot;Seoul&quot;,
      &quot;O&quot;: &quot;Kubernetes&quot;,
      &quot;OU&quot;: &quot;Kubernetes The Hard Way&quot;,
      &quot;ST&quot;: &quot;Korea&quot;
    }
  ]
}
EOF

cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -hostname=10.32.0.1,10.15.10.2,10.15.10.21,10.15.10.22,10.15.10.23,${KUBERNETES_BAREMETAL_ADDRESS},127.0.0.1,${KUBERNETES_HOSTNAMES} \
  -profile=kubernetes \
  kubernetes-csr.json | cfssljson -bare kubernetes

}


$ ls -al kubernetes*.pem
-rw-------. 1 root root 1675 Mar 21 08:44 kubernetes-key.pem
-rw-r--r--. 1 root root 1647 Mar 21 08:44 kubernetes.pem
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  Kubernetes API 서버에는 kubernetes 내부 dns 이름이 자동으로 할당되며, 이는 컨트롤 플레인 부트 스트랩 실험실에서 내부 클러스터 서비스 용으로 예약 된 주소 범위 (10.32.0.0/24)에서 첫 번째 IP 주소 (10.32.0.1)에 연결된다.
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-service-account-key-pair&quot; id=&quot;the-service-account-key-pair&quot;&gt;
   The Service Account Key Pair
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  Kubernetes Controller Manager는 키 페어를 사용하여 서비스 계정 관리 문서(
  &lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/&quot;&gt;
   https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/
  &lt;/a&gt;
  ) 에 설명 된대로 서비스 계정 토큰을 생성하고 서명한다.
 &lt;/p&gt;
 &lt;p&gt;
  service-account 인증서 및 개인 키를 생성
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$
{

cat &amp;gt; service-account-csr.json &amp;lt;&amp;lt;EOF
{
  &quot;CN&quot;: &quot;service-accounts&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [
    {
      &quot;C&quot;: &quot;KR&quot;,
      &quot;L&quot;: &quot;Seoul&quot;,
      &quot;O&quot;: &quot;Kubernetes&quot;,
      &quot;OU&quot;: &quot;Kubernetes The Hard Way&quot;,
      &quot;ST&quot;: &quot;Korea&quot;
    }
  ]
}
EOF

cfssl gencert \
  -ca=ca.pem \
  -ca-key=ca-key.pem \
  -config=ca-config.json \
  -profile=kubernetes \
  service-account-csr.json | cfssljson -bare service-account

}

$ ls -al service-account*.pem
-rw-------. 1 root root 1675 Mar 21 08:44 service-account-key.pem
-rw-r--r--. 1 root root 1419 Mar 21 08:44 service-account.pem
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#distribute-the-client-and-server-certificates&quot; id=&quot;distribute-the-client-and-server-certificates&quot;&gt;
   Distribute the Client and Server Certificates
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  적절한 인증서와 개인 키를 각 Worker 인스턴스에 복사한다. (kube-proxy, kube-controller-manager, kube-scheduler 및 kubelet 클라이언트 인증서는  클라이언트 인증 구성 파일을 생성하는 데 사용)
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ for node in kube-hard-worker001 kube-hard-worker002 kube-hard-worker003  kube-hard-master002  kube-hard-master001 kube-hard-master003; do
  	for key in ca.pem ${node}-key.pem ${node}.pem kube-proxy-key.pem kube-proxy.pem; do
	    	 scp ${key} centos@${node}:~ 
	  done
  done
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  적절한 인증서 및 개인 키를 각 Controller 인스턴스에 복사한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$  for node in kube-hard-master001 kube-hard-master003 kube-hard-master002; do 
  	for key in ca.pem ca-key.pem kubernetes-key.pem kubernetes.pem service-account-key.pem service-account.pem; do 
		 scp ${key} centos@${node}:~ 
        done 
  done
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#generating-kubernetes-configuration-files-for-authentication&quot; id=&quot;generating-kubernetes-configuration-files-for-authentication&quot;&gt;
   Generating Kubernetes Configuration Files for Authentication
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  이 실습에서는 Kubernetes configuration files (
  &lt;a href=&quot;https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/&quot;&gt;
   https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/
  &lt;/a&gt;
  ) 라고도하는 Kubernetes 구성 파일을 생성하여 Kubernetes 클라이언트가 Kubernetes API 서버를 찾고 인증 할 수 있도록 한다.
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#client-authentication-configs&quot; id=&quot;client-authentication-configs&quot;&gt;
   Client Authentication Configs
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  &lt;code&gt;
   controller manager
  &lt;/code&gt;
  ,
  &lt;code&gt;
   kubelet
  &lt;/code&gt;
  ,
  &lt;code&gt;
   kube-proxy
  &lt;/code&gt;
  및
  &lt;code&gt;
   scheduler
  &lt;/code&gt;
  클라이언트 및
  &lt;code&gt;
   admin
  &lt;/code&gt;
  을 위한 kubeconfig 파일을 생성한다.
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#kubernetes-public-ip-address&quot; id=&quot;kubernetes-public-ip-address&quot;&gt;
   Kubernetes Public IP Address
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  각 kubeconfig에는 Kubernetes API 서버가 연결되어 있어야 한다. 고 가용성을 지원하기 위해 Kubernetes API 서버 앞에있는로드 밸런서에 할당 된 IP 주소가 사용된다. 로드 밸런서 고정 IP 주소를 검색 한다.
  &lt;code&gt;
   KUBERNETES_PUBLIC_ADDRESS
  &lt;/code&gt;
  는 로드 밸런서 IP 주소로  Kubernetes 클러스터 내부의 모든 인스턴스와 베어 메탈 자체에서 오는 모든 API 요청의 시작점 이라고 할수 있다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ KUBERNETES_PUBLIC_ADDRESS=10.15.10.2
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-kubelet-kubernetes-configuration-file&quot; id=&quot;the-kubelet-kubernetes-configuration-file&quot;&gt;
   The kubelet Kubernetes Configuration File
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  Kubelets에 대한 kubeconfig 파일을 생성 할 때 Kubelet의 노드 이름과 일치하는 클라이언트 인증서를 사용해야 한다. 이를 통해 Kuberlet이 Kubernetes Node Authorizer(
  &lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/node/&quot;&gt;
   https://kubernetes.io/docs/reference/access-authn-authz/node/
  &lt;/a&gt;
  )에 의해 올바르게 인증된다. ( SSL 인증서를 생성하는 데 사용 된 동일한 디렉토리에서 다음 명령을 실행해야 한다.)
 &lt;/p&gt;
 &lt;p&gt;
  각 작업자 노드에 대한 kubeconfig 파일을 생성한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ for instance in kube-hard-worker001 kube-hard-worker002 kube-hard-worker003  kube-hard-master002  kube-hard-master001 kube-hard-master003 ; do
  kubectl config set-cluster kubernetes-the-hard-way \
    --certificate-authority=ca.pem \
    --embed-certs=true \
    --server=https://${KUBERNETES_PUBLIC_ADDRESS}:6443 \
    --kubeconfig=${instance}.kubeconfig

  kubectl config set-credentials system:node:${instance}.${DOMAIN} \
    --client-certificate=${instance}.pem \
    --client-key=${instance}-key.pem \
    --embed-certs=true \
    --kubeconfig=${instance}.kubeconfig

  kubectl config set-context default \
    --cluster=kubernetes-the-hard-way \
    --user=system:node:${instance}.${DOMAIN} \
    --kubeconfig=${instance}.kubeconfig

  kubectl config use-context default --kubeconfig=${instance}.kubeconfig
done

$ ls -al kube-hard-worker*.kubeconfig
-rw-------. 1 root root 6412 Mar 21 08:45 kube-hard-worker001.kubeconfig
-rw-------. 1 root root 6412 Mar 21 08:45 kube-hard-worker002.kubeconfig
-rw-------. 1 root root 6412 Mar 21 08:45 kube-hard-worker003.kubeconfig
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-kube-proxy-kubernetes-configuration-file&quot; id=&quot;the-kube-proxy-kubernetes-configuration-file&quot;&gt;
   The kube-proxy Kubernetes Configuration File
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  kube-proxy 서비스에 대한 kubeconfig 파일을 생성 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ 
{
KUBERNETES_PUBLIC_ADDRESS=10.15.10.2

  kubectl config set-cluster kubernetes-the-hard-way \
    --certificate-authority=ca.pem \
    --embed-certs=true \
    --server=https://${KUBERNETES_PUBLIC_ADDRESS}:6443 \
    --kubeconfig=kube-proxy.kubeconfig

  kubectl config set-credentials system:kube-proxy \
    --client-certificate=kube-proxy.pem \
    --client-key=kube-proxy-key.pem \
    --embed-certs=true \
    --kubeconfig=kube-proxy.kubeconfig

  kubectl config set-context default \
    --cluster=kubernetes-the-hard-way \
    --user=system:kube-proxy \
    --kubeconfig=kube-proxy.kubeconfig

  kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig
}

$ ls -al kube-proxy.kubeconfig
-rw-------. 1 root root 6258 Mar 21 08:46 kube-proxy.kubeconfig
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-kube-controller-manager-kubernetes-configuration-file&quot; id=&quot;the-kube-controller-manager-kubernetes-configuration-file&quot;&gt;
   The kube-controller-manager Kubernetes Configuration File
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  kube-controller-manager 서비스를위한 kubeconfig 파일을 생성
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$
{
  kubectl config set-cluster kubernetes-the-hard-way \
    --certificate-authority=ca.pem \
    --embed-certs=true \
    --server=https://127.0.0.1:6443 \
    --kubeconfig=kube-controller-manager.kubeconfig

  kubectl config set-credentials system:kube-controller-manager \
    --client-certificate=kube-controller-manager.pem \
    --client-key=kube-controller-manager-key.pem \
    --embed-certs=true \
    --kubeconfig=kube-controller-manager.kubeconfig

  kubectl config set-context default \
    --cluster=kubernetes-the-hard-way \
    --user=system:kube-controller-manager \
    --kubeconfig=kube-controller-manager.kubeconfig

  kubectl config use-context default --kubeconfig=kube-controller-manager.kubeconfig
}

$ ls -al kube-controller-manager.kubeconfig
-rw-------. 1 root root 6323 Mar 21 08:46 kube-controller-manager.kubeconfig
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-kube-scheduler-kubernetes-configuration-file&quot; id=&quot;the-kube-scheduler-kubernetes-configuration-file&quot;&gt;
   The kube-scheduler Kubernetes Configuration File
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  kube-scheduler 서비스에 대한 kubeconfig 파일을 생성
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$
{
  kubectl config set-cluster kubernetes-the-hard-way \
    --certificate-authority=ca.pem \
    --embed-certs=true \
    --server=https://127.0.0.1:6443 \
    --kubeconfig=kube-scheduler.kubeconfig

  kubectl config set-credentials system:kube-scheduler \
    --client-certificate=kube-scheduler.pem \
    --client-key=kube-scheduler-key.pem \
    --embed-certs=true \
    --kubeconfig=kube-scheduler.kubeconfig

  kubectl config set-context default \
    --cluster=kubernetes-the-hard-way \
    --user=system:kube-scheduler \
    --kubeconfig=kube-scheduler.kubeconfig

  kubectl config use-context default --kubeconfig=kube-scheduler.kubeconfig
}


$ ls -al kube-scheduler.kubeconfig
-rw-------. 1 root root 6269 Mar 21 08:46 kube-scheduler.kubeconfig
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-admin-kubernetes-configuration-file&quot; id=&quot;the-admin-kubernetes-configuration-file&quot;&gt;
   The admin Kubernetes Configuration File
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  관리자를위한 kubeconfig 파일을 생성
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ {
  kubectl config set-cluster kubernetes-the-hard-way \
    --certificate-authority=ca.pem \
    --embed-certs=true \
    --server=https://127.0.0.1:6443 \
    --kubeconfig=admin.kubeconfig

  kubectl config set-credentials admin \
    --client-certificate=admin.pem \
    --client-key=admin-key.pem \
    --embed-certs=true \
    --kubeconfig=admin.kubeconfig

  kubectl config set-context default \
    --cluster=kubernetes-the-hard-way \
    --user=admin \
    --kubeconfig=admin.kubeconfig

  kubectl config use-context default --kubeconfig=admin.kubeconfig
}

$ ls -al admin.kubeconfig
-rw-------. 1 root root 6193 Mar 21 08:46 admin.kubeconfig
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#distribute-the-kubernetes-configuration-files&quot; id=&quot;distribute-the-kubernetes-configuration-files&quot;&gt;
   Distribute the Kubernetes Configuration Files
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  적절한 kubelet 및 kube-proxy kubeconfig 파일을 각 Woker 인스턴스에 복사
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ for node in kube-hard-worker001 kube-hard-worker002 kube-hard-worker003 
do 
	 scp ${node}.kubeconfig centos@${node}:~
	 scp kube-proxy.kubeconfig centos@${node}:~
done
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  적절한 kube-controller-manager 및 kube-scheduler kubeconfig 파일을 각 Controller 인스턴스에 복사
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ for node in kube-hard-master001 kube-hard-master002 kube-hard-master003 kube-hard-master002  kube-hard-master001 kube-hard-master003
 do
	 for kubeconfig in admin.kubeconfig kube-controller-manager.kubeconfig kube-scheduler.kubeconfig; do 
		 scp ${kubeconfig} centos@${node}:~
 	done 
done
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#generating-the-data-encryption-config-and-key&quot; id=&quot;generating-the-data-encryption-config-and-key&quot;&gt;
   Generating the Data Encryption Config and Key
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  Kubernetes는 클러스터 상태, 응용 프로그램 구성 및 Secret을 포함한 다양한 데이터를 저정한다. Kubernetes는 유휴 클러스터 데이터를 암호화하는 기능을 지원한다.(
  &lt;a href=&quot;https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/&quot;&gt;
   https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/
  &lt;/a&gt;
  )
 &lt;/p&gt;
 &lt;p&gt;
  Kubernetes Secrets 암호화에 적합한 암호화 키 및 암호화 구성을 생성합니다.(
  &lt;a href=&quot;https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/#understanding-the-encryption-at-rest-configuration&quot;&gt;
   https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/#understanding-the-encryption-at-rest-configuration
  &lt;/a&gt;
  )
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-encryption-key&quot; id=&quot;the-encryption-key&quot;&gt;
   The Encryption Key
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  암호화 키를 생성
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ ENCRYPTION_KEY=$(head -c 32 /dev/urandom | base64)
$ echo $ENCRYPTION_KEY
HRF0fAkpGSP762AFx9v0ugveE/v2ikl9Z4AdrLo6/rc=
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-encryption-config-file&quot; id=&quot;the-encryption-config-file&quot;&gt;
   The Encryption Config File
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  encryption-config.yaml 암호화 구성 파일을 작성
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cat &amp;gt; encryption-config.yaml &amp;lt;&amp;lt;EOF
kind: EncryptionConfig
apiVersion: v1
resources:
  - resources:
      - secrets
    providers:
      - aescbc:
          keys:
            - name: key1
              secret: ${ENCRYPTION_KEY}
      - identity: {}
EOF
$ ls -al encryption-config.yaml
-rw-r--r--. 1 root root 240 Mar 21 08:47 encryption-config.yaml
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  encryption-config.yaml 암호화 구성 파일을 각 Controller 인스턴스에 복사
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ for node in kube-hard-master001 kube-hard-master002 kube-hard-master003; do 
	 scp encryption-config.yaml centos@$node:~
  done
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#bootstrapping-the-etcd-cluster&quot; id=&quot;bootstrapping-the-etcd-cluster&quot;&gt;
   Bootstrapping the etcd Cluster
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  Kubernetes 구성 요소는 상태 비 저장이며 클러스터 상태를 etcd(
  &lt;a href=&quot;https://github.com/etcd-io/etcd&quot;&gt;
   https://github.com/etcd-io/etcd
  &lt;/a&gt;
  ) 에 저장한다. etcd는 분산 시스템 또는 시스템 클러스터에서 액세스해야하는 데이터를 안정적으로 저장할 수있는 강력하고 일관된 분산 키-값 저장소 이다. 3 개의 노드 클러스터를 부트 스트랩 하고 고 가용성 및 안전한 원격 액세스를 위해 구성힌다.
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#time-synchronization&quot; id=&quot;time-synchronization&quot;&gt;
   Time synchronization
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  분산 시스템은 구성 요소가 동기화되어 있어야 한다. 그렇기 때문에 인프라의 모든 VM을 따라 시간 동기화를 구성하는 것이 좋다. 이를 위해 CentOS에서 패키지로 제공되는 Ansible 및system roles을 활용할 것이다.
 &lt;/p&gt;
 &lt;p&gt;
  먼저  system-role을 설치 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ yum install rhel-system-roles.noarch  -y 
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  시간 동기화를 위한 playbook을 작성 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cat &amp;gt; timesync.yml &amp;lt;&amp;lt;EOF

- hosts: all
  become: yes
  vars:
    timesync_ntp_provider: chrony
    timesync_ntp_servers:
      - hostname: pool.ntp.org
        iburst: yes
  roles:
  - rhel-system-roles.timesync

EOF

$ ansible-playbook -i hosts timesync.yml
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  Ansible ad-hoc 을 이용하여 시간동기화가 제대로 되었는지 확인 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ ansible -i hosts  all -a &quot;date&quot;
kube-hard-master001 | CHANGED | rc=0 &amp;gt;&amp;gt;
Sat Mar 21 17:50:28 KST 2020
kube-hard-master003 | CHANGED | rc=0 &amp;gt;&amp;gt;
Sat Mar 21 17:50:16 KST 2020
kube-hard-worker001 | CHANGED | rc=0 &amp;gt;&amp;gt;
Sat Mar 21 17:50:15 KST 2020
kube-hard-worker003 | CHANGED | rc=0 &amp;gt;&amp;gt;
Sat Mar 21 17:49:59 KST 2020
kube-hard-worker002 | CHANGED | rc=0 &amp;gt;&amp;gt;
Sat Mar 21 17:50:02 KST 2020
kube-hard-master002 | CHANGED | rc=0 &amp;gt;&amp;gt;
Sat Mar 21 17:50:11 KST 2020
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#bootstrapping-an-etcd-cluster-member&quot; id=&quot;bootstrapping-an-etcd-cluster-member&quot;&gt;
   Bootstrapping an etcd Cluster Member
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  모든 master노드에서 사용할 etcd 바이너리 파일을 다운로드하며, etcd에 관련된 바이너리를 각 마스터 노드의 /usr/local/bin/ 로 이동한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ wget  https://github.com/etcd-io/etcd/releases/download/v3.4.5/etcd-v3.4.5-linux-amd64.tar.gz
$ tar zxvf etcd-v3.4.5-linux-amd64.tar.gz  '*/etcd' '*/etcdctl' --transform 's,.*/\+\([^/]*\)$,\1,'
$ for file in etcd etcdctl; do ansible -i hosts kube_master -m copy -ba &quot;src=$file dest=/usr/local/bin/ owner=root group=root mode=0755&quot;; done
$ for dir in /etc/etcd /var/lib/etcd; do ansible -i hosts kube-master -m file -ba &quot;path=$dir state=directory&quot;; done
$ for file in ca.pem kubernetes-key.pem kubernetes.pem
  do
    ansible -i hosts kube_master -m copy -ba &quot;src=$file dest=/etc/etcd/ owner=root group=root mode=0600&quot;
  done
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  etcd.service 파일을 각 마스터 노드에 생성 하고 etcd서비스를 실행 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF | tee etcd.service.j2
[Unit]
Description=etcd
Documentation=https://github.com/coreos
 
[Service]
ExecStart=/usr/local/bin/etcd \\
  --name  \\
  --cert-file=/etc/etcd/kubernetes.pem \\
  --key-file=/etc/etcd/kubernetes-key.pem \\
  --peer-cert-file=/etc/etcd/kubernetes.pem \\
  --peer-key-file=/etc/etcd/kubernetes-key.pem \\
  --trusted-ca-file=/etc/etcd/ca.pem \\
  --peer-trusted-ca-file=/etc/etcd/ca.pem \\
  --peer-client-cert-auth \\
  --client-cert-auth \\
  --initial-advertise-peer-urls https://:2380 \\
  --listen-peer-urls https://:2380 \\
  --listen-client-urls https://:2379,https://127.0.0.1:2379 \\
  --advertise-client-urls https://:2379 \\
  --initial-cluster-token etcd-cluster-0 \\
  --initial-cluster  \\
  --initial-cluster-state new \\
  --data-dir=/var/lib/etcd
Restart=on-failure
RestartSec=5
 
[Install]
WantedBy=multi-user.target
EOF
 
ansible -i hosts kube_master -m template -ba 'src=etcd.service.j2 dest=/etc/systemd/system/etcd.service owner=root group=root mode=0644'
ansible -i hosts kube_master -m systemd -ba 'name=etcd state=started daemon_reload=yes enabled=yes'
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  제대로 맴버가 join되었는지 etcdctl 명령을 이용해서 확인 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ sudo ETCDCTL_API=3 ./etcdctl member list \
  --endpoints=https://10.15.10.21:2379 \
  --cacert=ca.pem \
  --cert=kubernetes.pem \
  --key=kubernetes-key.pem
2b127dde7e17ea5d, started, kube-hard-master001, https://10.15.10.21:2380, https://10.15.10.21:2379, false
3472b03aa4a9e736, started, kube-hard-master003, https://10.15.10.23:2380, https://10.15.10.23:2379, false
cfbb4a598b8eb8bc, started, kube-hard-master002, https://10.15.10.22:2380, https://10.15.10.22:2379, false
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#bootstrapping-the-kubernetes-control-plane&quot; id=&quot;bootstrapping-the-kubernetes-control-plane&quot;&gt;
   Bootstrapping the Kubernetes Control Plane
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  3 개의 컴퓨팅 인스턴스에서 Kubernetes Controller 노드를 을 Bootstrap하고 고 가용성을 위해 구성한다. Kubernetes API 서버를 원격 클라이언트에 노출시키는 이미 프로비저닝 된 로드 밸런서를 사용한다.
  &lt;code&gt;
   Kubernetes API ,
  &lt;/code&gt;
  &lt;code&gt;
   Scheduler
  &lt;/code&gt;
  및
  &lt;code&gt;
   Controller Manager
  &lt;/code&gt;
  와 같은 구성 요소가 각 마스터 또는 컨트롤러에 설치 된다
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#prerequisites&quot; id=&quot;prerequisites&quot;&gt;
   Prerequisites
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  모든 마스터 노드에 SELinux를 해제 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ ansible -i hosts kube_master -m selinux -ba &quot;state=disabled&quot;
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#download-and-install-the-kubernetes-controller-binaries&quot; id=&quot;download-and-install-the-kubernetes-controller-binaries&quot;&gt;
   Download and Install the Kubernetes Controller Binaries
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  공식 Kubernetes 릴리스 바이너리를 다운로드 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ wget \
  &quot;https://storage.googleapis.com/kubernetes-release/release/v1.17.4/bin/linux/amd64/kube-apiserver&quot; \
  &quot;https://storage.googleapis.com/kubernetes-release/release/v1.17.4/bin/linux/amd64/kube-controller-manager&quot; \
  &quot;https://storage.googleapis.com/kubernetes-release/release/v1.17.4/bin/linux/amd64/kube-scheduler&quot; \
  &quot;https://storage.googleapis.com/kubernetes-release/release/v1.17.4/bin/linux/amd64/kubectl&quot;
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  각 마스터 노드에  다운로드 받은 바이너리와 생성한 인증서를 복사한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ ansible -i hosts kube_master -m file -ba 'path=/etc/kubernetes/config state=directory'
$ for file in kube-apiserver kube-controller-manager kube-scheduler kubectl
  do
    ansible -i hosts kube_master -m copy -ba &quot;src=$file dest=/usr/local/bin/ owner=root group=root mode=0755&quot;
  done
$ for file in encryption-config.yaml ca.pem ca-key.pem kubernetes-key.pem kubernetes.pem service-account-key.pem service-account.pem
  do
    ansible -i hosts kube_master  -m copy -ba &quot;src=$file dest=/var/lib/kubernetes/ owner=root group=root mode=0600&quot;
  done
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  kube-apiserver.service 시스템 Unit 파일을 작성하고 마스터 노드에 복사 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF | sudo tee kube-apiserver.service.j2
[Unit]
Description=Kubernetes API Server
Documentation=https://github.com/kubernetes/kubernetes

[Service]
ExecStart=/usr/local/bin/kube-apiserver \\
  --advertise-address= \\
  --allow-privileged=true \\
  --apiserver-count=3 \\
  --audit-log-maxage=30 \\
  --audit-log-maxbackup=3 \\
  --audit-log-maxsize=100 \\
  --audit-log-path=/var/log/audit.log \\
  --authorization-mode=Node,RBAC \\
  --bind-address=0.0.0.0 \\
  --client-ca-file=/var/lib/kubernetes/ca.pem \\
  --enable-admission-plugins=NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \\
  --etcd-cafile=/var/lib/kubernetes/ca.pem \\
  --etcd-certfile=/var/lib/kubernetes/kubernetes.pem \\
  --etcd-keyfile=/var/lib/kubernetes/kubernetes-key.pem \\
  --etcd-servers= \\
  --event-ttl=1h \\
  --encryption-provider-config=/var/lib/kubernetes/encryption-config.yaml \\
  --kubelet-certificate-authority=/var/lib/kubernetes/ca.pem \\
  --kubelet-client-certificate=/var/lib/kubernetes/kubernetes.pem \\
  --kubelet-client-key=/var/lib/kubernetes/kubernetes-key.pem \\
  --kubelet-https=true \\
  --service-account-key-file=/var/lib/kubernetes/service-account.pem \\
  --service-cluster-ip-range=10.32.0.0/24 \\
  --service-node-port-range=30000-32767 \\
  --tls-cert-file=/var/lib/kubernetes/kubernetes.pem \\
  --tls-private-key-file=/var/lib/kubernetes/kubernetes-key.pem \\
  --v=2
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

$ ansible -i hosts kube_master -m template -ba 'src=kube-apiserver.service.j2 dest=/etc/systemd/system/kube-apiserver.service owner=root group=root mode=0644'
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;code&gt;
   service-cluster-ip-range
  &lt;/code&gt;
  설정은 서비스 Kubernetes 객체가 수신하는 서비스 네트워크에 할당 된 네트워크 범위를 나타낸다 . 이 네트워크는 내부 Kubernetes 네트워크이다.
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#configure-the-kubernetes-controller-manager&quot; id=&quot;configure-the-kubernetes-controller-manager&quot;&gt;
   Configure the Kubernetes Controller Manager
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  &lt;code&gt;
   kube-controller-manager.service
  &lt;/code&gt;
  시스템 Unit  파일을 만들고 마스터 노드로 복사 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF | sudo tee kube-controller-manager.service
[Unit]
Description=Kubernetes Controller Manager
Documentation=https://github.com/kubernetes/kubernetes

[Service]
ExecStart=/usr/local/bin/kube-controller-manager \\
  --address=0.0.0.0 \\
  --allocate-node-cidrs=true \\
  --cluster-cidr=10.200.0.0/16 \\
  --cluster-name=kubernetes \\
  --cluster-signing-cert-file=/var/lib/kubernetes/ca.pem \\
  --cluster-signing-key-file=/var/lib/kubernetes/ca-key.pem \\
  --kubeconfig=/var/lib/kubernetes/kube-controller-manager.kubeconfig \\
  --leader-elect=true \\
  --root-ca-file=/var/lib/kubernetes/ca.pem \\
  --service-account-private-key-file=/var/lib/kubernetes/service-account-key.pem \\
  --service-cluster-ip-range=10.32.0.0/24 \\
  --use-service-account-credentials=true \\
  --v=2
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

$ ansible -i hosts kube_master -m copy -ba 'src=kube-controller-manager.service dest=/etc/systemd/system/ owner=root group=root mode=0644'
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;code&gt;
   cluster-cidr
  &lt;/code&gt;
  은 포드가 실행되는 클러스터의 모든 노드에 할당 된 네트워크 범위이다. 실제로 각 노드에는 이 네트워크의 일부가 할당된다. 이 네트워크는 내부 Kubernetes 네트워크이다.
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#configure-the-kubernetes-scheduler&quot; id=&quot;configure-the-kubernetes-scheduler&quot;&gt;
   Configure the Kubernetes Scheduler
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  &lt;code&gt;
   kube-scheduler.yaml
  &lt;/code&gt;
  설정 파일을 생성 하고 마스터 노드로 복사 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF | sudo tee kube-scheduler.yaml
apiVersion: kubescheduler.config.k8s.io/v1alpha1
kind: KubeSchedulerConfiguration
clientConnection:
  kubeconfig: &quot;/var/lib/kubernetes/kube-scheduler.kubeconfig&quot;
leaderElection:
  leaderElect: true
EOF

$ ansible -i  hosts kube_master -m copy -ba 'src=kube-scheduler.yaml dest=/etc/kubernetes/config/ owner=root group=root mode=0644'
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;code&gt;
   kube-scheduler.service
  &lt;/code&gt;
  시스템 Unit 파일을 생성 하고 마스터 노드로 복사 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF | sudo tee kube-scheduler.service
[Unit]
Description=Kubernetes Scheduler
Documentation=https://github.com/kubernetes/kubernetes

[Service]
ExecStart=/usr/local/bin/kube-scheduler \\
  --config=/etc/kubernetes/config/kube-scheduler.yaml \\
  --v=2
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

$ ansible -i  hosts kube_master -m copy -ba 'src=kube-scheduler.service dest=/etc/systemd/system/ owner=root group=root mode=0644'
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  kube-controller-manager kube-scheduler 의 kubeconfig  파일을 복사 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ for file in kube-controller-manager kube-scheduler
do
ansible -i  hosts kube_master  -m copy -ba &quot;src=${file}.kubeconfig dest=/var/lib/kubernetes/ owner=root group=root mode=0644&quot;
done
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#start-the-controller-services&quot; id=&quot;start-the-controller-services&quot;&gt;
   Start the Controller Services
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  설정한 데몬을 실행 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ for service in kube-apiserver kube-controller-manager kube-scheduler
do
ansible -i hosts kube_master -m systemd -ba &quot;name=$service state=started daemon-reload=yes enabled=yes&quot;
done
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#rbac-for-kubelet-authorization&quot; id=&quot;rbac-for-kubelet-authorization&quot;&gt;
   RBAC for Kubelet Authorization
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  Kubernetes API 서버가 각 작업자 노드의 Kubelet API에 액세스 할 수 있도록 RBAC 권한을 구성한다. 포드에서 메트릭, 로그 및 명령을 검색하려면 Kubelet API에 액세스해야 한다.
 &lt;/p&gt;
 &lt;p&gt;
  Kubelet --authorization-mode 플래그를 Webhook로 설정한다. 웹 후크 모드는 SubjectAccessReview API를 사용하여 권한을 결정한다.(
  &lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/authorization/#checking-api-access&quot;&gt;
   https://kubernetes.io/docs/reference/access-authn-authz/authorization/#checking-api-access
  &lt;/a&gt;
  )
 &lt;/p&gt;
 &lt;p&gt;
  Kubelet API에 액세스 할 수있는 권한으로
  &lt;code&gt;
   system:kube-apiserver-to-kubelet
  &lt;/code&gt;
  ClusterRole(
  &lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole&quot;&gt;
   https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole
  &lt;/a&gt;
  )을 만들고 포드 관리와 관련된 가장 일반적인 작업을 수행한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF | kubectl apply --kubeconfig admin.kubeconfig -f -
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: system:kube-apiserver-to-kubelet
rules:
  - apiGroups:
      - &quot;&quot;
    resources:
      - nodes/proxy
      - nodes/stats
      - nodes/log
      - nodes/spec
      - nodes/metrics
    verbs:
      - &quot;*&quot;
EOF
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  Kubernetes API 서버는
  &lt;code&gt;
   --kubelet-client-certificate
  &lt;/code&gt;
  플래그로 정의 된 클라이언트 인증서를 사용하여 kubernetes 사용자로 Kubelet에 Kubelet을 인증한다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   system:kube-apiserver-to-kubelet
  &lt;/code&gt;
  를 ClusterRole kubernetes유저로 바인딩 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF | kubectl apply --kubeconfig admin.kubeconfig -f -
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: system:kube-apiserver
  namespace: &quot;&quot;
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:kube-apiserver-to-kubelet
subjects:
  - apiGroup: rbac.authorization.k8s.io
    kind: User
    name: kubernetes
EOF
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#verification-2&quot; id=&quot;verification-2&quot;&gt;
   Verification
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  마지막으로 서비스가 성공적으로 실행되고 있으며 정상 상태인지 확인한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ kubectl get componentstatuses --kubeconfig admin.kubeconfig -o yaml | egrep &quot;kind|name|message&quot;

# Output&amp;gt;&amp;gt;
- message: ok
  kind: ComponentStatus
    name: controller-manager
  - message: ok
  kind: ComponentStatus
    name: scheduler
  - message: '{&quot;health&quot;:&quot;true&quot;}'
  kind: ComponentStatus
    name: etcd-1
  - message: '{&quot;health&quot;:&quot;true&quot;}'
  kind: ComponentStatus
    name: etcd-2
  - message: '{&quot;health&quot;:&quot;true&quot;}'
  kind: ComponentStatus
    name: etcd-0
kind: List
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  베어 메탈 노드에서 로드 밸런서가 올바르게 구성되었는지 확인한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ KUBERNETES_PUBLIC_ADDRESS=10.15.10.2
$ curl --cacert ca.pem https://${KUBERNETES_PUBLIC_ADDRESS}:6443/version

curl --cacert ca.pem https://${KUBERNETES_PUBLIC_ADDRESS}:6443/version
{
  &quot;major&quot;: &quot;1&quot;,
  &quot;minor&quot;: &quot;17&quot;,
  &quot;gitVersion&quot;: &quot;v1.17.4&quot;,
  &quot;gitCommit&quot;: &quot;8d8aa39598534325ad77120c120a22b3a990b5ea&quot;,
  &quot;gitTreeState&quot;: &quot;clean&quot;,
  &quot;buildDate&quot;: &quot;2020-03-12T20:55:23Z&quot;,
  &quot;goVersion&quot;: &quot;go1.13.8&quot;,
  &quot;compiler&quot;: &quot;gc&quot;,
  &quot;platform&quot;: &quot;linux/amd64&quot;
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#bootstrapping-the-kubernetes-worker-nodes&quot; id=&quot;bootstrapping-the-kubernetes-worker-nodes&quot;&gt;
   Bootstrapping the Kubernetes Worker Nodes
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  3 개의 Kubernetes Worker 노드를 부트 스트랩 한다. 다음 구성 요소가 각 노드에 설치된다 : docker, kubelet 및 kube-proxy
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#provisioning-a-kubernetes-worker-node&quot; id=&quot;provisioning-a-kubernetes-worker-node&quot;&gt;
   Provisioning a Kubernetes Worker Node
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  모든 Worker 노드에 OS 종속성패키지를 설치하며, Docker를 설치 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ for package in epel-release socat conntrack ipset wget  vim jq   device-mapper-persistent-data  yum-utils lvm2 ;
  do 
    ansible -i hosts  all -b -m yum  -a name=$package ;
 done 

$ wget https://download.docker.com/linux/centos/docker-ce.repo 

$  ansible -i hosts  all  -b -m copy -a 'src=docker-ce.repo  dest=/etc/yum.repos.d/docker.repo'

$  for docker_package in docker-ce docker-ce-cli containerd.io ;
  do 
    ansible -i hosts  all -b -m yum  -a name=$docker_package ;
 done 
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#download-and-install-worker-binaries&quot; id=&quot;download-and-install-worker-binaries&quot;&gt;
   Download and Install Worker Binaries
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  모든 Worker노드에 구성을 위한 바이너리 파일을 다운로드 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ wget \
https://github.com/containernetworking/plugins/releases/download/v0.8.2/cni-plugins-linux-amd64-v0.8.2.tgz \
https://storage.googleapis.com/kubernetes-release/release/v1.17.4/bin/linux/amd64/kube-proxy \
https://storage.googleapis.com/kubernetes-release/release/v1.17.4/bin/linux/amd64/kubelet


$ for dir in  /etc/cni/net.d /opt/cni/bin /var/lib/kubelet /var/lib/kubernetes /var/run/kubernetes /var/lib/kube-proxy; 
    do 
      ansible -i hosts all -m file -ba &quot;path=$dir state=directory&quot;; 
    done


$ for file in kubectl kube-proxy kubelet  ; 
  do 
     ansible -i hosts all -m copy -ba &quot;src=$file dest=/usr/local/bin/ owner=root group=root mode=0755&quot;; 
  done

$  ansible -i hosts all -m copy -ba &quot;src=cni-plugins-linux-amd64-v0.8.2.tgz dest=/tmp owner=root group=root mode=0755&quot;; 

$ ansible -i hosts all -m unarchive -ba 'src=/tmp/cni-plugins-linux-amd64-v0.8.2.tgz dest=/opt/cni/bin/ remote_src=yes'
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#configure-the-kubelet&quot; id=&quot;configure-the-kubelet&quot;&gt;
   Configure the Kubelet
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  worker 노드 설정을 위한 인증서와 kubeconfig  파일을 복사 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ ansible -i hosts all  -m copy -ba &quot;src=-key.pem dest=/var/lib/kubelet/ owner=root group=root mode=0600&quot;
$ ansible -i hosts all  -m copy -ba &quot;src=.pem dest=/var/lib/kubelet/ owner=root group=root mode=0600&quot;
$ ansible -i hosts all  -m copy -ba &quot;src=.kubeconfig dest=/var/lib/kubelet/kubeconfig owner=root group=root mode=0644&quot;
$ ansible -i hosts all  -m copy -ba &quot;src=ca.pem dest=/var/lib/kubernetes/ owner=root group=root mode=0600&quot;
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;code&gt;
   kubelet-config.yaml
  &lt;/code&gt;
  구성 파일을 작성하고 woker노드로 복사한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF | sudo tee kubelet-config.yaml.j2
kind: KubeletConfiguration
apiVersion: kubelet.config.k8s.io/v1beta1
authentication:
  anonymous:
    enabled: false
  webhook:
    enabled: true
  x509:
    clientCAFile: &quot;/var/lib/kubernetes/ca.pem&quot;
authorization:
  mode: Webhook
clusterDomain: &quot;cluster.local&quot;
clusterDNS:
  - &quot;10.32.0.10&quot;
resolvConf: &quot;/etc/resolv.conf&quot;
runtimeRequestTimeout: &quot;15m&quot;
tlsCertFile: &quot;/var/lib/kubelet/.pem&quot;
tlsPrivateKeyFile: &quot;/var/lib/kubelet/-key.pem&quot;
EOF

$ ansible -i hosts all -m template -ba &quot;src=kubelet-config.yaml.j2 dest=/var/lib/kubelet/kubelet-config.yaml owner=root group=root mode=0644&quot;
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;code&gt;
   resolvConf
  &lt;/code&gt;
  구성은
  &lt;code&gt;
   systemd-resolved
  &lt;/code&gt;
  를 실행하는 시스템에서 서비스 검색에
  &lt;code&gt;
   CoreDNS
  &lt;/code&gt;
  를 사용할 때 루프를 피하기 위해 사용된다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   kubelet.service
  &lt;/code&gt;
  시스템 Unit 파일을 작성한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF | sudo tee kubelet.service
[Unit]
Description=Kubernetes Kubelet
Documentation=https://github.com/kubernetes/kubernetes
After=containerd.service
Requires=containerd.service

[Service]
ExecStart=/usr/local/bin/kubelet \\
  --config=/var/lib/kubelet/kubelet-config.yaml \\
  --container-runtime=docker \\
  --image-pull-progress-deadline=2m \\
  --kubeconfig=/var/lib/kubelet/kubeconfig \\
  --network-plugin=cni \\
  --register-node=true \\
  --v=2
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

$ ansible -i hosts all  -m copy -ba &quot;src=kubelet.service dest=/etc/systemd/system/kubelet.service owner=root group=root mode=0644&quot;
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#configure-the-kubernetes-proxy&quot; id=&quot;configure-the-kubernetes-proxy&quot;&gt;
   Configure the Kubernetes Proxy
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  worker 노드 설정을 kubeconfig  파일을 복사 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ ansible -i hosts all  -m copy -ba &quot;src=kube-proxy.kubeconfig  dest=/var/lib/kube-proxy/kubeconfig owner=root group=root mode=0600&quot;
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;code&gt;
   kube-proxy-config.yaml
  &lt;/code&gt;
  구성 파일을 작성하고  woker노드로 복사한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF | sudo tee kube-proxy-config.yaml
kind: KubeProxyConfiguration
apiVersion: kubeproxy.config.k8s.io/v1alpha1
clientConnection:
  kubeconfig: &quot;/var/lib/kube-proxy/kubeconfig&quot;
mode: &quot;iptables&quot;
clusterCIDR: &quot;10.200.0.0/16&quot;
EOF

$ ansible -i hosts all  -m copy -ba &quot;src=kube-proxy-config.yaml dest=/var/lib/kube-proxy/ owner=root group=root mode=0644&quot;
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;code&gt;
   kube-proxy.service
  &lt;/code&gt;
  시스템 Unit 파일을 작성하고  woker노드로 복사한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF | sudo tee kube-proxy.service
[Unit]
Description=Kubernetes Kube Proxy
Documentation=https://github.com/kubernetes/kubernetes

[Service]
ExecStart=/usr/local/bin/kube-proxy \\
  --config=/var/lib/kube-proxy/kube-proxy-config.yaml
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

$ ansible -i  hosts all -m copy -ba &quot;src=kube-proxy.service dest=/etc/systemd/system/ owner=root group=root mode=0644&quot;
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#start-the-worker-services&quot; id=&quot;start-the-worker-services&quot;&gt;
   Start the Worker Services
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  모든 Wokerer노드에서 Worker노드 구동에 필요한 데몬을 실행한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ for service in docker kubelet kube-proxy; 
  do 
    ansible -i hosts all  -m systemd -ba &quot;name=$service daemon-reload=yes state=started enabled=yes&quot;; 
  done
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  Verification
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ kubectl  get nodes -o wide
NAME                  STATUS     ROLES    AGE   VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION               CONTAINER-RUNTIME
kube-hard-master001   Ready    &amp;lt;none&amp;gt;   28s   v1.17.4   10.15.10.21   &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.27.2.el7.x86_64   docker://19.3.8
kube-hard-master002   Ready    &amp;lt;none&amp;gt;   29s   v1.17.4   10.15.10.22   &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.27.2.el7.x86_64   docker://19.3.8
kube-hard-master003   Ready    &amp;lt;none&amp;gt;   28s   v1.17.4   10.15.10.23   &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.27.2.el7.x86_64   docker://19.3.8
kube-hard-worker001   Ready    &amp;lt;none&amp;gt;   34m   v1.17.4   10.15.10.31   &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.27.2.el7.x86_64   docker://19.3.8
kube-hard-worker002   Ready    &amp;lt;none&amp;gt;   34m   v1.17.4   10.15.10.32   &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.27.2.el7.x86_64   docker://19.3.8
kube-hard-worker003   Ready    &amp;lt;none&amp;gt;   34m   v1.17.4   10.15.10.33   &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.27.2.el7.x86_64   docker://19.3.8
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#configuring-kubectl-for-remote-access&quot; id=&quot;configuring-kubectl-for-remote-access&quot;&gt;
   Configuring kubectl for Remote Access
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  kube-hard-deploy 인스턴스에서 로드밸런서 역할을 하는 haproxy로 클라이언트 요청을 보낼 context를 설정 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ KUBERNETES_PUBLIC_ADDRESS=10.15.10.2

  kubectl config set-cluster kubernetes-the-hard-way \
    --certificate-authority=ca.pem \
    --embed-certs=true \
    --server=https://${KUBERNETES_PUBLIC_ADDRESS}:6443

  kubectl config set-credentials admin \
    --client-certificate=admin.pem \
    --client-key=admin-key.pem

  kubectl config set-context kubernetes-the-hard-way \
    --cluster=kubernetes-the-hard-way \
    --user=admin

  kubectl config use-context kubernetes-the-hard-way
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  kube-hard-deploy 인스턴스에서 kubectl  클라이언트를 이용하여 클러스터의 상태를 확인 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ kubectl get componentstatuses -o yaml | egrep &quot;name:|kind:|message:&quot;
  - message: ok
  kind: ComponentStatus
    name: controller-manager
  - message: '{&quot;health&quot;:&quot;true&quot;}'
  kind: ComponentStatus
    name: etcd-1
  - message: '{&quot;health&quot;:&quot;true&quot;}'
  kind: ComponentStatus
    name: etcd-2
  - message: '{&quot;health&quot;:&quot;true&quot;}'
  kind: ComponentStatus
    name: etcd-0
kind: List

$ kubectl  get nodes -o wide
NAME                  STATUS     ROLES    AGE   VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION               CONTAINER-RUNTIME
kube-hard-master001   Ready    &amp;lt;none&amp;gt;   28s   v1.17.4   10.15.10.21   &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.27.2.el7.x86_64   docker://19.3.8
kube-hard-master002   Ready    &amp;lt;none&amp;gt;   29s   v1.17.4   10.15.10.22   &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.27.2.el7.x86_64   docker://19.3.8
kube-hard-master003   Ready    &amp;lt;none&amp;gt;   28s   v1.17.4   10.15.10.23   &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.27.2.el7.x86_64   docker://19.3.8
kube-hard-worker001   Ready    &amp;lt;none&amp;gt;   34m   v1.17.4   10.15.10.31   &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.27.2.el7.x86_64   docker://19.3.8
kube-hard-worker002   Ready    &amp;lt;none&amp;gt;   34m   v1.17.4   10.15.10.32   &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.27.2.el7.x86_64   docker://19.3.8
kube-hard-worker003   Ready    &amp;lt;none&amp;gt;   34m   v1.17.4   10.15.10.33   &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-957.27.2.el7.x86_64   docker://19.3.8
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#provisioning-pod-network-routes&quot; id=&quot;provisioning-pod-network-routes&quot;&gt;
   Provisioning Pod Network Routes
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  모든 워커 노드에서 IP forwarding 활성화 및 Forward 체인에 대하여 허용하는 iptables 룰을 추가 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ ansible -i hosts all  -m sysctl -ba 'name=net.ipv4.conf.all.forwarding value=1'
$ ansible -i hosts all -m iptables -ba 'chain=FORWARD jump=ACCEPT'
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#deploying-flannel&quot; id=&quot;deploying-flannel&quot;&gt;
   Deploying Flannel
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  CNI로 사용할 Flannel을 배포한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  배포된 Flannel은 데몬셋으로 모든 worker노드에 Pod로 올라온다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ kubectl  get pod -n kube-system -o wide
NAME                          READY   STATUS    RESTARTS   AGE   IP            NODE                  NOMINATED NODE   READINESS GATES
kube-flannel-ds-amd64-82jjr   1/1     Running   0          44s   10.15.10.23   kube-hard-master003   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
kube-flannel-ds-amd64-hdd56   1/1     Running   0          44s   10.15.10.21   kube-hard-master001   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
kube-flannel-ds-amd64-nzd9b   1/1     Running   0          29m   10.15.10.32   kube-hard-worker002   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
kube-flannel-ds-amd64-rxw7l   1/1     Running   0          44s   10.15.10.22   kube-hard-master002   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
kube-flannel-ds-amd64-vgftw   1/1     Running   0          29m   10.15.10.33   kube-hard-worker003   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
kube-flannel-ds-amd64-vzdf5   1/1     Running   0          29m   10.15.10.31   kube-hard-worker001   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  테스트를 위하여 nginx pod를 모든 wokre노드로 배포 하며, busybox를 통하여 서로 다른 노드간 통신이 되는지 확인 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt; EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  selector:
    matchLabels:
      run: nginx
  replicas: 6
  template:
    metadata:
      labels:
        run: nginx
    spec:
      containers:
      - name: my-nginx
        image: nginx
        ports:
        - containerPort: 80
EOF

$ kubectl expose deployment/nginx
$ kubectl run busybox --image=odise/busybox-curl --command -- sleep 3600
$ POD_NAME=$(kubectl get pods -l run=busybox -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
$ kubectl get ep nginxkubectl get ep nginx
NAME    ENDPOINTS                                               AGE
nginx   10.200.0.2:80,10.200.1.2:80,10.200.2.2:80 + 3 more...   36m kubectl exec $POD_NAME -- curl &amp;lt;first nginx pod IP address&amp;gt;

$ kubectl  get pod -o wide
NAME                      READY   STATUS    RESTARTS   AGE     IP           NODE                  NOMINATED NODE   READINESS GATES
busybox                   1/1     Running   0          7m22s   10.200.5.2   kube-hard-master003   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
busybox-9689b649d-sdbqp   1/1     Running   0          37m     10.200.0.3   kube-hard-worker001   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-776b7c6897-59tkb    1/1     Running   0          37m     10.200.2.2   kube-hard-worker002   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-776b7c6897-frs8s    1/1     Running   0          85s     10.200.5.3   kube-hard-master003   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-776b7c6897-kbw89    1/1     Running   0          37m     10.200.0.2   kube-hard-worker001   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-776b7c6897-l2hsr    1/1     Running   0          85s     10.200.4.3   kube-hard-master001   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-776b7c6897-mqqcv    1/1     Running   0          85s     10.200.3.3   kube-hard-master002   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-776b7c6897-pfrcp    1/1     Running   0          37m     10.200.1.2   kube-hard-worker003   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;

$ kubectl exec $POD_NAME -- curl &amp;lt;각 nginx pod ip &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#deploying-the-dns-cluster-add-on&quot; id=&quot;deploying-the-dns-cluster-add-on&quot;&gt;
   Deploying the DNS Cluster Add-on
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  Kubernetes 클러스터 내에서 실행되는 응용 프로그램에 DNS 기반 서비스 검색을 제공하는 DNS 애드온을 배포한다.
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#the-dns-cluster-add-on&quot; id=&quot;the-dns-cluster-add-on&quot;&gt;
   The DNS Cluster Add-on
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  coredns 서비시를 배포 한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ kubectl apply -f https://raw.githubusercontent.com/e-minguez/kubernetes-the-hard-way-osp/master/deployments/coredns.yaml
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  coredns pod를 확인할 수 있다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ kubectl get pods -l k8s-app=kube-dns -n kube-system -o wide
NAME                       READY   STATUS    RESTARTS   AGE   IP           NODE                  NOMINATED NODE   READINESS GATES
coredns-68567cdb47-bkzsq   1/1     Running   0          87s   10.200.4.2   kube-hard-master001   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
coredns-68567cdb47-cc2xn   1/1     Running   0          87s   10.200.3.2   kube-hard-master002   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#verification-3&quot; id=&quot;verification-3&quot;&gt;
   Verification
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  확인하기 위하여 간단한 busybox를 배포한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ kubectl run --generator=run-pod/v1 busybox --image=busybox:1.28 --command -- sleep 3600
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  busybox 컨테이너에서 kuberntes 도메인에 대하여 질의 되는 것을 확인한다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ kubectl exec -ti busybox -- nslookup kubernetes
Server:    10.32.0.10
Address 1: 10.32.0.10 kube-dns.kube-system.svc.cluster.local

Name:      kubernetes
Address 1: 10.32.0.1 kubernetes.default.svc.cluster.local
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  만약 아래와 같은 응답이 안오는 현상이 있을경우
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$ kubectl exec -ti busybox -- nslookup kubernetes
Server:    10.32.0.10
Address 1: 10.32.0.10

nslookup: can't resolve 'kubernetes'
command terminated with exit code 1
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  각 모든 worker 노드에서
  &lt;code&gt;
   br_netfilter
  &lt;/code&gt;
  설정을 확인 해보자
 &lt;/p&gt;
 &lt;p&gt;
  &lt;a href=&quot;https://github.com/alosadagrande/kubernetes-the-hard-way-libvirt-kvm/blob/a78d056e67f580f33097dcdf4a462f388c6a2f05/docs/12-dns-addon.md&quot;&gt;
   https://github.com/alosadagrande/kubernetes-the-hard-way-libvirt-kvm/blob/a78d056e67f580f33097dcdf4a462f388c6a2f05/docs/12-dns-addon.md
  &lt;/a&gt;
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;$  ansible -i hosts kube_worker -m modprobe -ba 'name=br_netfilter state=present'
&lt;/code&gt;&lt;/pre&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;</description>
        <pubDate>Sun, 22 Mar 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/03/22/91695235/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/03/22/91695235/</guid>
        
        <category>kubernetes</category>
        
        <category>flannel</category>
        
        
      </item>
    
      <item>
        <title>Jenkins에서 anchore를 이용한 docker image scanning</title>
        <description>&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
 &quot;앤코어&quot;라고 불리우는 DevSecOps 도구의 사용법과 Jenkins상에서 Anchore와 연계된 CICD pipeline을&lt;/br&gt;
 만드는 과정에 대해 알아보도록 하겠습니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#anchore-는&quot; id=&quot;anchore-는&quot;&gt;
   Anchore 는?
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;p&gt;
  컨테이너 이미지에 대한 검증, 분석, 검사에 대한 중앙화된 서비스를 제공하는 오픈소스 프로젝트입니다.
  &lt;br/&gt;
  Docker V2 호환 컨테이너 저장소들로부터 컨테이너 이미지를 다운로드 받고 분석합니다. 
  &lt;br/&gt;
  그리고 사용자가 지정한 정책에 기반해 평가를 수행합니다.
  &lt;br/&gt;
  CI/CD와 통합된 서비스로 빌드 파이프라인 상에서 보안 및 규정에 대한 체크를 시행할수 있고
  &lt;br/&gt;
  RESTful API와의 연동을 통해 컨테이너 모니터링과의 연동의 구성요소로도 사용될수 있습니다.
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://github.com/anchore/anchore-engine&quot;&gt;
    https://github.com/anchore/anchore-engine
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#anchore-engine-은&quot; id=&quot;anchore-engine-은&quot;&gt;
   Anchore Engine 은?
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;p&gt;
 Anchore는 상용버전과 open source 버전이 있는데 Anchore Engine은 오픈소스 버전으로 &lt;br/&gt;
 깊이있는 이미지 검사와 취약점 스캐닝을 수행할수 있고 Anchore Enterprise 버전은 상용버전으로 &lt;br/&gt;
  대규모 팀을 위한 포괄적인 워크 플로우 및 감사를 수행하는 솔루션 입니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://anchore.com/resources/&quot;&gt;
    https://anchore.com/resources/
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
  Anchore Engine은 다음과 같은 component들로 구성되어 있습니다.
 &lt;/p&gt;
 &lt;ul style=&quot;font-weight:bold&quot;&gt;
  &lt;li&gt;
   API service
  &lt;/li&gt;
  &lt;li&gt;
   catalog service
  &lt;/li&gt;
  &lt;li&gt;
   queuing service
  &lt;/li&gt;
  &lt;li&gt;
   policy engine service
  &lt;/li&gt;
  &lt;li&gt;
   kubernetes webhook service
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
  실제 동작은 다음과 같은 행위를 기반으로 수행됩니다.
  &lt;br/&gt;
  &lt;b style=&quot;color:blue&quot;&gt;
   이미지를 가져와 -&amp;gt; 분석하고 -&amp;gt; 데이터베이스에 저장하고 -&amp;gt; 평가를 수행 -&amp;gt; 평가결과에 대한 알림 -&amp;gt; 반복
  &lt;/b&gt;
 &lt;/p&gt;
 &lt;p&gt;
  아래 링크들은 anchore 공식 문서들로 위 내용들을 좀더 상세히 알아볼수 있습니다.
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://docs.anchore.com/current/docs/engine/general/&quot;&gt;
    https://docs.anchore.com/current/docs/engine/general/
   &lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://docs.anchore.com/current/docs/engine/engine_installation/&quot;&gt;
    https://docs.anchore.com/current/docs/engine/engine_installation/
   &lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://github.com/anchore/anchore-engine&quot;&gt;
    https://github.com/anchore/anchore-engine
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#anchore-engine-설치&quot; id=&quot;anchore-engine-설치&quot;&gt;
   Anchore Engine 설치
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;p&gt;
  우리는 kubernetes 환경을 사용할 예정이기에 helm chart를 사용하여 배포를 진행해보도록 하겠습니다.
  &lt;br/&gt;
  반갑게도 helm3를 지원하고 있고 helm3를 통한 배포예제도 제공되고 있으니 참고하여 배포를 진행합니다.
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://github.com/helm/charts/tree/master/stable/anchore-engine&quot;&gt;
    https://github.com/helm/charts/tree/master/stable/anchore-engine
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
 helm chart의 value 값을 변경하기 위해 아래와 같이 values.yaml template 파일을 가져옵니다.
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm fetch stable/anchore-engine
jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ll
total 60
drwxr-xr-x 2 jacob jacob  4096  3월 16 18:17 ./
drwxr-xr-x 9 jacob jacob  4096  3월 16 18:16 ../
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 jacob jacob 52937  3월 16 18:17 anchore-engine-1.4.2.tgz
jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tar &lt;/span&gt;xvzf anchore-engine-1.4.2.tgz 
anchore-engine/Chart.yaml
anchore-engine/values.yaml
...
jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;anchore-engine/
jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim values.yaml 
&lt;span class=&quot;c&quot;&gt;## OR&lt;/span&gt;
jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; https://raw.githubusercontent.com/helm/charts/master/stable/anchore-engine/values.yaml&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;p&gt;
  가져온 values.yaml 파일의 내용을 아래와 같이 수정합니다.
  &lt;br/&gt;
(개인적으로 필요한 정보만을 넣어준것이기에 추가적으로 변경이 필요한 부분은 확인하여 변경하시기를 권장합니다.)
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;...
  &lt;span class=&quot;c&quot;&gt;#defaultAdminPassword: foobar&lt;/span&gt;
  defaultAdminPassword: password
...
anchoreApi:
  replicaCount: 1

  &lt;span class=&quot;c&quot;&gt;# Set extra environment variables. These will be set on all api containers.&lt;/span&gt;
  extraEnv: &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# - name: foo&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   value: bar&lt;/span&gt;

  &lt;span class=&quot;c&quot;&gt;# kubernetes service configuration for anchore external API&lt;/span&gt;
  service:
    &lt;span class=&quot;c&quot;&gt;#type: ClusterIP&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: LoadBalancer
    port: 8228&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;p&gt;
  이제 배포를 진행합니다.
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k create ns anchore
namespace/anchore created
jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;helm install anchore &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; values.yaml stable/anchore-engine &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; anchore
NAME: anchore
LAST DEPLOYED: Mon Mar 16 18:20:01 2020
NAMESPACE: anchore
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
To use Anchore Engine you need the URL, username, and password to access the API.

Anchore Engine can be accessed via port 8228 on the following DNS name from within the cluster:
anchore-anchore-engine-api.anchore.svc.cluster.local

Here are the steps to configure the anchore-cli &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;pip install anchorecli&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; Use these same values &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;direct API access as well.

To configure your anchore-cli run:

    &lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;admin
    &lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_PASS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;kubectl get secret &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt; anchore anchore-anchore-engine &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;jsonpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;{.data.ANCHORE_ADMIN_PASSWORD}&quot;&lt;/span&gt; | base64 &lt;span class=&quot;nt&quot;&gt;--decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;

Using the service endpoint from within the cluster you can use:
    &lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://anchore-anchore-engine-api.anchore.svc.cluster.local:8228/v1/


To verify the service is up and running, you can run container &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the Anchore Engine CLI:

    kubectl run &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--tty&lt;/span&gt; anchore-cli &lt;span class=&quot;nt&quot;&gt;--restart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Always &lt;span class=&quot;nt&quot;&gt;--image&lt;/span&gt; anchore/engine-cli  &lt;span class=&quot;nt&quot;&gt;--env&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;admin &lt;span class=&quot;nt&quot;&gt;--env&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_PASS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_PASS&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--env&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://anchore-anchore-engine-api.anchore.svc.cluster.local:8228/v1/

from within the container you can use &lt;span class=&quot;s1&quot;&gt;'anchore-cli'&lt;/span&gt; commands.

&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; NOTE: On first startup of anchore-engine, it performs a CVE data sync which may take several minutes to complete. During this &lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;the system status will report &lt;span class=&quot;s1&quot;&gt;'partially_down'&lt;/span&gt; and any images added &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;analysis will stay &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the &lt;span class=&quot;s1&quot;&gt;'not_analyzed'&lt;/span&gt; state.
Once the sync is &lt;span class=&quot;nb&quot;&gt;complete&lt;/span&gt;, any queued images will be analyzed and the system status will change to &lt;span class=&quot;s1&quot;&gt;'all_up'&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

Initial setup &lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;can be &amp;amp;gt&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;120sec &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;postgresql setup and readiness checks to pass &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the services as indicated by pod state. You can check with:
    kubectl get pods &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;anchore-anchore-engine,component&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;api


A quick primer on using the Anchore Engine CLI follows. For more info see: https://github.com/anchore/anchore-engine/wiki/Getting-Started

View system status:

    anchore-cli system status

Add an image to be analyzed:

    anchore-cli image add &amp;amp;lt&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;imageref&amp;amp;gt&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

List images and see the analysis status &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;not_analyzed initially&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:

    anchore-cli image list

Once the image is analyzed you&lt;span class=&quot;s1&quot;&gt;'ll see status change to '&lt;/span&gt;analyzed&lt;span class=&quot;s1&quot;&gt;'. This may take some time on first execution with a new database because
the system must first do a CVE data sync which can take several minutes. Once complete, the image will transition to '&lt;/span&gt;analyzing&lt;span class=&quot;s1&quot;&gt;' state.

When the image reaches '&lt;/span&gt;analyzed&lt;span class=&quot;s1&quot;&gt;' state, you can view policy evaluation output with:

    anchore-cli evaluate check &amp;amp;lt;imageref&amp;amp;gt;

List CVEs found in the image with:

    anchore-cli image vuln &amp;amp;lt;imageref&amp;amp;gt; os

List OS packages found in the image with:
    anchore-cli image content &amp;amp;lt;imageref&amp;amp;gt; os

List files found in the image with:
    anchore-cli image content &amp;amp;lt;imageref&amp;amp;gt; files&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://github.com/helm/charts/tree/master/stable/anchore-engine&quot;&gt;
    https://github.com/helm/charts/tree/master/stable/anchore-engine
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
 anchore 설치후 동작하는데 약 5분의 시간이 소요되었습니다.&lt;/br&gt;
anchore document에는 약3분정도 소요된다고 했는데 시스템에 따라 다를수 있으니 최소 3분이상 대기가 필요할것으로 보입니다.
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k get po &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; anchore
NAME                                                  READY   STATUS    RESTARTS   AGE
anchore-anchore-engine-analyzer-8659dccb4b-sdfpd      1/1     Running   0          5m8s
anchore-anchore-engine-api-658ff56945-5jgxc           1/1     Running   0          5m8s
anchore-anchore-engine-catalog-5786dd8986-dkdjn       1/1     Running   0          5m8s
anchore-anchore-engine-policy-6fcb868764-v5n48        1/1     Running   0          5m8s
anchore-anchore-engine-simplequeue-7689ff844f-rbkrw   1/1     Running   0          5m8s
anchore-postgresql-7d8f988b7-kdc4z                    1/1     Running   0          5m6s&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;p&gt;
  위와 같은 anchore engine의 각 구성요소들이 정상적으로 동작하는지를 확인하여 설치를 완료합니다.
 &lt;/p&gt;
 &lt;p&gt;
  또한 실제 외부 IP를 확인하여 해당 IP로 anchore가 정상적으로 running 하는지 확인해봅니다.
  &lt;/br&gt;
(loadbalancer type으로 생성하여 진행하였습니다.)
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;k get svc &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; anchore
NAME                                 TYPE           CLUSTER-IP      EXTERNAL-IP       PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;          AGE
anchore-anchore-engine-api           LoadBalancer   10.233.33.72    192.168.197.140   8228:32182/TCP   6m59s
anchore-anchore-engine-catalog       ClusterIP      10.233.61.226   &amp;amp;lt&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;none&amp;amp;gt&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;            8082/TCP         6m58s
anchore-anchore-engine-policy        ClusterIP      10.233.13.102   &amp;amp;lt&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;none&amp;amp;gt&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;            8087/TCP         6m59s
anchore-anchore-engine-simplequeue   ClusterIP      10.233.10.236   &amp;amp;lt&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;none&amp;amp;gt&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;            8083/TCP         7m1s
anchore-postgresql                   ClusterIP      10.233.39.237   &amp;amp;lt&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;none&amp;amp;gt&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;            5432/TCP         6m58s&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;p&gt;
  아래와 같이 api 호출에 대한 json 결과를 확인할수 있는 페이지가 확인되어집니다.
  &lt;br/&gt;
  &lt;img src=&quot;/assets/images/91693588/0.png&quot; width=60%/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  참고로 docker-compose를 이용하여 설치도 가능하니 참고하면 좋을 것 같습니다.
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://geekflare.com/anchore-container-security-scanner/&quot;&gt;
    https://geekflare.com/anchore-container-security-scanner/
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   &lt;strong style=&quot;color:red;font-weight:bold&quot;&gt;
    WARNING
   &lt;/strong&gt;
   &lt;br/&gt;
   UI는 Enterprise 버전에서만 가능합니다.
   &lt;br/&gt;
   물론 UI가 꼭 필요하지는 않지만 좀더 UI를 통해 정보를 확인하고자할 경우
   &lt;br/&gt;
   enterprise 라이센스구매에 대해서도 고민해볼 필요는 있을것 같습니다.
  &lt;/p&gt;
 &lt;/blockquote&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#api-정보-확인&quot; id=&quot;api-정보-확인&quot;&gt;
   API 정보 확인
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  swagger UI를 통해 api spec을 확인해볼수 있습니다.
  &lt;br/&gt;
  접속 경로는 v1/swagger.json으로 접속하면 됩니다.
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;http://192.168.197.140:8228/v1/swagger.json&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   &lt;strong style=&quot;color:red;font-weight:bold&quot;&gt;
    WARNING
   &lt;/strong&gt;
   &lt;br/&gt;
   실제 v1/ui로 안내되고 있는데 해당 정보는 업데이트가 아직안된것으로 보여집니다.
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;a href=&quot;https://docs.anchore.com/current/docs/engine/usage/api_usage/&quot;&gt;
     https://docs.anchore.com/current/docs/engine/usage/api_usage/
    &lt;/a&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/blockquote&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#anchore-cli-설치&quot; id=&quot;anchore-cli-설치&quot;&gt;
   anchore-cli 설치
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;p&gt;
  실제 anchore 를 사용하기 위해서는 anchore-cli를 설치해서 사용해야 합니다.
   &lt;/br&gt;
하여 다음 링크를 참고하여 anchore-cli를 설치합니다.
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://github.com/anchore/anchore-cli&quot;&gt;
    https://github.com/anchore/anchore-cli
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
  필자는 ubuntu 환경이어서 아래와 같이 설치를 진행했습니다.
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; venv/bin/activate
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pip install anchorecli
DEPRECATION: Python 2.7 reached the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 is no longer maintained. A future version of pip will drop support &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;Python 2.7. More details about Python 2 support &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;pip, can be found at https://pip.pypa.io/en/latest/development/release-process/#python-2-support
Collecting anchorecli
  Downloading anchorecli-0.6.1.tar.gz &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;36 kB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Requirement already satisfied: &lt;span class=&quot;nv&quot;&gt;certifi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;2019.11.28 &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; ./venv/lib/python2.7/site-packages &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;from anchorecli&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2019.11.28&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Collecting &lt;span class=&quot;nv&quot;&gt;Click&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;7.0
  Downloading Click-7.0-py2.py3-none-any.whl &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;81 kB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     |████████████████████████████████| 81 kB 260 kB/s 
Requirement already satisfied: &lt;span class=&quot;nv&quot;&gt;prettytable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;0.7.2 &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; ./venv/lib/python2.7/site-packages &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;from anchorecli&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.7.2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
...
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli 
Usage: anchore-cli &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;OPTIONS] COMMAND &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;ARGS]...

Options:
...
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; ~/.bash_profile 
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://192.168.197.140:8228/v1
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;admin
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ANCHORE_CLI_PASS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;password
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli image list&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;p&gt;
  위와 같이 image list 를 출력해보았을때 아무 결과가 나오지 않으면 설치 및 인증이 정상적으로 된것이라 보면 됩니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#anchore-cli-사용법&quot; id=&quot;anchore-cli-사용법&quot;&gt;
   anchore-cli 사용법
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;p&gt;
  이제부터 anchore-cli를 사용하여 이미지를 추가하고 분석하는 작업을 수행해보도록 하겠습니다.
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#기본-사용법&quot; id=&quot;기본-사용법&quot;&gt;
   기본 사용법
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  우선 anchore document에서 소개되고 있는 debian image를 가져와 분석하는 과정을 수행해보도록 하겠습니다.
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli image add docker.io/library/debian:latest
Image Digest: sha256:121dd2a723be1c8aa8b116684d66157c93c801f2f5107b60287937e88c13ab89
Parent Digest: sha256:a63d0b2ecbd723da612abf0a8bdb594ee78f18f691d7dc652ac305a490c9b71a
Analysis Status: not_analyzed
Image Type: docker
Analyzed At: None
Image ID: 971452c943760ab769134f22db8d3381b09ea000a6c459fbfa3603bb99115f62
Dockerfile Mode: None
Distro: None
Distro Version: None
Size: None
Architecture: None
Layer Count: None

Full Tag: docker.io/library/debian:latest
Tag Detected At: 2020-03-16T07:58:44Z
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli image list
Full Tag                               Image Digest                                                                   Analysis Status        
docker.io/library/debian:latest        sha256:121dd2a723be1c8aa8b116684d66157c93c801f2f5107b60287937e88c13ab89        analyzing                        
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli image &lt;span class=&quot;nb&quot;&gt;wait &lt;/span&gt;docker.io/library/debian:latest
Status: analyzing
Waiting 5.0 seconds &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;next retry.
Image Digest: sha256:121dd2a723be1c8aa8b116684d66157c93c801f2f5107b60287937e88c13ab89
Parent Digest: sha256:a63d0b2ecbd723da612abf0a8bdb594ee78f18f691d7dc652ac305a490c9b71a
Analysis Status: analyzed
Image Type: docker
Analyzed At: 2020-03-16T07:59:27Z
Image ID: 971452c943760ab769134f22db8d3381b09ea000a6c459fbfa3603bb99115f62
Dockerfile Mode: Guessed
Distro: debian
Distro Version: 10
Size: 126607360
Architecture: amd64
Layer Count: 1

Full Tag: docker.io/library/debian:latest
Tag Detected At: 2020-03-16T07:58:44Z&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;p&gt;
  아래와 같이 api service를 통해 업로드된 image 정보를 확인할 수 있습니다.
  &lt;br/&gt;
  &lt;img src=&quot;/assets/images/91693588/1.png&quot; width=100%/&gt;
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#policy-hub-사용&quot; id=&quot;policy-hub-사용&quot;&gt;
   policy hub 사용
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  사전에 정의된 anchore 정책 번들의 저장소라는 개념으로 policy hub가 사용되어집니다.
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli policy hub list
Name                           Description                                                         
anchore_security_only          Single policy, single whitelist bundle &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;performing               
                               security checks, including example blacklist known malicious        
                               packages by name.                                                   
anchore_default_bundle         Default policy bundle that comes installed with vanilla             
                               anchore-engine deployments.  Mixture of light vulnerability         
                               checks, dockerfiles checks, and warning triggers &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;common         
                               best practices.                                                     
anchore_cis_1.13.0_base        Docker CIS 1.13.0 image content checks, from section 4 and          
                               5. NOTE: some parameters &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;generally are named &lt;span class=&quot;s1&quot;&gt;'example...'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;         
                               must be modified as they require site-specific settings         
&lt;span class=&quot;c&quot;&gt;### https://github.com/anchore/hub/tree/master/sources/bundles    &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli policy hub install anchore_cis_1.13.0_base
Policy ID: anchore_cis_1.13.0_base
Active: False
Source: &lt;span class=&quot;nb&quot;&gt;local
&lt;/span&gt;Created: 2020-03-16T08:28:33Z
Updated: 2020-03-16T08:28:33Z

&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli policy activate anchore_cis_1.13.0_base
Success: anchore_cis_1.13.0_base activated
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli policy list
Policy ID                                   Active        Created                     Updated                     
anchore_cis_1.13.0_base                     True          2020-03-17T01:34:06Z        2020-03-17T01:34:20Z        
2c53a13c-1765-11e8-82ef-23527761d060        False         2020-03-16T09:25:06Z        2020-03-17T01:34:20Z        &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://github.com/anchore/hub&quot;&gt;
    https://github.com/anchore/hub
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
 개인 repository에 있는 이미지를 실제 upload 및 scan해보도록 하겠습니다.&lt;/br&gt;
anchore-cli를 통해 이미지를 가져오고 분석하여 평가하는 과정을 아래 명령어들을 통해 수행해볼수 있습니다.
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli image add dubaek/samplejavaweb:latest
Image Digest: sha256:164b91f591beec2f6452f222024e825a1b845686f41796ab18f9ff653c91926e
Parent Digest: sha256:164b91f591beec2f6452f222024e825a1b845686f41796ab18f9ff653c91926e
Analysis Status: not_analyzed
Image Type: docker
Analyzed At: None
Image ID: 5fcdc5f418ee9d480cd8dc6f3f74938277614e4ac7a1f7176cf0a29818cef132
Dockerfile Mode: None
Distro: None
Distro Version: None
Size: None
Architecture: None
Layer Count: None

Full Tag: docker.io/dubaek/samplejavaweb:latest
Tag Detected At: 2020-03-17T01:35:18Z
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli image &lt;span class=&quot;nb&quot;&gt;wait &lt;/span&gt;dubaek/samplejavaweb:latest
Status: analyzing
Waiting 5.0 seconds &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;next retry.
Status: analyzing
Waiting 5.0 seconds &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;next retry.
Image Digest: sha256:164b91f591beec2f6452f222024e825a1b845686f41796ab18f9ff653c91926e
Parent Digest: sha256:164b91f591beec2f6452f222024e825a1b845686f41796ab18f9ff653c91926e
Analysis Status: analyzed
Image Type: docker
Analyzed At: 2020-03-17T01:38:17Z
Image ID: 5fcdc5f418ee9d480cd8dc6f3f74938277614e4ac7a1f7176cf0a29818cef132
Dockerfile Mode: Guessed
Distro: debian
Distro Version: 9
Size: 549058560
Architecture: amd64
Layer Count: 12

Full Tag: docker.io/dubaek/samplejavaweb:latest
Tag Detected At: 2020-03-17T01:35:18Z

&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli evaluate check docker.io/dubaek/samplejavaweb:latest &lt;span class=&quot;nt&quot;&gt;--detail&lt;/span&gt;
Image Digest: sha256:164b91f591beec2f6452f222024e825a1b845686f41796ab18f9ff653c91926e
Full Tag: docker.io/dubaek/samplejavaweb:latest
Image ID: 5fcdc5f418ee9d480cd8dc6f3f74938277614e4ac7a1f7176cf0a29818cef132
Status: fail
Last Eval: 2020-03-17T01:39:11Z
Policy ID: anchore_cis_1.13.0_base
Final Action: stop
Final Action Reason: policy_evaluation

Gate                   Trigger                               Detail                                                                                                                                                    Status                             
vulnerabilities        stale_feed_data                       The vulnerability feed &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;this image distro is older than MAXAGE &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; days                                                                                stop                               
vulnerabilities        vulnerability_data_unavailable        Feed data unavailable, cannot perform CVE scan &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;distro: debian:9                                                                                       stop                               
dockerfile             exposed_ports                         Dockerfile exposes port &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;8080&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; which is not &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;policy file ALLOWEDPORTS list                                                                              stop                               
dockerfile             instruction                           Dockerfile directive &lt;span class=&quot;s1&quot;&gt;'ADD'&lt;/span&gt; check &lt;span class=&quot;s1&quot;&gt;'exists'&lt;/span&gt; matched against &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;line &lt;span class=&quot;s1&quot;&gt;'file:fdf0128645db4c8b990073dc4fe3fabad50411032c9aa4f86538d46e0e8f158f in /'&lt;/span&gt;        warn                               
dockerfile             instruction                           Dockerfile directive &lt;span class=&quot;s1&quot;&gt;'HEALTHCHECK'&lt;/span&gt; not found, matching condition &lt;span class=&quot;s1&quot;&gt;'not_exists'&lt;/span&gt; check                                                                       stop                               
dockerfile             instruction                           Dockerfile directive &lt;span class=&quot;s1&quot;&gt;'FROM'&lt;/span&gt; check &lt;span class=&quot;s1&quot;&gt;'not_in'&lt;/span&gt; matched against &lt;span class=&quot;s1&quot;&gt;'example_trusted_base1,example_trusted_base2'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;line &lt;span class=&quot;s1&quot;&gt;'scratch'&lt;/span&gt;                               stop                               
...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;p&gt;
  파일, 운영체제, 패키지, npm, gem 등 docker image의 모든 산출물에 대한 content를 분석하고 이에 대한 결과를 확인할 수 있습니다.
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli image content docker.io/dubaek/samplejavaweb:latest
os: available
files: available
npm: available
gem: available
python: available
java: available

&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli image content docker.io/dubaek/samplejavaweb:latest python
Package          Version           Location                                
Python           2.7.13            /usr/lib/python2.7/lib-dynload          
argparse         1.2.1             /usr/lib/python2.7                      
bzr              2.8.0.dev1        /usr/lib/python2.7/dist-packages        
configobj        5.0.6             /usr/lib/python2.7/dist-packages        
mercurial        4.0               /usr/lib/python2.7/dist-packages        
six              1.10.0            /usr/lib/python2.7/dist-packages        
wsgiref          0.1.2             /usr/lib/python2.7                      &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://docs.anchore.com/current/docs/using/cli_usage/images/inspecting_image_content/&quot;&gt;
    https://docs.anchore.com/current/docs/using/cli_usage/images/inspecting_image_content/
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
  아래 명령을 이용하여 컨테이너 이미지의 발견된 취약점목록을 확인할 수 있습니다.
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli image vuln docker.io/library/debian:latest os

Vulnerability ID        Package                            Severity          Fix         CVE Refs        Vulnerability URL                                                   
CVE-2005-2541           tar-1.30+dfsg-6                    Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2005-2541           
CVE-2007-5686           login-1:4.5-1.1                    Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2007-5686           
CVE-2007-5686           passwd-1:4.5-1.1                   Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2007-5686           
CVE-2010-4051           libc-bin-2.28-10                   Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2010-4051           
CVE-2010-4051           libc6-2.28-10                      Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2010-4051           
CVE-2010-4052           libc-bin-2.28-10                   Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2010-4052           
CVE-2010-4052           libc6-2.28-10                      Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2010-4052           
CVE-2010-4756           libc-bin-2.28-10                   Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2010-4756           
CVE-2010-4756           libc6-2.28-10                      Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2010-4756           
CVE-2011-3374           apt-1.8.2                          Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2011-3374           
CVE-2011-3374           libapt-pkg5.0-1.8.2                Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2011-3374           
CVE-2011-3389           libgnutls30-3.6.7-4+deb10u2        Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2011-3389           
CVE-2011-4116           perl-base-5.28.1-6                 Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2011-4116           
CVE-2012-2663           libxtables12-1.8.2-4               Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2012-2663           
CVE-2013-4235           login-1:4.5-1.1                    Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2013-4235           
CVE-2013-4235           passwd-1:4.5-1.1                   Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2013-4235           
CVE-2013-4392           libsystemd0-241-7~deb10u3          Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2013-4392           
CVE-2013-4392           libudev1-241-7~deb10u3             Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2013-4392           
CVE-2017-11164          libpcre3-2:8.39-12                 Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2017-11164          
CVE-2017-16231          libpcre3-2:8.39-12                 Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2017-16231          
CVE-2017-18018          coreutils-8.30-3                   Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2017-18018          
CVE-2017-7245           libpcre3-2:8.39-12                 Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2017-7245           
CVE-2017-7246           libpcre3-2:8.39-12                 Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2017-7246           
CVE-2018-1000654        libtasn1-6-4.13-3                  Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2018-1000654        
CVE-2018-20796          libc-bin-2.28-10                   Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2018-20796          
CVE-2018-20796          libc6-2.28-10                      Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2018-20796          
CVE-2018-6829           libgcrypt20-1.8.4-5                Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2018-6829           
CVE-2019-1010022        libc-bin-2.28-10                   Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-1010022        
CVE-2019-1010022        libc6-2.28-10                      Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-1010022        
CVE-2019-1010023        libc-bin-2.28-10                   Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-1010023        
CVE-2019-1010023        libc6-2.28-10                      Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-1010023        
CVE-2019-1010024        libc-bin-2.28-10                   Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-1010024        
CVE-2019-1010024        libc6-2.28-10                      Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-1010024        
CVE-2019-1010025        libc-bin-2.28-10                   Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-1010025        
CVE-2019-1010025        libc6-2.28-10                      Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-1010025        
CVE-2019-11360          libxtables12-1.8.2-4               Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-11360          
CVE-2019-19882          login-1:4.5-1.1                    Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-19882          
CVE-2019-19882          passwd-1:4.5-1.1                   Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-19882          
CVE-2019-9192           libc-bin-2.28-10                   Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-9192           
CVE-2019-9192           libc6-2.28-10                      Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-9192           
CVE-2019-9893           libseccomp2-2.3.3-4                Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-9893           
CVE-2019-9923           tar-1.30+dfsg-6                    Negligible        None                        https://security-tracker.debian.org/tracker/CVE-2019-9923           
CVE-2020-1712           libsystemd0-241-7~deb10u3          Unknown           None                        https://security-tracker.debian.org/tracker/CVE-2020-1712           
CVE-2020-1712           libudev1-241-7~deb10u3             Unknown           None                        https://security-tracker.debian.org/tracker/CVE-2020-1712           &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://docs.anchore.com/current/docs/using/cli_usage/images/viewing_security_vulnerabilities/&quot;&gt;
    https://docs.anchore.com/current/docs/using/cli_usage/images/viewing_security_vulnerabilities/
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   &lt;strong style=&quot;color:red;font-weight:bold&quot;&gt;
    WARNING
   &lt;/strong&gt;
   &lt;br/&gt;
   system feeds sync가 되어 있어야 취약점 결과가 출력될수 있습니다.
   &lt;br/&gt;
   system feeds list에 출력결과가 없을 경우 sync를 수행한후 진행하는것을 권장합니다.
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;a href=&quot;https://mydeveloperplanet.com/2019/02/13/check-docker-images-for-vulnerabilities-with-anchore-engine/&quot;&gt;
     https://mydeveloperplanet.com/2019/02/13/check-docker-images-for-vulnerabilities-with-anchore-engine/
    &lt;/a&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
  앞서 명령들은 컨테이너 이미지의 tag 하나하나를 직접 지정하여 사용하는 방식이었고
  &lt;br/&gt;
  아래는 저장소의 특정 컨테이너 이미지의 모든 tag의 변화를 감지하는 방식입니다.
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli repo add docker.io/dubaek/samplejavaweb
Repository                            Watched        TagCount        
docker.io/dubaek/samplejavaweb        True           1               
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli image list
Full Tag                                     Image Digest                                                                   Analysis Status        
192.168.197.130:5000/stlapp:1.0              sha256:5b307c4254ec86e8043a42037b254ffb3ff5cccab5f6c5002fceb885443579c8        analyzed               
docker.io/dubaek/samplejavaweb:latest        sha256:164b91f591beec2f6452f222024e825a1b845686f41796ab18f9ff653c91926e        analyzed               
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker tag dubaek/samplejavaweb:latest dubaek/samplejavaweb:1.0
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker push dubaek/samplejavaweb:1.0
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli image list
Full Tag                                     Image Digest                                                                   Analysis Status        
192.168.197.130:5000/stlapp:1.0              sha256:5b307c4254ec86e8043a42037b254ffb3ff5cccab5f6c5002fceb885443579c8        analyzed               
docker.io/dubaek/samplejavaweb:1.0           sha256:164b91f591beec2f6452f222024e825a1b845686f41796ab18f9ff653c91926e        analyzed               
docker.io/dubaek/samplejavaweb:latest        sha256:164b91f591beec2f6452f222024e825a1b845686f41796ab18f9ff653c91926e        analyzed               
 &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;p&gt;
  실제로 특정 이미지(samplejavaweb)에 tag를 추가하여 push한 결과 cycle time(60초)에 기반하여
  &lt;br/&gt;
  새로 push된 tag에 맞는 컨테이너 이미지를 가져옴을 확인할수 있습니다.
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://docs.anchore.com/current/docs/using/cli_usage/repositories/&quot;&gt;
    https://docs.anchore.com/current/docs/using/cli_usage/repositories/
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#image-삭제&quot; id=&quot;image-삭제&quot;&gt;
   image 삭제
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  image 삭제는 관련된 subscription이 inactive 상태가 되어야 삭제가 가능합니다.
  &lt;br/&gt;
  subscription active 상태가 true로 남아 있다면 다음과 같이 에러가 나게 됩니다.
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli image del docker.io/debian:latest
Error: cannot delete image that is the latest of its tags, and has active subscription
HTTP Code: 409
Detail: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;u&lt;span class=&quot;s1&quot;&gt;'error_codes'&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[]}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;p&gt;
  하여 아래와 같이 관련된 subscription을 inactive 로 변경하여 삭제를 진행합니다.
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli subscription list
Tag                                    Subscription Type        Active        
192.168.197.130:5000/stlapp:1.0        analysis_update          True          
192.168.197.130:5000/stlapp:1.0        policy_eval              False         
192.168.197.130:5000/stlapp:1.0        tag_update               True          
192.168.197.130:5000/stlapp:1.0        vuln_update              False         
docker.io/debian:latest                analysis_update          True          
docker.io/debian:latest                policy_eval              False         
docker.io/debian:latest                tag_update               True          
docker.io/debian:latest                vuln_update              False         
docker.io/library/debian:latest        analysis_update          True          
docker.io/library/debian:latest        policy_eval              False         
docker.io/library/debian:latest        tag_update               True          
docker.io/library/debian:latest        vuln_update              False         
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli subscription deactivate analysis_update docker.io/debian:latest
Success
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli subscription deactivate tag_update docker.io/debian:latest
Success
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli subscription list
Tag                                    Subscription Type        Active        
192.168.197.130:5000/stlapp:1.0        analysis_update          True          
192.168.197.130:5000/stlapp:1.0        policy_eval              False         
192.168.197.130:5000/stlapp:1.0        tag_update               True          
192.168.197.130:5000/stlapp:1.0        vuln_update              False         
docker.io/debian:latest                analysis_update          False         
docker.io/debian:latest                policy_eval              False         
docker.io/debian:latest                tag_update               False         
docker.io/debian:latest                vuln_update              False         
docker.io/library/debian:latest        analysis_update          False         
docker.io/library/debian:latest        policy_eval              False         
docker.io/library/debian:latest        tag_update               False         
docker.io/library/debian:latest        vuln_update              False         
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli image del docker.io/debian:latest
Success

&lt;span class=&quot;c&quot;&gt;## 혹은 --force option을 통한 강제 삭제&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;venv&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; jacob@jacob-laptop:~/workspace/openlabs/openlabs-manifests/anchore-engine&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;anchore-cli image del docker.io/library/debian:latest &lt;span class=&quot;nt&quot;&gt;--force&lt;/span&gt;
Success&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   &lt;strong style=&quot;color:yellowgreen;font-weight:bold&quot;&gt;
    NOTE
   &lt;/strong&gt;
   &lt;br/&gt;
   참고로 anchore engine내부에서 사용되는 component로는 skopeo 입니다.
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;a href=&quot;https://github.com/containers/skopeo&quot;&gt;
     https://github.com/containers/skopeo
    &lt;/a&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/blockquote&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#anchore-cli를-사용하는-jenkins-plugin&quot; id=&quot;anchore-cli를-사용하는-jenkins-plugin&quot;&gt;
   anchore-cli를 사용하는 jenkins plugin
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;p&gt;
  이제부터는 jenkins를 통해 pipeline 상에서 자동으로 image scanning을 수행하고
  &lt;br/&gt;
  그결과를 확인할 수 있는 방법에 대하여 알아보도록 하겠습니다.
 &lt;/p&gt;
 &lt;p&gt;
  workflow는 다음과 같습니다.
  &lt;br/&gt;
  &lt;img src=&quot;/assets/images/91693588/2.png&quot; width=100%/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  anchore를 jenkins에서 사용하기 위해서는 plugin을 설치해야 합니다.
  &lt;br/&gt;
  설치될 plugin은 다음과 같습니다.
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;http://plugins.jenkins.io/anchore-container-scanner/&quot;&gt;
    http://plugins.jenkins.io/anchore-container-scanner/
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
  plugin설치가 완료된후 jenkins의 configuration system 메뉴에서 Anchore Container Image Scanner 설정을 추가합니다.
  &lt;br/&gt;
  해당 정보는 앞서 anchore-cli에서 export 했던 정보를 그대로 입력하면 됩니다.
  &lt;br/&gt;
  &lt;img src=&quot;/assets/images/91693588/3.png&quot; width=60%/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  이후 kubernetes 환경에서 jenkins를 사용중이기에 scripted pipeline으로 작성을 진행합니다.
  &lt;br/&gt;
  kubernetes 환경의 jenkins에서는 docker image를 사용할수 있고 anchore를 사용하기 위해서는
  &lt;br/&gt;
  (Jenkins pipeline을 kubernetes에서 사용하는 방법은
  &lt;a href=&quot;https://tech.osci.kr/2019/11/21/86026733/&quot;&gt;
   https://tech.osci.kr/2019/11/21/86026733/
  &lt;/a&gt;
  블로그 참고)
  &lt;br/&gt;
  다음 anchore-cli container image를 사용합니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://hub.docker.com/r/anchore/engine-cli&quot;&gt;
    https://hub.docker.com/r/anchore/engine-cli
   &lt;/a&gt;
   참고로 찾다보면 anchore/cli와 같은 이전 버전의 cli image가 있는데 이를 사용하면 안되고
   &lt;br/&gt;
   API를 사용해 engine과 통신하여 scanning을 수행하는 방식으로 변경되었고 그에 맞는 이미지를 사용해야 합니다.
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
  이제 jenkins pipeline을 작성해보도록 하겠습니다.
  &lt;br/&gt;
  아래는 간단한 예제입니다.
 &lt;/p&gt;
 &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;            stage&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'check security'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                // container&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'anchore-cli'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                //     def imageLine &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'debian:latest'&lt;/span&gt;
                //     writeFile file: &lt;span class=&quot;s1&quot;&gt;'anchore_images'&lt;/span&gt;, text: imageLine
                //     anchore name: &lt;span class=&quot;s1&quot;&gt;'anchore_images'&lt;/span&gt;
                // &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                container&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'anchore-cli'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    def imageLine &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'192.168.197.130:5000/stlapp:1.0'&lt;/span&gt;
                    writeFile file: &lt;span class=&quot;s1&quot;&gt;'anchore_images'&lt;/span&gt;, text: imageLine
                    anchore name: &lt;span class=&quot;s1&quot;&gt;'anchore_images'&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   &lt;strong style=&quot;color:yellowgreen;font-weight:bold&quot;&gt;
    NOTE
   &lt;/strong&gt;
   &lt;br/&gt;
   jenkins pipeline에 의해 실행된 anchore 결과 중 image 정보를 확인해볼수 있습니다.
   &lt;br/&gt;
   &lt;img src=&quot;/assets/images/91693588/4.png&quot; width=100%/&gt;
   &lt;br/&gt;
   또한 jenkinsfile example은 다음과 같습니다.
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;a href=&quot;https://github.com/nightfurys/anchore-jenkins-example/blob/master/Jenkinsfile&quot;&gt;
     https://github.com/nightfurys/anchore-jenkins-example/blob/master/Jenkinsfile
    &lt;/a&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
  실제 jenkins pipeline에 의해 실행된 결과는 다음과 같이 출력됩니다.
  &lt;br/&gt;
  &lt;img src=&quot;/assets/images/91693588/5.png&quot; width=100%/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  Jenkins plugin을 통해 다음과 같은 파일들이 생성됨을 확인할 수 있으며 각 파일은 json 형태로 생성됩니다.
  &lt;br/&gt;
  &lt;img src=&quot;/assets/images/91693588/6.png&quot; width=100%/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  Anchore Policy에 기반한 평가 결과에 대해서도 Jenkins UI상에서 확인해볼수 있습니다.
  &lt;br/&gt;
  &lt;img src=&quot;/assets/images/91693588/7.png&quot; width=100%/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  Dockerfile의 HEALTHCHECK 지시어 사용에대한 권장안도 출력되었고 CVE를 기반으로 하기에 CVE의 취약점에 대한 경고도
  &lt;br/&gt;
  함께 출력됨을 확인할 수 있습니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#참고사이트&quot; id=&quot;참고사이트&quot;&gt;
   참고사이트
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://docs.anchore.com/current/docs/engine/general/&quot;&gt;
    https://docs.anchore.com/current/docs/engine/general/
   &lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://bcho.tistory.com/1309&quot;&gt;
    https://bcho.tistory.com/1309
   &lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://anchore.com/integrating-anchore-scanning-into-jenkins-pipeline-via-jenkinsfile/&quot;&gt;
    https://anchore.com/integrating-anchore-scanning-into-jenkins-pipeline-via-jenkinsfile/
   &lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://wiki.jenkins.io/display/JENKINS/Anchore+Container+Image+Scanner+Plugin&quot;&gt;
    https://wiki.jenkins.io/display/JENKINS/Anchore+Container+Image+Scanner+Plugin
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 17 Mar 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/03/17/91693588/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/03/17/91693588/</guid>
        
        <category>anchore</category>
        
        <category>jenkins</category>
        
        <category>anchore_jenkinsfile</category>
        
        <category>jenkinsfile</category>
        
        <category>security</category>
        
        <category>container_image_scanning</category>
        
        <category>컨테이너</category>
        
        <category>이미지</category>
        
        <category>스캐닝</category>
        
        
      </item>
    
      <item>
        <title>재택 근무를 위해 꼭 필요한 세 가지 Tips, 이것만 기억하세요!</title>
        <description>&lt;p&gt;
 안녕하세요,
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅 마케팅팀 박현수입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 신종 코로나 바이러스로 인한 감염병 위험 단계가  &quot;심각&quot; 으로 격상되면서, 국내 많은 기업들이 구성원과 고객의 안전을 위해 재택 근무를 도입하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(51,51,51);&quot;&gt;
  유연한 조직 문화가 잘 형성되어 있던 스타트업뿐 만 아니라 카카오, SK텔레콤, KT 등 대기업들도 빠르게 재택 근무를 도입하여 눈길을 끌었습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(51,51,51);&quot;&gt;
  업무 효율성과 내부 만족도를 위해 잘 구축해 놓았던 원격 근무 시스템 덕분에, 예상치 못한 재난 사태에도 구성원들의 안전을 챙기기위한 조치를 취할 수 있었습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 신종 코로나 바이러스 사태가 잠잠해지더라도, 재택 근무와 같은 비대면 근무 형태는 점점 보편화될 것이라고 전문가들은 예측하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅은 지난 2012년부터 업무 공유, 의사소통 체계를 갖추고 여러 팀에서 재량에 맞게 재택을 해 온 경험이 있어, 이번 사태에도 빠르게 재택 근무 시스템을 채택하여 안전한 근무 생활을 지속해나가고 있습니다
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/91691404/0.svg&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 재택 근무를 위해서는 여러 가지 솔루션을 기반으로 효율적인 업무 처리를 위한 툴과 좋은 문화가 수반되어야 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/91691404/1.jpeg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;h1 id=&quot;id-재택근무를위해꼭필요한세가지Tips,이것만기억하세요!-첫번째팁,안정적인인프라를구축할것!&quot;&gt;
 &lt;span style=&quot;color: rgb(60,62,64);&quot;&gt;
  첫번째 팁, 안정적인 인프라를 구축할 것!
 &lt;/span&gt;
&lt;/h1&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(60,62,64);&quot;&gt;
  -중소 기업 간 재택근무 여력도 여실히 드러났다. 2~3년 전부터 공유오피스를 도입해 운영 중인 대기업들은 갑작스러운 재택근무 상황에도 순조롭게 적응 중이다. SK그룹의 한 매니저급 직원은 “공유오피스를 도입하면서 업무 자체가 클라우드 기반으로 바뀌었다”며 “집 컴퓨터로도 개인정보만 입력하면 사무실에서 일하는 것과 동일하게 사내 메신저 등을 이용할 수 있다&quot;고 말했다. 반면 IT 인프라 투자 여력이 없는 중소기업은 재택근무가 사실상 불가능하다.
 &lt;/span&gt;
 &lt;br/&gt;
 &lt;br/&gt;
 &lt;span style=&quot;color: rgb(60,62,64);&quot;&gt;
  [출처: 중앙일보] 코로나 재택근무 표정…대리 &quot;일할맛&quot; 과장 &quot;감옥&quot; 상무 &quot;심심&quot;
 &lt;/span&gt;
&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;
 재택 근무를 하고 싶어도 못하는 첫번째 이유는 위와 같은 상황처럼 사내 인프라 접속이 집에서 어려워 사무실로의 출근이 불가피하기 때문입니다. 디지털 트랜스포메이션이 도래하면서, 많은 기업들이 클라우드 환경으로의 이전을 고민하고 있지만, 비용이나 기술 등 현실적인 여건때문에 도입을 주저하고 있는 현실입니다. 오픈소스컨설팅 열린기술공방에서는 실제 업무를 클라우드 환경으로 직접 마이그레이션해봄으로써, 마이그레이션 시의 고려 사항에 대해 이해하고 관련된 기술과 지식을 직접 익힐 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 클라우드로 향하는 첫걸음,
 &lt;span&gt;
 &lt;/span&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;http://bit.ly/3cCBbob&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot;&gt;
  더 알아보기
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;id-재택근무를위해꼭필요한세가지Tips,이것만기억하세요!-두번째팁,적절한툴을사용할것!&quot;&gt;
 두번째 팁, 적절한 툴을 사용할 것!
&lt;/h1&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;_5mfr&quot; style=&quot;color: rgb(23,43,77);&quot;&gt;
  &lt;span class=&quot;_6qdm&quot; style=&quot;text-decoration: none;&quot;&gt;
   ✅
  &lt;/span&gt;
 &lt;/span&gt;
 &lt;span style=&quot;color: rgb(23,43,77);&quot;&gt;
  &lt;strong&gt;
   일정 공유, 외부 회의 : G-Suite
  &lt;/strong&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 Google Calendar로 전체 구성원의 일정을 한번에 확인해볼 수 있으며, 사내 회의가 아닌 외부 회의 일정은 Hangouts 미팅을 활용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;_5mfr&quot; style=&quot;color: rgb(23,43,77);&quot;&gt;
  &lt;span class=&quot;_6qdm&quot; style=&quot;text-decoration: none;&quot;&gt;
   ✅
  &lt;/span&gt;
 &lt;/span&gt;
 &lt;span style=&quot;color: rgb(23,43,77);&quot;&gt;
  &lt;strong&gt;
   전
   &lt;span style=&quot;color: rgb(0,0,0);&quot;&gt;
    사 영업 회의 : Salesforce
   &lt;/span&gt;
  &lt;/strong&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(0,0,0);&quot;&gt;
  전세계 1위 CRM 툴로 주목받고 있는 Salesforce! 아래와 같은 대시보드를 통해 영업 목표 달성률 및 진행 현황을 공유할 수 있는데요. 이러한 기능은 재택근무 기간동안에 더욱 유용하게 활용됩니다. 굳이 대면 보고를 하지 않아도 영업현황을 실시간으로 파악할 수 있고, 영업 회의 또한 편리하게 진행할 수 있었답니다. 또한, 마케팅 캠페인으로 들어온 리드의 진행 상황도 한 눈에 볼 수 있어 마케팅-영업 간 긴밀한 협업도 가능합니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/91691404/2.jpeg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(23,43,77);&quot;&gt;
  &lt;span class=&quot;_5mfr&quot; style=&quot;color: rgb(23,43,77);&quot;&gt;
   &lt;span class=&quot;_6qdm&quot; style=&quot;text-decoration: none;&quot;&gt;
    ✅
   &lt;/span&gt;
  &lt;/span&gt;
  &lt;strong&gt;
   커뮤니케이션, 화상 회의 : Slack
  &lt;/strong&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(23,43,77);&quot;&gt;
  팀 주간 회의나 Scrum 미팅은 Slack을 통해 진행합니다. 오픈소스컨설팅은 기존에도 내부 커뮤니케이션 도구로 Slack (이하, 슬랙)을 사용하고 있는데요. 사내 메신저처럼 공지 사항 등을 실시간으로 알리기도 하는 등 커뮤니케이션하고, 업무 논의는 부서별, 프로젝트별로 구성된 &quot;Channel&quot;에서 협의합니다. 마케팅팀 소속인 글쓴이 같은 경우에는 &quot;marketing&quot; 팀 채널 뿐만 아니라, &quot;sales_mkt&quot;, &quot;mkt_rnd&quot;등 채널에 소속되어 다른 팀과도 간편하게 협업하고 있습니다.  또한, 슬랙은 Google Calendar뿐만 아니라, 아래 소개할 협업 툴인 Jira, Confluence와도 찰떡 궁합이라 업무를 더욱 효율적으로 수행할 수 있도록 돕습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(23,43,77);&quot;&gt;
  (아래 사진은 슬랙을 통해 화상 회의를 하면서, Confluence에 작성하고 있는 회의록 화면을 공유하는 장면입니다.)
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/91691404/3.jpeg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(23,43,77);&quot;&gt;
  &lt;span class=&quot;_5mfr&quot; style=&quot;color: rgb(23,43,77);&quot;&gt;
   &lt;span class=&quot;_6qdm&quot; style=&quot;text-decoration: none;&quot;&gt;
    ✅
   &lt;/span&gt;
  &lt;/span&gt;
  &lt;strong&gt;
   프로젝트 수행, 이슈 관리 : Jira
  &lt;/strong&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(51,51,51);&quot;&gt;
  진행 중인 프로젝트와 다양한 업무들은 별도 이슈로 생성해서 관리할 수 있습니다. 바로 Jira에서요!
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(51,51,51);&quot;&gt;
  `To do` → `In Progress' → 'Done' 의 칸반 보드로 팀별 태스크 및 진행 현황을 관리하여, 굳이 물어보거나 답하지 않아도 Jira를 통해 한눈에 파악할 수 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(23,43,77);&quot;&gt;
  &lt;span class=&quot;_5mfr&quot; style=&quot;color: rgb(23,43,77);&quot;&gt;
   &lt;span class=&quot;_6qdm&quot; style=&quot;text-decoration: none;&quot;&gt;
    ✅
   &lt;/span&gt;
  &lt;/span&gt;
  &lt;strong&gt;
   산출물 관리, 회의록 작성 : Confluence
  &lt;/strong&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(23,43,77);&quot;&gt;
  회의록 작성이나 Checklist 등 문서 작성이 필요할 때는 Confluence를 이용합니다. Confluence는 wiki라고 부르기도 할만큼 사내의 다양한 정보를 담고 있으며, 또한 필요한 만큼 Space를 생성해서 팀별/프로젝트별로 활용할 수 있습니다. (아래 사진은 회의 참석자들이 공동 편집 기능으로 회의록을 작성하는 장면이예요! 모바일 환경에서도 실시간으로 편집 기능을 사용할 수 있답니다.) 또, Confluence는 링크만 있으면 구성원들이 쉽게 접속해 볼 수 있고, pdf, excel, powerpoint 등 많이 사용하는 파일도 매크로를 통해 쉽게 연동이 가능한 장점이 있어, Jira 이슈의 최종 산출물을 쉽게 관리할 수 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(23,43,77);&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/91691404/4.jpeg&quot;/&gt;
   &lt;/span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;gt;&amp;gt;재택 근무를 가능하게 하는 강력한 협업 툴 Jira &amp;amp; Confluence,
 &lt;span&gt;
 &lt;/span&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;http://bit.ly/2VPhSSE&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot;&gt;
  무료 교육 만나보기
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;id-재택근무를위해꼭필요한세가지Tips,이것만기억하세요!-세번째팁,유연한문화를형성할것!&quot;&gt;
 세번째 팁, 유연한 문화를 형성할 것!
&lt;/h1&gt;
&lt;p&gt;
 &lt;strong&gt;
  Agile
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 애자일(Agile) 방법론은 작업 계획을 짧은 단위로 세우고, 작업 및 사이클을 반복함으로써 고객 요구의 변화에도 유연하고 신속하게 대응하는 개발 방법론입니다. 소프트웨어 개발 방식의 하나로 통용되던 말이었으나, 최근 개발 분야에 국한되지 않고 조직과 사업 등 기업 경영 전반으로 범위가 확대되고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅은 Agile한 문화 형성을 위해, Sprint와 Scrum Meeting을 도입하고 있습니다. Scrum Meeting 동안은 매일 주어진 시간에 5분동안 서로의 DDL (Daily Did List)와 이슈를 공유합니다. 각 팀에는 Scrum Master가 팀의 이슈 해결을 돕고 스프린트를 장려하기도 하죠. 매일 공유하는 시간을 갖는 습관 덕분에, 오픈소스컨설팅은 급작스럽게 재택 근무를 하게 되어도 Daily Scrum Meeting을 통해 팀 내부 업무를 투명하게 공유하고, Sprint를 지속해 나갈 수 있었답니다.
&lt;/p&gt;
&lt;p&gt;
 &amp;gt;&amp;gt; 조직에 Agile을 도입하는 방법에 대해
 &lt;a class=&quot;external-link&quot; href=&quot;http://bit.ly/3cty3uS&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot;&gt;
  더 알아보기
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  공유 문화
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 매주 월요일 10시, 오픈소스컨설팅인들은 열린기술공방으로 모입니다. 월요일 아침을
 &lt;span&gt;
  Tech Session으로 열고, 각자 스터디한 것을 공유하고 함께 의견을 나누는 시간을 가집니다.
 &lt;/span&gt;
 블로그 글을 작성해서, 다른 커뮤니티나 교육 등에서 보고 느낀 것, 배우고 공유한 것을 나눕니다.
 &lt;span&gt;
  그러한 결과물들이 모여 현재의 오픈소스컨설팅을 만든 것이죠.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 함께 머리를 맞대고 고민하여 더 나은 것으로 나아가는 공유 문화,
 &lt;a class=&quot;external-link&quot; href=&quot;http://bit.ly/2vKT6Zj&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot;&gt;
  열린기술공방
 &lt;/a&gt;
 에서 직접 만나보실 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 감사합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Fri, 06 Mar 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/03/06/91691404/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/03/06/91691404/</guid>
        
        <category>재택근무</category>
        
        <category>agile</category>
        
        <category>devops</category>
        
        <category>cloud</category>
        
        <category>마이그레이션</category>
        
        <category>신종코로나</category>
        
        
      </item>
    
      <item>
        <title>[Container 시리즈] 02. Docker사용법 Docker Basic Command</title>
        <description>&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-information conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;info&quot;&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   nginx docker image를 여 registry로 부터 image pull, run, 그리고 삭제하는 과정에 대해 기술
  &lt;/p&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 안녕하세요 ^^
&lt;/p&gt;
&lt;p&gt;
 저번시간에 설치만 해서 너무 간질간질 하셨을 여러분을 위해
&lt;/p&gt;
&lt;p&gt;
 지난 글에 이어서 Docker 기본 명령어에 대해 알아보는 시간을 가지도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;a href=&quot;/pages/viewpage.action?pageId=91690167&quot;&gt;
  [Container 시리즈] 00. Container/ Docker란 뭔가요?
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a href=&quot;/pages/viewpage.action?pageId=91690190&quot;&gt;
  [Container 시리즈] 01. 도커를 설치하고 실행해보자! Docker on Amazon Linux
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;id-[Container시리즈]02.Docker사용법DockerBasicCommand-1.Image가져오기&quot;&gt;
 1. Image 가져오기
&lt;/h1&gt;
&lt;p&gt;
 : 기본 개념에서와 같이 도커는 저장소(registry)에서 이미지를 가져와 사용을 합니다
&lt;/p&gt;
&lt;p&gt;
 $ docker pull nginx:latest
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;# docker images 명령어를 통해 현재 가지고 있는 이미지 확인
[kbseo@ip-172-20-1-221 ~]$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE

# docker login
[kbseo@ip-172-20-1-221 ~]$ docker login
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.
Username: kbseo
Password: 
WARNING! Your password will be stored unencrypted in /home1/kbseo/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded

&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이미지를 땡겨 봅시다
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;# tag를 지정해주지 않으면 default로 latest 버전을 가져옵니다.
# tag를 지정할 경우 
# docker pull nginx:latest 
# 위의 명령어 대로 pull 가능

[kbseo@ip-172-20-1-221 ~]$ docker pull nginx
Using default tag: latest
latest: Pulling from library/nginx
bc51dd8edc1b: Pull complete 
66ba67045f57: Pull complete 
bf317aa10aa5: Pull complete 
Digest: sha256:ad5552c786f128e389a0263104ae39f3d3c7895579d45ae716f528185b36bc6f
Status: Downloaded newer image for nginx:latest
[kbseo@ip-172-20-1-221 ~]$ 

# 이미지 확인
[kbseo@ip-172-20-1-221 ~]$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
nginx               latest              2073e0bcb60e        3 weeks ago         127MB
[kbseo@ip-172-20-1-221 ~]$ 

&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 이미지를 가져왔으니 이제 실행시켜봐야죠!
&lt;/p&gt;
&lt;h1 class=&quot;auto-cursor-target&quot; id=&quot;id-[Container시리즈]02.Docker사용법DockerBasicCommand-2.RunContainer&quot;&gt;
 2. Run Container
&lt;/h1&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;# docker ps 라는 명령어로 현재 실행중인 컨테이너를 확인합니다.
# docker ps -a -&amp;gt; 중지된 컨테이너까지 모두 출력

[kbseo@ip-172-20-1-221 ~]$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 실행중인 컨테이너가 없네요
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;# docker run 이라는 명령어로 컨테이너를 실행시켜줍니다.
# docker run &amp;lt;옵션&amp;gt; &amp;lt;이미지 이름&amp;gt; &amp;lt;실행할 파일&amp;gt;

[kbseo@ip-172-20-1-221 ~]$ docker run -it -d -p 8080:80 --name=nginx nginx:latest
57c8f50ce8c565e7b8fcfbe3a730b4be9c7c0221606ee0ba7dc22295d1b8ae04

# 옵션 -i(interactive), -t(Pseudo-tty) -&amp;gt; Bash Shell에 입력 및 출력을 할 수 있습니다.
# 옵션 --name -&amp;gt; 컨테이너의 이름을 지정해 줍니다.
# 옵션 -d -&amp;gt; daemonized
# 옵션 -p -&amp;gt; 포트포워딩

[kbseo@ip-172-20-1-221 ~]$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
57c8f50ce8c5        nginx:latest        &quot;nginx -g 'daemon of…&quot;   4 seconds ago       Up 3 seconds        0.0.0.0:8080-&amp;gt;80/tcp   nginx
[kbseo@ip-172-20-1-221 ~]$ 

[kbseo@ip-172-20-1-221 ~]$ curl http://localhost:8080
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Welcome to nginx!&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;For online documentation and support please refer to
&amp;lt;a href=&quot;http://nginx.org/&quot;&amp;gt;nginx.org&amp;lt;/a&amp;gt;.&amp;lt;br/&amp;gt;
Commercial support is available at
&amp;lt;a href=&quot;http://nginx.com/&quot;&amp;gt;nginx.com&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Thank you for using nginx.&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
[kbseo@ip-172-20-1-221 ~]$ 


&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/91690192/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot; style=&quot;text-align: center;&quot;&gt;
 잘 뜨네요. 기쁩니다.
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 컨테이너를 실행했으니 내부로 들어가 봅시다.
&lt;/p&gt;
&lt;h1 class=&quot;auto-cursor-target&quot; id=&quot;id-[Container시리즈]02.Docker사용법DockerBasicCommand-3.Container내부탐험&quot;&gt;
 3. Container 내부탐험
&lt;/h1&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 $ docker exec
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;# 내부장벽진입
[kbseo@ip-172-20-1-221 ~]$ docker exec -it nginx /bin/bash
root@57c8f50ce8c5:/# 

# 진입완료
# 컨테이너의 hostname을 알아봅시다 
root@57c8f50ce8c5:/# hostname
57c8f50ce8c5

root@57c8f50ce8c5:/# cat /etc/issue
Debian GNU/Linux 10 \n \l

root@57c8f50ce8c5:/# 

# Shell을 빠져나오려면 Ctrl + D 혹은 exit를 입력합니다.

# exit로 나왔을 경우 container 도 쉘 종료메세지(exit 0)을 받고 자연스럽게 종료 되기때문에 docker start [컨테이더 ID ] 명령어로 재시작 혹은 ctrl+ p 혹은 ctrl + q 로 실행을 유지한 채 터미널로 빠져 나올 수 있습니다.&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h1 class=&quot;auto-cursor-target&quot; id=&quot;id-[Container시리즈]02.Docker사용법DockerBasicCommand-4.Image삭제&quot;&gt;
 4. Image 삭제
&lt;/h1&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 : 보통은 이미지를 삭제하기 전 컨테이너를 먼저 삭제한 후 진행됩니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;# docker rm 명령어를 통해 삭제합니다
# 컨테이너 삭제 
[kbseo@ip-172-20-1-221 ~]$ docker rm nginx
Error response from daemon: You cannot remove a running container 57c8f50ce8c565e7b8fcfbe3a730b4be9c7c0221606ee0ba7dc22295d1b8ae04. Stop the container before attempting removal or force remove

# 어라? 삭제가 안되네요
# 먼저 중지를 해줍니다.

# I will find you and I will kill you...

[kbseo@ip-172-20-1-221 ~]$ docker kill nginx
nginx

# 다시삭제를 해봅니다.
[kbseo@ip-172-20-1-221 ~]$ docker rm nginx
nginx
[kbseo@ip-172-20-1-221 ~]$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[kbseo@ip-172-20-1-221 ~]$ 

# 잘 삭제가 되네요

&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 이미지도 지워버립시다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;# docker rmi 명령어를 통해 이미지를 삭제해줍니다.

[kbseo@ip-172-20-1-221 ~]$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
nginx               latest              2073e0bcb60e        3 weeks ago         127MB
[kbseo@ip-172-20-1-221 ~]$ 

# $ docker rmi nginx:latest 혹은 $ docker rmi [ 이미지 ID ] 

[kbseo@ip-172-20-1-221 ~]$ docker rmi nginx:latest
Untagged: nginx:latest
Untagged: nginx@sha256:ad5552c786f128e389a0263104ae39f3d3c7895579d45ae716f528185b36bc6f
Deleted: sha256:2073e0bcb60ee98548d313ead5eacbfe16d9054f8800a32bedd859922a99a6e1
Deleted: sha256:a3136fbf38691346715cac8360bcdfca0fff812cede416469653670f04e2cab0
Deleted: sha256:99360ffcb2da18fd9ede194efaf5d4b90e7aee99f45737e918113e6833dcf278
Deleted: sha256:488dfecc21b1bc607e09368d2791cb784cf8c4ec5c05d2952b045b3e0f8cc01e
[kbseo@ip-172-20-1-221 ~]$ 
[kbseo@ip-172-20-1-221 ~]$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE

&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 컨테이너를 삭제하기 전 이미지를 삭제할 경우 -f옵션으로 한꺼번에 삭제할 수 있습니다.
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 $ docker rmi -f [이미지 ID]
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &amp;gt; 컨테이너도 강제삭제
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 이렇게 끝내면 너무 아쉬우니 부가적으로 이미지를 저장할때 aws s3로 저장하는 방법도 슬쩍 소개해 드리겠습니다.
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;s&gt;
  aws가 좋아서 그런거는 아닙니다.
 &lt;/s&gt;
&lt;/p&gt;
&lt;h1 class=&quot;auto-cursor-target&quot; id=&quot;id-[Container시리즈]02.Docker사용법DockerBasicCommand-+AWSS3에컨테이너이미지저장&quot;&gt;
 + AWS S3에 컨테이너 이미지 저장
&lt;/h1&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Docker registry 이미지를 가져옵니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;# docker pull registry:latest
[kbseo@ip-172-20-1-221 ~]$ docker pull registry:latest
latest: Pulling from library/registry
486039affc0a: Pull complete 
ba51a3b098e6: Pull complete 
8bb4c43d6c8e: Pull complete 
6f5f453e5f2d: Pull complete 
42bc10b72f42: Pull complete 
Digest: sha256:7d081088e4bfd632a88e3f3bcd9e007ef44a796fddfe3261407a3f9f04abe1e7
Status: Downloaded newer image for registry:latest
[kbseo@ip-172-20-1-221 ~]$ 

&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  이미지를 컨테이너로 실행해줍니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;# 다운받은 이미지 Run
[kbseo@ip-172-20-1-221 ~]$  docker run -d -p 5000:5000 --restart=always --name docker-registry \
&amp;gt;   -e REGISTRY_STORAGE=s3 \
&amp;gt;   -e REGISTRY_STORAGE_S3_BUCKET=kbseo-s3 \
&amp;gt;   -e REGISTRY_STORAGE_S3_ACCESSKEY=AKIAJMYYWQIA******* \
&amp;gt;   -e REGISTRY_STORAGE_S3_SECRETKEY=YTOwsm0lDgghwjRHtR************ \
&amp;gt;   -e REGISTRY_STORAGE_S3_REGION=ap-northeast-2 \
&amp;gt;   registry
274a07c0c008d866e44215eb4b3626448e5ef11fa573acd69ecb3e000ebde7b2

[kbseo@ip-172-20-1-221 ~]$ 

# docker run -d -p 5000:5000 --restart=always --name docker-registr -&amp;gt; s3-registry 이미지 이름 지정 후 registry 기본포트 5000번으로 실행해줍니다
# -e SETTINGS_FLAVOR=s3  -&amp;gt; SETTINGS_FLAVOR는 s3로 설정해줍니다.
# -e AWS_BUCKET=kbseo-s3 -&amp;gt; 저장할 버킷이름을 지정해주세요
# -e STORAGE_PATH=/registry -&amp;gt; 저장될 경로입니다.
# -e AWS_KEY=AKIAJMYYWQIA******* -&amp;gt; IAM 혹은 루트계정의 Access Key를 입력해주세요
# -e AWS_SECRET=YTOwsm0lDgghwjRHtR************ -&amp;gt;  IAM 혹은 루트계정의 Secret Key를 입력해주세요

 docker run -d -p 5000:5000 --restart=always --name docker-registry \
  -e REGISTRY_STORAGE=s3 \
  -e REGISTRY_STORAGE_S3_BUCKET=kbseo-s3 \
  -e REGISTRY_STORAGE_S3_ACCESSKEY=AKIAJMYYWQIA****** \
  -e REGISTRY_STORAGE_S3_SECRETKEY=YTOwsm0lDgghwjRHtR************ \
  -e REGISTRY_STORAGE_S3_REGION=ap-northeast-2 \
  registry&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  이제 s3로 푸시해볼 차례입니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;# 어떤 이미지를 푸시해볼까....
[kbseo@ip-172-20-1-221 ~]$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
registry            latest              708bc6af7e5e        4 weeks ago         25.8MB
[kbseo@ip-172-20-1-221 ~]$ 

# 음.. 이미지를 다 지워서 push할 이미지가 없네요
# 만만한 hello-world 이미지를 받아봅니다.

[kbseo@ip-172-20-1-221 ~]$ docker pull hello-world
Using default tag: latest
latest: Pulling from library/hello-world
1b930d010525: Pull complete 
Digest: sha256:fc6a51919cfeb2e6763f62b6d9e8815acbf7cd2e476ea353743570610737b752
Status: Downloaded newer image for hello-world:latest
[kbseo@ip-172-20-1-221 ~]$ 
[kbseo@ip-172-20-1-221 ~]$ docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
registry                     latest              708bc6af7e5e        4 weeks ago         25.8MB
hello-world                  latest              fce289e99eb9        14 months ago       1.84kB
localhost:5000/hello-world   latest              fce289e99eb9        14 months ago       1.84kB


# tag를 지정해줍니다
# tag에 대해선 다음시간에 좀 더 자세히 다뤄보도록 하겠습니다.
[kbseo@ip-172-20-1-221 ~]$ docker tag hello-world localhost:5000/hello-world

# registry가 잘 돌아가고있네요
[kbseo@ip-172-20-1-221 ~]$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
274a07c0c008        registry            &quot;/entrypoint.sh /etc…&quot;   7 seconds ago       Up 6 seconds        0.0.0.0:5000-&amp;gt;5000/tcp   docker-registry
[kbseo@ip-172-20-1-221 ~]$ 



# s3에 올려볼 차례
[kbseo@ip-172-20-1-221 ~]$ docker push localhost:5000/hello-world
The push refers to repository [localhost:5000/hello-world]
af0b15c8625b: Pushed 
latest: digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a size: 524
[kbseo@ip-172-20-1-221 ~]$ 

&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  확인
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 잘 올라갔는지 s3로 가봅시다 총총총
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91690192/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 요기 올라와져있네여
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 사실상 Code →  Docker file → Docker Image 형태이기 때문에  이러한 과정에서 수정사항이 있으면 Docker file을 재작성 후 재빌드하고 이를 다시 Image화 하야하는데
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 천리길도 한걸음부터 라는 말이 있듯이!
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 이러한 과정은 다음시간에 이어서 소개해 드리겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Tue, 03 Mar 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/03/03/91690192/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/03/03/91690192/</guid>
        
        <category>docker</category>
        
        <category>dockerbasic</category>
        
        <category>dockercommand</category>
        
        <category>도커</category>
        
        <category>도커명령어</category>
        
        
      </item>
    
      <item>
        <title>[Container 시리즈] 01. 도커를 설치하고 실행해보자! Docker on Amazon Linux</title>
        <description>&lt;div class=&quot;confluence-information-macro confluence-information-macro-information conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;info&quot;&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   기존에 테스트용으로 사용하던 서버위에 설치
  &lt;/p&gt;
  &lt;p&gt;
   서버 환경 : Amazon Linux 2
  &lt;/p&gt;
  &lt;p&gt;
   서버 스펙 : t3.micro
  &lt;/p&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 안녕하세요 저번시간에 Container와 Docker에 대해서 간략하게 알아보는 시간을 가졌는데요
&lt;/p&gt;
&lt;p style=&quot;margin-left: 30.0px;&quot;&gt;
 지난 시간 글
 &lt;a href=&quot;/pages/viewpage.action?pageId=91690167&quot;&gt;
  [Container 시리즈] 00. Container/ Docker란 뭔가요?
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 아무래도 엔지니어분들은 직접 명령어를 쳐야 몸이 풀리기때문에
&lt;/p&gt;
&lt;p&gt;
 도커 설치하는 법 부터 가져왔습니다!
&lt;/p&gt;
&lt;p&gt;
 자 한번 설치를 시작해볼까요???
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-[Container시리즈]01.도커를설치하고실행해보자!DockeronAmazonLinux-1.테스트서버를간만에접속해서업데이트를먼저해줍니다.&quot;&gt;
 1.
 &lt;s&gt;
  테스트 서버를 간만에 접속해서
 &lt;/s&gt;
 업데이트를 먼저 해줍니다.
&lt;/h2&gt;
&lt;p&gt;
 $ sudo yum -y upgrade
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;[ec2-user@ip-172-20-1-221 ~]$ sudo yum -y upgrade 
Loaded plugins: extras_suggestions, langpacks, priorities, update-motd
amzn2-core                                                                                                  | 2.4 kB  00:00:00     
amzn2extra-docker                                                                                           | 1.3 kB  00:00:00     
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package amazon-ssm-agent.x86_64 0:2.3.662.0-1.amzn2 will be updated
---&amp;gt; Package amazon-ssm-agent.x86_64 0:2.3.714.0-1.amzn2 will be an update
---&amp;gt; Package at.x86_64 0:3.1.13-23.amzn2 will be updated

...

  sysstat.x86_64 0:10.1.5-18.amzn2.0.1                                  systemd.x86_64 0:219-57.amzn2.0.12                         
  systemd-libs.x86_64 0:219-57.amzn2.0.12                               systemd-sysv.x86_64 0:219-57.amzn2.0.12                    
  systemtap-runtime.x86_64 0:4.2-1.amzn2.0.1                            tcpdump.x86_64 14:4.9.2-4.amzn2.1                          
  yum.noarch 0:3.4.3-158.amzn2.0.3                                     

Replaced:
  kpatch.noarch 0:0.4.0-3.amzn2                               rpm-python.x86_64 0:4.11.3-25.amzn2.0.3                              

Complete!

&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-[Container시리즈]01.도커를설치하고실행해보자!DockeronAmazonLinux-2.Docker를설치해볼차례!&quot;&gt;
 2. Docker를 설치해볼차례!
&lt;/h2&gt;
&lt;p&gt;
 $ sudo amazon-linux-extras install -y docker
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;[ec2-user@ip-172-20-1-221 ~]$ sudo amazon-linux-extras install -y docker
Installing docker
Loaded plugins: extras_suggestions, langpacks, priorities, update-motd
Cleaning repos: amzn2-core amzn2extra-docker
10 metadata files removed
4 sqlite files removed
0 metadata files removed
Loaded plugins: extras_suggestions, langpacks, priorities, update-motd
amzn2-core                                                                                                  | 2.4 kB  00:00:00     
amzn2extra-docker                                                                                           | 1.3 kB  00:00:00     
(1/4): amzn2-core/2/x86_64/updateinfo                                                                       | 187 kB  00:00:00     
(2/4): amzn2-core/2/x86_64/group_gz                                                                         | 2.5 kB  00:00:00    

...

===================================================================================================================================
 Package                 Arch                Version                                          Repository                      Size
===================================================================================================================================
Installing:
 docker                  x86_64              18.09.9ce-2.amzn2                                amzn2extra-docker               30 M
Installing for dependencies:
 containerd              x86_64              1.2.6-1.amzn2                                    amzn2extra-docker               20 M
 libcgroup               x86_64              0.41-21.amzn2                                    amzn2-core                      66 k
 pigz                    x86_64              2.3.4-1.amzn2.0.1                                amzn2-core                      81 k
 runc                    x86_64              1.0.0-0.1.20190510.git2b18fe1.amzn2              amzn2extra-docker              2.0 M

Transaction Summary
===================================================================================================================================
Install  1 Package (+4 Dependent packages)

Total download size: 51 M
Installed size: 214 M
Downloading packages:
(1/5): libcgroup-0.41-21.amzn2.x86_64.rpm                                                                   |  66 kB  00:00:00     
(2/5): pigz-2.3.4-1.amzn2.0.1.x86_64.rpm                                                                    |  81 kB  00:00:00     
(3/5): containerd-1.2.6-1.amzn2.x86_64.rpm                                                                  |  20 MB  00:00:00     
(4/5): runc-1.0.0-0.1.20190510.git2b18fe1.amzn2.x86_64.rpm                                                  | 2.0 MB  00:00:00     
(5/5): docker-18.09.9ce-2.amzn2.x86_64.rpm                                                                  |  30 MB  00:00:00     
-----------------------------------------------------------------------------------------------------------------------------------
Total                                                                                               75 MB/s |  51 MB  00:00:00     

...


        [ =1.8.0_192  =1.8.0_202  =1.8.0_212  =1.8.0_222  =1.8.0_232
          =1.8.0_242 ]
 28  firecracker              available    [ =0.11 ]
 29  golang1.11               available    \
        [ =1.11.3  =1.11.11  =1.11.13 ]
 30  squid4                   available    [ =4 ]
 31  php7.3                   available    \
        [ =7.3.2  =7.3.3  =7.3.4  =7.3.6  =7.3.8  =7.3.9  =7.3.10
          =7.3.11  =7.3.13 ]
 32  lustre2.10               available    [ =2.10.5  =2.10.8 ]
 33  java-openjdk11           available    [ =11 ]
 34  lynis                    available    [ =stable ]
 35  kernel-ng                available    [ =stable ]
 36  BCC                      available    [ =0.x ]
 37  mono                     available    [ =5.x ]
 38  nginx1                   available    [ =stable ]
 39  ruby2.6                  available    [ =2.6 ]
 40  mock                     available    [ =stable ]
 41  postgresql11             available    [ =11 ]
[ec2-user@ip-172-20-1-221 ~]$ 

# 버전확인
[ec2-user@ip-172-20-1-221 ~]$ docker --version
Docker version 18.09.9-ce, build 039a7df
[ec2-user@ip-172-20-1-221 ~]$ 


&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;id-[Container시리즈]01.도커를설치하고실행해보자!DockeronAmazonLinux-3.설치를했으니돌려봅시다.&quot;&gt;
 3. 설치를 했으니 돌려봅시다.
&lt;/h2&gt;
&lt;p&gt;
 $ sudo systemctl start docker
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;
[ec2-user@ip-172-20-1-221 ~]$ sudo systemctl start docker

[ec2-user@ip-172-20-1-221 ~]$ ps -ef | grep docker
root     22846     1  1 08:23 ?        00:00:00 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --default-ulimit nofile=1024:4096
ec2-user 23025  4157  0 08:23 pts/0    00:00:00 grep --color=auto docker

&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;id-[Container시리즈]01.도커를설치하고실행해보자!DockeronAmazonLinux-4.ec2-user에게권한을..&quot;&gt;
 4. ec2-user에게 권한을..
&lt;/h2&gt;
&lt;p&gt;
 $ sudo usermod -aG docker ec2-user
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;
[ec2-user@ip-172-20-1-221 ~]$ sudo systemctl start docker

[ec2-user@ip-172-20-1-221 ~]$ ps -ef | grep docker
root     22846     1  1 08:23 ?        00:00:00 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --default-ulimit nofile=1024:4096
ec2-user 23025  4157  0 08:23 pts/0    00:00:00 grep --color=auto docker

# 적용을 위하여 다시 ssh 재접속을 합니다
# exit로 나간뒤 접속 ㄱㄱ
# sudo 명령어 없이 실행해봅니다.

[ec2-user@ip-172-20-1-221 ~]$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[ec2-user@ip-172-20-1-221 ~]$ &lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 + 번외로 docker는 Server-Client 구조입니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Eclipse&quot; data-theme=&quot;Eclipse&quot;&gt;# docker verision으로 각각의 버전확인 가능
[kbseo@ip-172-20-1-221 ~]$ docker version
Client:
 Version:           18.09.9-ce
 API version:       1.39
 Go version:        go1.10.3
 Git commit:        039a7df
 Built:             Fri Nov  1 19:26:49 2019
 OS/Arch:           linux/amd64
 Experimental:      false

Server:
 Engine:
  Version:          18.09.9-ce
  API version:      1.39 (minimum version 1.12)
  Go version:       go1.10.3
  Git commit:       039a7df
  Built:            Fri Nov  1 19:28:24 2019
  OS/Arch:          linux/amd64
  Experimental:     false

&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 설치를 완료하였으니
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 본격적으로 도커 사용법에 대해 알아보도록 하겠습니다!
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 다음 글에서 계속할께요....
&lt;/p&gt;</description>
        <pubDate>Tue, 03 Mar 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/03/03/91690190/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/03/03/91690190/</guid>
        
        <category>container</category>
        
        <category>containerized</category>
        
        <category>docker</category>
        
        <category>dockerinstall</category>
        
        <category>dockeronaws</category>
        
        <category>aws</category>
        
        <category>컨테이너</category>
        
        <category>도커</category>
        
        <category>도커설치</category>
        
        
      </item>
    
  </channel>
</rss>
