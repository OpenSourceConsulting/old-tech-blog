<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>오픈소스컨설팅 
기술 블로그
</title>
    <description>기술을 나눕니다. 함께 성장합니다.
Sharing Tech. Growing Together.
</description>
    <link>https://tech.osci.kr/</link>
    <atom:link href="https://tech.osci.kr/rss" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 03 Aug 2020 18:52:12 +0900</pubDate>
    <lastBuildDate>Mon, 03 Aug 2020 18:52:12 +0900</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>openstack helm을 이용한 kubernetes환경에서 openstack 배포</title>
        <description>&lt;p&gt;
 Openstack Helm을 Centos 환경에서  Ceph RBD로 구축 하는 방법에 대하여 이야기 합니다.
&lt;/p&gt;
&lt;p&gt;
 공식 매뉴얼이 Ubuntu 및 Swift기반이기 때문에 커스텀하게 수정한 부분이 다소 존재 합니다. 하지만, 기본 배경은 공식 문서(
 &lt;a class=&quot;external-link&quot; href=&quot;https://docs.openstack.org/openstack-helm/latest/&quot; rel=&quot;nofollow&quot;&gt;
  https://docs.openstack.org/openstack-helm/latest/
 &lt;/a&gt;
 )를 기반으로 작성 되었습니다.
&lt;/p&gt;
&lt;h2 id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-Openstackhelm?&quot;&gt;
 Openstack helm ?
&lt;/h2&gt;
&lt;p&gt;
 openstack helm은 이름에서 알수 있듯이 openstack을 kubernetes환경에서 helm chart를 이용하여 배포할 수 있는 프로젝트입니다. Kubernetes의 기본 기능인  Self-Healing 을 비롯하여 Kubernetes의 많은 장점들을 이용하여 Openstack을 관리 하기 때문에 확장등의 라이프 사이클 관리에 도움이 되며 을 구축, 업그레이드, 확장등의 관리를 손쉽게 할 수 있습니다. 대부분 AT&amp;amp;T를 주도적으로 99cloud , Suse등과 함께 국내에서는 SK Telecom이 많은 기여 하고 있는 프로젝트입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97477266/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;blockquote&gt;
 &lt;p&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.stackalytics.com/?module=openstack-helm-group&quot; rel=&quot;nofollow&quot;&gt;
   https://www.stackalytics.com/?module=openstack-helm-group
  &lt;/a&gt;
 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-환경설정&quot;&gt;
 환경 설정
&lt;/h2&gt;
&lt;p&gt;
 아래의 환경과 같이 Centos7의 동일한 운영체제를 사용하며, 총 5개의 NIC이 용도별로 설정 되어 있어야 합니다. 이중 001노드에서는 Kubernetes Master및 Ceph Monitor의 역할과 배포의 역할을 담당하게 됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97477266/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;table-wrap&quot;&gt;
 &lt;table class=&quot;wrapped fixed-table confluenceTable&quot;&gt;
  &lt;colgroup&gt;
   &lt;col style=&quot;width: 155.0px;&quot;/&gt;
   &lt;col style=&quot;width: 248.0px;&quot;/&gt;
   &lt;col style=&quot;width: 501.0px;&quot;/&gt;
   &lt;col style=&quot;width: 156.0px;&quot;/&gt;
  &lt;/colgroup&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;th class=&quot;confluenceTh&quot;&gt;
     hostname
    &lt;/th&gt;
    &lt;th class=&quot;confluenceTh&quot;&gt;
     OS
    &lt;/th&gt;
    &lt;th class=&quot;confluenceTh&quot;&gt;
     IP address
    &lt;/th&gt;
    &lt;th class=&quot;confluenceTh&quot;&gt;
     ETC
    &lt;/th&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td class=&quot;confluenceTd&quot;&gt;
     kube-cy4-kube001
    &lt;/td&gt;
    &lt;td class=&quot;confluenceTd&quot;&gt;
     CentOS Linux release 7.8.2003
    &lt;/td&gt;
    &lt;td class=&quot;confluenceTd&quot;&gt;
     &lt;p&gt;
      eth0 : 10.4.10.21 (API, Deploy )
     &lt;/p&gt;
     &lt;p&gt;
      eth1 : 10.4.20.21 (Ceph Storage Public  )
     &lt;/p&gt;
     &lt;p&gt;
      eth2 : 10.4.30.21 (Ceph Storage Replication )
     &lt;/p&gt;
     &lt;p&gt;
      eth3 : 10.4.40.21 (Openstack Tanent Network )
     &lt;/p&gt;
     &lt;p&gt;
      eth4 : 192.168.193.21 (Openstack External Netowkr: Provider Network )
     &lt;/p&gt;
    &lt;/td&gt;
    &lt;td class=&quot;confluenceTd&quot;&gt;
     &lt;p&gt;
      Kubernetes Master
     &lt;/p&gt;
     &lt;p&gt;
      Ceph Monitor
     &lt;/p&gt;
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td class=&quot;confluenceTd&quot;&gt;
     kube-cy4-kube002
    &lt;/td&gt;
    &lt;td class=&quot;confluenceTd&quot;&gt;
     CentOS Linux release 7.8.2003
    &lt;/td&gt;
    &lt;td class=&quot;confluenceTd&quot;&gt;
     &lt;p&gt;
      eth0 : 10.4.20.22 (API, Deploy )
     &lt;/p&gt;
     &lt;p&gt;
      eth1 : 10.4.20.22 (Ceph Storage Public  )
     &lt;/p&gt;
     &lt;p&gt;
      eth2 : 10.4.30.22 (Ceph Storage Replication )
     &lt;/p&gt;
     &lt;p&gt;
      eth3 : 10.4.40.22 (Openstack Tanent Network )
     &lt;/p&gt;
     &lt;p&gt;
      eth4 : 192.168.193.22 (Openstack External Netowkr: Provider Network )
     &lt;/p&gt;
    &lt;/td&gt;
    &lt;td class=&quot;confluenceTd&quot;&gt;
     &lt;p&gt;
      Kubernetes Worker
     &lt;/p&gt;
     &lt;p&gt;
      Ceph OSD
     &lt;/p&gt;
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td class=&quot;confluenceTd&quot;&gt;
     kube-cy4-kube003
    &lt;/td&gt;
    &lt;td class=&quot;confluenceTd&quot;&gt;
     CentOS Linux release 7.8.2003
    &lt;/td&gt;
    &lt;td class=&quot;confluenceTd&quot;&gt;
     &lt;p&gt;
      eth0 : 10.4.10.23 (API, Deploy )
     &lt;/p&gt;
     &lt;p&gt;
      eth1 : 10.4.20.23 (Ceph Storage Public  )
     &lt;/p&gt;
     &lt;p&gt;
      eth2 : 10.4.30.23 (Ceph Storage Replication )
     &lt;/p&gt;
     &lt;p&gt;
      eth3 : 10.4.40.23 (Openstack Tanent Network )
     &lt;/p&gt;
     &lt;p&gt;
      eth4 : 192.168.193.23 (Openstack External Netowkr: Provider Network )
     &lt;/p&gt;
    &lt;/td&gt;
    &lt;td class=&quot;confluenceTd&quot;&gt;
     &lt;p&gt;
      Kubernetes Worker
     &lt;/p&gt;
     &lt;p&gt;
      Ceph OSD
     &lt;/p&gt;
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;
     kube-cy4-kube004
    &lt;/td&gt;
    &lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;
     CentOS Linux release 7.8.2003
    &lt;/td&gt;
    &lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;
     &lt;p&gt;
      eth0 : 10.4.10.24 (API, Deploy )
     &lt;/p&gt;
     &lt;p&gt;
      eth1 : 10.4.20.24 (Ceph Storage Public  )
     &lt;/p&gt;
     &lt;p&gt;
      eth2 : 10.4.30.24 (Ceph Storage Replication )
     &lt;/p&gt;
     &lt;p&gt;
      eth3 : 10.4.40.24 (Openstack Tanent Network )
     &lt;/p&gt;
     &lt;p&gt;
      eth4 : 192.168.193.24 (Openstack External Netowkr: Provider Network )
     &lt;/p&gt;
    &lt;/td&gt;
    &lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;
     &lt;p&gt;
      Kubernetes Worker
     &lt;/p&gt;
     &lt;p&gt;
      Ceph OSD
     &lt;/p&gt;
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
&lt;/div&gt;
&lt;h2 class=&quot;auto-cursor-target&quot; id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-DeployCeph&quot;&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  Deploy Ceph
 &lt;/span&gt;
&lt;/h2&gt;
&lt;p&gt;
 Ceph는 RBD형태로 Openstack상에서 볼륨을 사용하거나 인스턴스를 이용할 경우 사용되는 스토리지로 사용되며, Kubernetes상에 배포되는 Openstack-helm-infra의 Mariadb,RabbitMQ의 PV로 사용 됩니다.
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 배포에 필요한 스크립트는
 &lt;em&gt;
  &quot;/hoem/deploy&quot;
 &lt;/em&gt;
 에서 관리하기 위하여 해당 디렉토리를 생성하며, 프로젝트를 클론 받기 위하여  git과 배포시 필요한 파이선 패키지 관리를 위하여  pip 패키지를 설치합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ~]# mkdir  /home/deploy ; cd  /home/deploy
[root@kube-cy4-kube001 deploy]# yum install -y git epel*
[root@kube-cy4-kube001 deploy]# yum install -y python-pip&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 ceph 배포를 위하여  ceph-ansible을 클론받고, v4.0.20 로 checkout합니다. 그리고 배포를 위한 파이선 패키지 설치를 위하여 requirements.txt 파일을 기반으로 파이선 패키지를 설치 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 deploy]# git clone https://github.com/ceph/ceph-ansible.git
[root@kube-cy4-kube001 deploy]# cd ceph-ansible/
[root@kube-cy4-kube001 ceph-ansible]# git checkout v4.0.20
[root@kube-cy4-kube001 ceph-ansible]# pip install -r requirements.txt&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 ceph은 ansible을 통하여 배포하기 때문에 deploy 인터페이스 아이피로
 &lt;em&gt;
  &quot;/etc/hosts&quot;
 &lt;/em&gt;
 파일을 수정 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ceph-ansible]# tee /etc/hosts &amp;lt;&amp;lt; EOF
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
10.4.10.21 kube-cy4-kube001 kube1
10.4.10.22 kube-cy4-kube003 kube2
10.4.10.23 kube-cy4-kube002 kube3
10.4.10.24 kube-cy4-kube004 kube4
EOF&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 ceph-ansible에서 각 역할별로 구분하여 배포 하기 때문에 Group 별로 나눠 ceph-ansible의 inventory파일을 생성하며, 해당 inventory파일로 통신이 되는지 확인 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ceph-ansible]# tee ./ceph-hosts &amp;lt;&amp;lt; EOF
[mons]
kube-cy4-kube001
[osds]
kube-cy4-kube002
kube-cy4-kube003
kube-cy4-kube004
[mdss]
[rgws]
[nfss]
[rbdmirrors]
[clients]
kube-cy4-kube001
[mgrs]
kube-cy4-kube001
[iscsigws]
[iscsi-gws]
[grafana-server]
[rgwloadbalancers]
[all:vars]
ansible_become=true
#### 설정된 User로 변경 필요
ansible_user=centos
#### 설정된 Password로 변경 필요
ansible_ssh_pass=password
EOF

[root@kube-cy4-kube001 ceph-ansible]# yum install -y sshpass
[root@kube-cy4-kube001 ceph-ansible]# ansible -i ceph-hosts -m ping  all
kube-cy4-kube003 | SUCCESS =&amp;gt; {
    &quot;ansible_facts&quot;: {
        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;
    },
    &quot;changed&quot;: false,
    &quot;ping&quot;: &quot;pong&quot;
}
kube-cy4-kube002 | SUCCESS =&amp;gt; {
    &quot;ansible_facts&quot;: {
        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;
    },
    &quot;changed&quot;: false,
    &quot;ping&quot;: &quot;pong&quot;
}
...&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 group_vars/all.yml 파일은 ceph-ansible을 이용하여 배포시 설정할 수 있는 전반적인 배포 변수를 설정합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ceph-ansible]# tee  group_vars/all.yml &amp;lt;&amp;lt; EOF
osd_scenario: lvm
osd_objectstore: bluestore

## monitor로 통신할 인터페이스로 실제 rbd를 사용할 경우 해당 인터페이스를 사용하게 됩니다.
monitor_interface: eth1
## monitor_interface 에 설정되어 있는 ip 대역으로 설정
public_network: 10.4.20.0/24
## 각 osd마다 복제를 위해 사용하는 인터페이스의 ip 대역으로 설정 합니다.
cluster_network: 10.4.30.0/24

ceph_stable_release: nautilus
ceph_origin: repository
ceph_repository: community
ceph_mirror: http://download.ceph.com
ceph_stable_key: https://download.ceph.com/keys/release.asc

ntp_service_enabled: true
osd_auto_discovery: false
dashboard_enabled: false
cluster: ceph
ceph_conf_overrides:
  global:
    mon_allow_pool_delete: false
    mon_osd_down_out_subtree_limit: host
    osd_pool_default_size: 2
    osd_pool_default_min_size: 1
  osd:
    osd_min_pg_log_entries: 10
    osd_max_pg_log_entries: 10
    osd_pg_log_dups_tracked: 10
    osd_pg_log_trim_min: 10
EOF&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 osds.yml 에서는 실제 osd로 사용할 디바이스를 지정합니다. osd 노드의 연결되어 있는 디바이스를 확인후 아래와 같이 osds.yml파일을 설정합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ceph-ansible]# ansible -i ceph-hosts  -ba 'lsblk' osds
kube-cy4-kube004 | CHANGED | rc=0 &amp;gt;&amp;gt;
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sr0     11:0    1  366K  0 rom
vda    253:0    0   68G  0 disk
└─vda1 253:1    0   68G  0 part /
vdb    253:16   0   40G  0 disk
vdc    253:32   0   40G  0 disk
kube-cy4-kube002 | CHANGED | rc=0 &amp;gt;&amp;gt;
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sr0     11:0    1  366K  0 rom
vda    253:0    0   68G  0 disk
└─vda1 253:1    0   68G  0 part /
vdb    253:16   0   40G  0 disk
vdc    253:32   0   40G  0 disk
kube-cy4-kube003 | CHANGED | rc=0 &amp;gt;&amp;gt;
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sr0     11:0    1  366K  0 rom
vda    253:0    0   68G  0 disk
└─vda1 253:1    0   68G  0 part /
vdb    253:16   0   40G  0 disk
vdc    253:32   0   40G  0 disk

[root@kube-cy4-kube001 ceph-ansible]# tee  group_vars/osds.yml &amp;lt;&amp;lt; EOF
---
devices:
 - /dev/vdb
 - /dev/vdc
EOF&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 clients.yml 파일에 admin key를 복사하여 ceph client명령이 수행할 수 있도록 설정 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-deploy ceph-ansible]#  tee  group_vars/clients.yml &amp;lt;&amp;lt; EOF
---
copy_admin_key: true
EOF&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 site.yml.sample 을 이용하여 설정한 group_vars의 변수를 기반으로 ansible-playbook 명령을 이용하여 ceph를 배포합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[[root@kube-cy4-kube001 ceph-ansible]# ansible-playbook  -i ceph-hosts  site.yml.sample&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-warning conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;warning&quot;&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-error confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   만약 아래와 같은 에러가 발생하여 정상적으로 설치가 안되는 경우가 발생할 수 있습니다.
  &lt;/p&gt;
  &lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
   &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
    &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;...
TASK [check for python] *******************************************************************************
Saturday 01 August 2020  15:46:14 +0900 (0:00:00.058)       0:00:00.058 *******
fatal: [kube-cy4-kube001]: FAILED! =&amp;gt;
  msg: The ips_in_ranges filter requires python's netaddr be installed on the ansible controller.
fatal: [kube-cy4-kube002]: FAILED! =&amp;gt;
  msg: The ips_in_ranges filter requires python's netaddr be installed on the ansible controller.
fatal: [kube-cy4-kube003]: FAILED! =&amp;gt;
  msg: The ips_in_ranges filter requires python's netaddr be installed on the ansible controller.
fatal: [kube-cy4-kube004]: FAILED! =&amp;gt;
  msg: The ips_in_ranges filter requires python's netaddr be installed on the ansible controller.
...&lt;/pre&gt;
   &lt;/div&gt;
  &lt;/div&gt;
  &lt;p class=&quot;auto-cursor-target&quot;&gt;
   배포하는 호스트에서 netaddr 패키지를 설치한뒤 다시 배포를 진행 하면 정상적으로 배포가 진행됩니다.
  &lt;/p&gt;
  &lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
   &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
    &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ceph-ansible]# yum install python-netaddr.noarch -y&lt;/pre&gt;
   &lt;/div&gt;
  &lt;/div&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-warning conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;warning&quot;&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-error confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   만약, ceph cluster를 삭제 하기 위해서는 아래와 같이 purge-cluster.yml  플레이북을 실행하여 삭제할 수 있습니다.
  &lt;/p&gt;
  &lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
   &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
    &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ceph-ansible]# ansible-playbook  -i ceph-hosts infrastructure-playbooks/purge-cluster.yml &lt;/pre&gt;
   &lt;/div&gt;
  &lt;/div&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 배포가 완료 되면
 &lt;em&gt;
  &quot;ceph -s
 &lt;/em&gt;
 &quot;명령을 이용하여 &quot;
 &lt;em&gt;
  health: HEALTH_OK&quot;
 &lt;/em&gt;
 상태를 확인 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ceph-ansible]# ceph -s
  cluster:
    id:     f9b17cb6-b38c-455b-b10d-5c44d7bcc36b
    health: HEALTH_OK

  services:
    mon: 1 daemons, quorum kube-cy4-kube001 (age 3m)
    mgr: kube-cy4-kube001(active, since 2m)
    osd: 6 osds: 6 up (since 85s), 6 in (since 98s)

  data:
    pools:   0 pools, 0 pgs
    objects: 0 objects, 0 B
    usage:   6.0 GiB used, 234 GiB / 240 GiB avail
    pgs:&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h2 class=&quot;auto-cursor-target&quot; id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-InstallDocker&quot;&gt;
 Install Docker
&lt;/h2&gt;
&lt;p&gt;
 Kubernetes를 배포하기전 Container Runtime으로 사용될 Docker를 설치 합니다.
&lt;/p&gt;
&lt;p&gt;
 아래와 같이 docker-ce repository를 등록한뒤 docker-ce를 yum으로 설치 합니다. 해당 과정은 모든 노드에서 진행 하게 됩니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ~]# yum install -y yum-utils

[root@kube-cy4-kube001 ~]# yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo

[root@kube-cy4-kube001 ~]# yum install docker-ce docker-ce-cli containerd.io

[root@kube-cy4-kube001 ~]# systemctl enable --now  docker

[root@kube-cy4-kube001 ~]# systemctl  status docker
● docker.service - Docker Application Container Engine
   Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)
   Active: active (running) since Sat 2020-08-01 13:56:13 KST; 2h 34min ago
     Docs: https://docs.docker.com
 Main PID: 1368 (dockerd)
    Tasks: 15
   Memory: 147.2M
   CGroup: /system.slice/docker.service
           └─1368 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
...&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h2 class=&quot;auto-cursor-target&quot; id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-DeployKubernetes&quot;&gt;
 Deploy Kubernetes
&lt;/h2&gt;
&lt;p&gt;
 kubernetes를 설치하기 위해서 kubeadm을 사용할것 입니다. kubeadm설치와 kubelet설치를 위하여 kubernetes upstream repository를 등록 하여 kubeadm,kubelet를 설치 합니다.
&lt;/p&gt;
&lt;p&gt;
 해당 설치는 모든 호스트에서 진행 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ~]#  cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg
        https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
EOF
 
[root@kube-cy4-kube001 ~]# yum install kubeadm  -y
[root@kube-cy4-kube001 ~]#  systemctl enable kubelet --now&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;em&gt;
  &quot;kubeadm init &quot;
 &lt;/em&gt;
 명령을 이용하여 master노드로 사용할 kube-cy4-kube001 호스트에서 초기화 과정을 진행 합니다.
&lt;/p&gt;
&lt;p&gt;
 이때 kubernetes api를 사용할 인터페이스인 eth0의 ip로 &quot;
 &lt;em&gt;
  --apiserver-advertise-address&quot;
 &lt;/em&gt;
 옵션을 추가 하며, pod들이 통신하기 위하여 사용되는 네트워크 cidr를 172.16.0.0/16으로 진행 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ~]# echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
[root@kube-cy4-kube001 ~]# kubeadm init  --apiserver-advertise-address=10.4.10.21  --pod-network-cidr=172.16.0.0/16&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 정상적으로 진행 되었습니다면 아래와 같이
 &lt;em&gt;
  &quot;initialized successfully&quot;
 &lt;/em&gt;
 메시지를 확인할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 마지막에 나온 hash 값을 통하여 다른 노드들이 join할 수 있도록 메시지를 출력한것을 확인 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;...
Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 10.4.10.21:6443 --token 26amyi.687200qzjh5lkkxw \
    --discovery-token-ca-cert-hash sha256:e1a4959da94c40d0d21aaf8fb39878608c0002a4a6be6122bc8fa3d116b5db9f&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 위에서 중간에 나온 메시지 처럼  master노드인 kube-cy4-kube001 에서 kubernetes clinet를 위해 사용되는 kube config파일을 복사하도록 하여 kubernetes clinet(kubectl)을 실행하여 봅니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ~]#   mkdir -p $HOME/.kube
[root@kube-cy4-kube001 ~]#   sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
[root@kube-cy4-kube001 ~]#   sudo chown $(id -u):$(id -g) $HOME/.kube/config
[root@kube-cy4-kube001 ~]# kubectl get nodes
NAME               STATUS     ROLES    AGE     VERSION
kube-cy4-kube001   NotReady   master   2m45s   v1.18.6&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 kube-cy4-kube002 노드에서  master 노드로 join을 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube002 ~]# echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
[root@kube-cy4-kube002 ~]# kubeadm join 10.4.10.21:6443 --token 26amyi.687200qzjh5lkkxw \
&amp;gt;     --discovery-token-ca-cert-hash sha256:e1a4959da94c40d0d21aaf8fb39878608c0002a4a6be6122bc8fa3d116b5db9f&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 kube-cy4-kube003 노드에서  master 노드로 join을 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube003 ~]# echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
[root@kube-cy4-kube003 ~]# kubeadm join 10.4.10.21:6443 --token 26amyi.687200qzjh5lkkxw \
&amp;gt;     --discovery-token-ca-cert-hash sha256:e1a4959da94c40d0d21aaf8fb39878608c0002a4a6be6122bc8fa3d116b5db9f&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 kube-cy4-kube004 노드에서  master 노드로 join을 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube004 ~]# echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
[root@kube-cy4-kube004 ~]# kubeadm join 10.4.10.21:6443 --token 26amyi.687200qzjh5lkkxw \
&amp;gt;     --discovery-token-ca-cert-hash sha256:e1a4959da94c40d0d21aaf8fb39878608c0002a4a6be6122bc8fa3d116b5db9f&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 다시 master노드로 들어와서  &quot;kubectl get nodes -o wide&quot; 명령을 수행하여 join된  노드를 확인할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 하지만 아직 CNI(Container Network Interface)가 설정이 안되어 있기 때문에  STATUS 가 아직 NotReady 상태입니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ~]# kubectl get nodes -o wide
NAME               STATUS     ROLES    AGE    VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION                CONTAINER-RUNTIME
kube-cy4-kube001   NotReady   master   6m8s   v1.18.6   10.4.10.21    &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-1127.13.1.el7.x86_64   docker://19.3.12
kube-cy4-kube002   NotReady   &amp;lt;none&amp;gt;   40s    v1.18.6   10.4.20.22    &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-1127.13.1.el7.x86_64   docker://19.3.12
kube-cy4-kube003   NotReady   &amp;lt;none&amp;gt;   38s    v1.18.6   10.4.20.23    &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-1127.13.1.el7.x86_64   docker://19.3.12
kube-cy4-kube004   NotReady   &amp;lt;none&amp;gt;   36s    v1.18.6   10.4.20.24    &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-1127.13.1.el7.x86_64   docker://19.3.12&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-DeployCalico&quot;&gt;
 Deploy Calico
&lt;/h2&gt;
&lt;p&gt;
 calico배포를 위한 매니패스트를 다운로드 한뒤 pod 네트워크를 위한 인터페이스 추가 및 IP in IP 모드를 Never로 변경하여 L2 통신간에 encapsulation없이 통신하도록 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ~]# mkdir /home/deploy/calico ; cd /home/deploy/calico
[root@kube-cy4-kube001 calico]# yum install -y wget
[root@kube-cy4-kube001 calico]# wget https://docs.projectcalico.org/manifests/calico.yaml
[root@kube-cy4-kube001 calico]# vi calico.yaml
...
      containers:
        # Runs calico-node container on each Kubernetes node. This
        # container programs network policy and routes on each
        # host.
        - name: calico-node
          image: calico/node:v3.15.1
          env:
            ### pod네트워크 인터페이스 추가 
            - name: IP_AUTODETECTION_METHOD
              value: &quot;interface=eth0&quot;
            # Use Kubernetes API as the backing datastore.
            - name: DATASTORE_TYPE
              value: &quot;kubernetes&quot;
            # Wait for the datastore.
            - name: WAIT_FOR_DATASTORE
              value: &quot;true&quot;
            # Set based on the k8s node name.
....
            ### IP in IP 모드를 사용하지 않도록 하기 위하여 Always를 Never로 변경
            - name: CALICO_IPV4POOL_IPIP
            #  value: &quot;Always&quot;
              value: &quot;Never&quot;
[root@kube-cy4-kube001 calico]# kubectl  create -f calico.yaml&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 이제, calico-system namespace에 pod들이 정상적으로 동작하는것을 확인할 수 있으며, &quot;
 &lt;em&gt;
  kubectl get nodes&quot;
 &lt;/em&gt;
 명령 수행시 Ready 상태로 변경된것을 확인할 수 있습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 calico]#  kubectl get pods -n calico-system -o wide
NAME                                       READY   STATUS    RESTARTS   AGE    IP              NODE               NOMINATED NODE   READINESS GATES
calico-kube-controllers-5687f44fd5-nj49z   1/1     Running   0          2m8s   172.16.10.130   kube-cy4-kube004   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
calico-node-48lw6                          1/1     Running   0          2m8s   10.4.20.24      kube-cy4-kube004   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
calico-node-6kt28                          1/1     Running   0          2m8s   10.4.10.21      kube-cy4-kube001   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
calico-node-jpqf5                          1/1     Running   0          2m8s   10.4.20.23      kube-cy4-kube003   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
calico-node-lh7fp                          1/1     Running   0          2m8s   10.4.20.22      kube-cy4-kube002   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
calico-typha-7648bcdddb-4cblz              1/1     Running   0          60s    10.4.20.22      kube-cy4-kube002   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
calico-typha-7648bcdddb-4mjvp              1/1     Running   0          60s    10.4.20.24      kube-cy4-kube004   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
calico-typha-7648bcdddb-5qz8m              1/1     Running   0          2m8s   10.4.20.23      kube-cy4-kube003   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
calico-typha-7648bcdddb-kq5q6              1/1     Running   0          60s    10.4.10.21      kube-cy4-kube001   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;

[root@kube-cy4-kube001 calico]# kubectl  get nodes -o wide
NAME               STATUS   ROLES    AGE   VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION                CONTAINER-RUNTIME
kube-cy4-kube001   Ready    master   24m   v1.18.6   10.4.10.21    &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-1127.13.1.el7.x86_64   docker://19.3.12
kube-cy4-kube002   Ready    &amp;lt;none&amp;gt;   19m   v1.18.6   10.4.20.22    &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-1127.13.1.el7.x86_64   docker://19.3.12
kube-cy4-kube003   Ready    &amp;lt;none&amp;gt;   19m   v1.18.6   10.4.20.23    &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-1127.13.1.el7.x86_64   docker://19.3.12
kube-cy4-kube004   Ready    &amp;lt;none&amp;gt;   18m   v1.18.6   10.4.20.24    &amp;lt;none&amp;gt;        CentOS Linux 7 (Core)   3.10.0-1127.13.1.el7.x86_64   docker://19.3.12&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 calicoctl 바이너리를 다운로드 받아 calico cni 가 제어할 pod들의 ippool의 목록과 bgp peer정보를 확인 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 calico]# curl -O -L  https://github.com/projectcalico/calicoctl/releases/download/v3.15.1/calicoctl
[root@kube-cy4-kube001 calico]# chmod +x calicoctl
[root@kube-cy4-kube001 calico]# sudo mv calicoctl /usr/local/bin/
[root@kube-cy4-kube001 calico]# tee /root/calico.rc &amp;lt;&amp;lt; EOF
export KUBECONFIG=/root/.kube/config
export DATASTORE_TYPE=kubernetes
EOF
[root@kube-cy4-kube001 calico]# source  ~/calico.rc
[root@kube-cy4-kube001 calico]# calicoctl get ippools
NAME                  CIDR            SELECTOR
default-ipv4-ippool   172.16.0.0/16   all()

[root@kube-cy4-kube001 calico]# calicoctl get nodes -o wide
NAME               ASN       IPV4            IPV6
kube-cy4-kube001   (64512)   10.4.10.21/24
kube-cy4-kube002   (64512)   10.4.10.22/24
kube-cy4-kube003   (64512)   10.4.10.23/24
kube-cy4-kube004   (64512)   10.4.10.24/24&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 실제 pod통신은 아래와 같이 eth0인터페이스를 통하여 172.16.0.0/16 대역에서 각 노드별 block 대역으로 직접 라우팅 되는것을 확인할 수 있습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 calico]# route -n | grep 172.16
172.16.10.128   10.4.10.24      255.255.255.192 UG    0      0        0 eth0
172.16.39.128   10.4.10.22      255.255.255.192 UG    0      0        0 eth0
172.16.43.192   10.4.10.23      255.255.255.192 UG    0      0        0 eth0&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-InstallHelm&quot;&gt;
 Install Helm
&lt;/h2&gt;
&lt;p&gt;
 openstack helm과 openstack helm infra는 helm기반으로 배포가 되기 때문에 helm을 설치 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ~ ]#  curl -LO https://git.io/get_helm.sh
[root@kube-cy4-kube001 ~ ]#  chmod 700 get_helm.sh
[root@kube-cy4-kube001 ~ ]#  ./get_helm.sh
[root@kube-cy4-kube001 ~ ]# kubectl create serviceaccount --namespace kube-system tiller
[root@kube-cy4-kube001 ~ ]# kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller
[root@kube-cy4-kube001 ~ ]# kubectl patch deploy --namespace kube-system tiller-deploy -p '{&quot;spec&quot;:{&quot;template&quot;:{&quot;spec&quot;:{&quot;serviceAccount&quot;:&quot;tiller&quot;}}}}'
[root@kube-cy4-kube001 ~ ]# helm init --service-account tiller --upgrade
[root@kube-cy4-kube001 ~ ]# helm version
Client: &amp;amp;version.Version{SemVer:&quot;v2.16.9&quot;, GitCommit:&quot;8ad7037828e5a0fca1009dabe290130da6368e39&quot;, GitTreeState:&quot;clean&quot;}
Server: &amp;amp;version.Version{SemVer:&quot;v2.16.9&quot;, GitCommit:&quot;8ad7037828e5a0fca1009dabe290130da6368e39&quot;, GitTreeState:&quot;clean&quot;}&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 local helm repository를 등록 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ~ ]#  tee /etc/systemd/system/helm-serve.service &amp;lt;&amp;lt;EOF
[Unit]
Description=Helm Server
After=network.target
 
[Service]
User=root
Restart=always
ExecStart=/usr/local/bin/helm serve
 
[Install]
WantedBy=multi-user.target
EOF

[root@kube-cy4-kube001 ~ ]#  systemctl daemon-reload ; systemctl enable helm-serve --now
[root@kube-cy4-kube001 calico]# helm repo list
NAME 	URL
local	http://localhost:8879/charts&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-SettingCSI(CephRBD)&quot;&gt;
 Setting CSI(Ceph RBD)
&lt;/h2&gt;
&lt;p&gt;
 앞에서 배포한 ceph cluster 를 kubernetes에서 storage class를 총하여 pv를 생성하기 위하여 csi를 설정 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;em&gt;
  &quot;ceph mon dump&quot;
 &lt;/em&gt;
 명령을 이용하여 cluster fsid를 확인합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ~]# ceph mon dump
dumped monmap epoch 1
epoch 1
fsid f9b17cb6-b38c-455b-b10d-5c44d7bcc36b
last_changed 2020-08-01 16:23:11.258185
created 2020-08-01 16:23:11.258185
min_mon_release 14 (nautilus)
0: [v2:10.4.20.21:3300/0,v1:10.4.20.21:6789/0] mon.kube-cy4-kube001&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 storage class로 사용할 &quot;kubernetes&quot;이름의 pool을 생성하며, kubernetes pool 인증에 사용할 kubernetes유저를 생성합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ~]# ceph osd pool create kubernetes 64 64
pool 'kubernetes' created
[root@kube-cy4-kube001 ~]# rbd pool init kubernetes
[root@kube-cy4-kube001 ~]# ceph auth get-or-create client.kubernetes mon 'profile rbd' osd 'profile rbd pool=kubernetes'
[client.kubernetes]
	key = AQBMeiVf1CKrHBAAYeIVScZlRiDo6D58xvPM4Q==&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 ceph-csi 프로젝트를 클론 받는다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ~]# cd /home/deploy/
[root@kube-cy4-kube001 deploy]# git clone https://github.com/ceph/ceph-csi.git ; cd ceph-csi/&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 csi-config-map에서는 앞에서 확인한 fsid와 초기 ceph구성시 monitor로 지정한 노드의 public network 대역의 아이피로 수정 한뒤 configmap을 적용합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ceph-csi]# vi deploy/rbd/kubernetes/csi-config-map.yaml 
---
apiVersion: v1
kind: ConfigMap
data:
  config.json: |-
    [
      {
##### fsid 
        &quot;clusterID&quot;: &quot;f9b17cb6-b38c-455b-b10d-5c44d7bcc36b&quot;,
        &quot;monitors&quot;: [
##### Monitor 호스트의 아이피
          &quot;10.4.20.21:6789&quot;
        ]
      }
    ]
metadata:
  name: ceph-csi-config
[root@kube-cy4-kube001 ceph-csi]# kubectl  create -f deploy/rbd/kubernetes/csi-config-map.yaml&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 secret에는 앞에서 생성한 pool에 인증하기 위한 userkey와 id를 추가 한뒤 secret을 생성 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ceph-csi]# vi examples/rbd/secret.yaml
---
apiVersion: v1
kind: Secret
metadata:
  name: csi-rbd-secret
  namespace: default
stringData:
  # Key values correspond to a user name and its key, as defined in the
  # ceph cluster. User ID should have required access to the 'pool'
  # specified in the storage class
  #userID: &amp;lt;plaintext ID&amp;gt;
  userID: kubernetes
  #userKey: &amp;lt;Ceph auth key corresponding to ID above&amp;gt;
  userKey: AQBMeiVf1CKrHBAAYeIVScZlRiDo6D58xvPM4Q==

  # Encryption passphrase
  encryptionPassphrase: test_passphrase

[root@kube-cy4-kube001 ceph-csi]# kubectl  create -f  examples/rbd/secret.yaml&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 pool은 앞서 생성한 pool의 이름으로, clusterID는 ceph fsid를 입력합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ceph-csi]# vi  examples/rbd/storageclass.yaml
...

   #clusterID: &amp;lt;cluster-id&amp;gt;
   clusterID: f9b17cb6-b38c-455b-b10d-5c44d7bcc36b
   # If you want to use erasure coded pool with RBD, you need to create
   # two pools. one erasure coded and one replicated.
   # You need to specify the replicated pool here in the `pool` parameter, it is
   # used for the metadata of the images.
   # The erasure coded pool must be set as the `dataPool` parameter below.
   # dataPool: ec-data-pool
   #pool: rbd
   pool: kubernetes
...
[root@kube-cy4-kube001 ceph-csi]# kubectl create -f examples/rbd/storageclass.yaml&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 ceph-csi가 vault를 이용한 키관리를 하기 때문에 해당부분을 적용합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ceph-csi]# kubectl create -f examples/kms/vault/kms-config.yaml&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 이제 적용한 내용으로 plugin을 배포 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ceph-csi]# cd examples/rbd/
[root@kube-cy4-kube001 rbd]# ./plugin-deploy.sh&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 정상적으로 배포가 완료 되었습니다면 아래와 같이 pod를 확인할 수 있으며, storage class를 이용하여 pvc를 정상적으로 생성할 수 있습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 rbd]# kubectl  get pod
NAME                                        READY   STATUS    RESTARTS   AGE
csi-rbdplugin-2m68m                         3/3     Running   0          19s
csi-rbdplugin-8xfpd                         3/3     Running   0          19s
csi-rbdplugin-provisioner-b77dfc64c-469b6   6/6     Running   0          20s
csi-rbdplugin-provisioner-b77dfc64c-lwgg9   6/6     Running   0          20s
csi-rbdplugin-provisioner-b77dfc64c-wnxkt   6/6     Running   0          20s
csi-rbdplugin-r9v28                         3/3     Running   0          19s


[root@kube-cy4-kube001 rbd]# kubectl  get sc
NAME         PROVISIONER        RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
csi-rbd-sc   rbd.csi.ceph.com   Delete          Immediate           true                   79s

[root@kube-cy4-kube001 rbd]# cd /home/deploy/ceph-csi/
[root@kube-cy4-kube001 ceph-csi]# kubectl create -f examples/rbd/pvc.yaml
[root@kube-cy4-kube001 ceph-csi]# kubectl  get pvc
NAME      STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
rbd-pvc   Bound    pvc-a33aeeec-e51a-463a-a708-f6ede4dbbc8a   1Gi        RWO            csi-rbd-sc     3s&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 ceph cluster에서 rbd명령을 이용하여 해당 이미지를 확인할 수 있습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ceph-csi]# rbd ls -p kubernetes
csi-vol-91ae5b24-d477-11ea-8fdb-1a270cdb0b8f&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-DeployOpenstackHelm/Helminfra&quot;&gt;
 Deploy Openstack Helm/Helm infra
&lt;/h2&gt;
&lt;p&gt;
 openstack helm,helm infra배포를 하기전 배포를 진행하는 노드에서 필요한 패키지를 설치 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 ~]# yum install git jq python2-pip gcc python-devel -y&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 openstack helm,helm infra 프로젝트를 clone합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 deploy]# git clone https://opendev.org/openstack/openstack-helm.git
[root@kube-cy4-kube001 deploy]# git clone https://opendev.org/openstack/openstack-helm-infra.git&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 각 프로젝트에서 make all 명령을 수행합니다. 수행이 완료되면 앞서 생성한 local helm repository에 각 차트들이 업로드 됩니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 deploy]# cd openstack-helm ; make all
[root@kube-cy4-kube001 openstack-helm]# cd ../openstack-helm-infra ; make all

[root@kube-cy4-kube001 openstack-helm-infra]# helm search
NAME                                  	CHART VERSION	APP VERSION	DESCRIPTION
local/aodh                            	0.1.0        	           	Openstack-Helm Aodh
local/barbican                        	0.1.0        	           	OpenStack-Helm Barbican
local/ca-issuer                       	0.1.0        	1.0        	Certificate Issuer chart for OSH
local/calico                          	0.1.0        	           	OpenStack-Helm Calico
local/ceilometer                      	0.1.0        	           	OpenStack-Helm Ceilometer
local/ceph-client                     	0.1.0        	           	OpenStack-Helm Ceph Client
...&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 배포 전 OSH_INFRA_PATH 환경변수에 openstack-helm-infra 프로젝트의 경로를 선언해준다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm-infra]# cd /home/deploy/openstack-helm
[root@kube-cy4-kube001 openstack-helm-infra]# export OSH_INFRA_PATH=&quot;/home/deploy/openstack-helm-infra&quot;&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 각 노드에 대한 label을 지정합니다. 002~4 노드는 control plane의 역할을 할것입니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# kubectl  get nodes
NAME               STATUS   ROLES    AGE   VERSION
kube-cy4-kube001   Ready    master   15h   v1.18.6
kube-cy4-kube002   Ready    &amp;lt;none&amp;gt;   15h   v1.18.6
kube-cy4-kube003   Ready    &amp;lt;none&amp;gt;   15h   v1.18.6
kube-cy4-kube004   Ready    &amp;lt;none&amp;gt;   15h   v1.18.6

[root@kube-cy4-kube001 openstack-helm]# kubectl label node  kube-cy4-kube002 openstack-control-plane=enabled

[root@kube-cy4-kube001 openstack-helm]# kubectl label node  kube-cy4-kube003 openstack-control-plane=enabled

[root@kube-cy4-kube001 openstack-helm]# kubectl label node  kube-cy4-kube004 openstack-control-plane=enabled&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-1.ingress&quot;&gt;
 1. ingress
&lt;/h3&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 ingress는 openstack component 간의 통신시 도메인 기반으로 통신시 사용 됩니다. 기본 chart의 value에 override하여 helm chart를 배포하기 위하여  배포전 value파일을 만들어 변경사항만 추가하여 배포하도록합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# tee /tmp/ingress-kube-system.yaml &amp;lt;&amp;lt; EOF
pod:
  replicas:
    error_page: 2
deployment:
  mode: cluster
  type: DaemonSet
network:
  host_namespace: true
EOF&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 kube-system namespace에 ingress 차트를 배포합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]#  helm upgrade --install ingress-kube-system ${OSH_INFRA_PATH}/ingress --namespace=kube-system --values=/tmp/ingress-kube-system.yaml
[root@kube-cy4-kube001 openstack-helm]# ./tools/deployment/common/wait-for-pods.sh kube-system&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 openstack namespace에 ingress를 배포합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]#  tee /tmp/ingress-openstack.yaml &amp;lt;&amp;lt; EOF
pod:
  replicas:
    ingress: 2
    error_page: 2
EOF

[root@kube-cy4-kube001 openstack-helm]#  helm upgrade --install ingress-openstack ${OSH_INFRA_PATH}/ingress --namespace=openstack --values=/tmp/ingress-openstack.yaml

[root@kube-cy4-kube001 openstack-helm]#  ./tools/deployment/common/wait-for-pods.sh openstack&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;auto-cursor-target&quot; id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-2.MariaDB&quot;&gt;
 2. MariaDB
&lt;/h3&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 MariaDB 차트를 배포합니다. 이때, storage class의 이름을 csi-rbd-sc로 앞서 생성한  storage class이름으로 변경합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# tee /tmp/mariadb.yaml &amp;lt;&amp;lt; EOF
pod:
  replicas:
    server: 3
    ingress: 3
volume:
  class_name: csi-rbd-sc
  size: 5Gi
EOF
[root@kube-cy4-kube001 openstack-helm]#  helm upgrade --install mariadb ${OSH_INFRA_PATH}/mariadb --namespace=openstack --values=/tmp/mariadb.yaml

[root@kube-cy4-kube001 openstack-helm]# ./tools/deployment/common/wait-for-pods.sh openstack&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;auto-cursor-target&quot; id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-3.RabbitMQ&quot;&gt;
 3. RabbitMQ
&lt;/h3&gt;
&lt;p&gt;
 rabbitmq도 mariadb와 동일하게 배포 storage class이름을 수정하여 배포합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;
[root@kube-cy4-kube001 openstack-helm]# tee  /tmp/rabbitmq.yaml &amp;lt;&amp;lt; EOF
volume:
  size: 10Gi
  class_name: csi-rbd-sc

[root@kube-cy4-kube001 openstack-helm]#  helm upgrade --install rabbitmq ${OSH_INFRA_PATH}/rabbitmq --namespace=openstack --values=/tmp/rabbitmq.yaml

[root@kube-cy4-kube001 openstack-helm]# ./tools/deployment/common/wait-for-pods.sh openstack&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;auto-cursor-target&quot; id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-4.Memcached&quot;&gt;
 4. Memcached
&lt;/h3&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 memcached는 사용할 pod selector를 지정하여 value 파일을 생성뒤 배포합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# tee /tmp/memcached.yaml &amp;lt;&amp;lt;EOF
manifests:
  network_policy: true
network_policy:
  memcached:
    ingress:
      - from:
        - podSelector:
            matchLabels:
              application: keystone
        - podSelector:
            matchLabels:
              application: heat
        - podSelector:
            matchLabels:
              application: glance
        - podSelector:
            matchLabels:
              application: cinder
        - podSelector:
            matchLabels:
              application: horizon
        - podSelector:
            matchLabels:
              application: nova
        - podSelector:
            matchLabels:
              application: neutron
        ports:
        - protocol: TCP
          port: 11211
EOF
[root@kube-cy4-kube001 openstack-helm]#  helm upgrade --install memcached ${OSH_INFRA_PATH}/memcached --namespace=openstack --values=/tmp/memcached.yaml

[root@kube-cy4-kube001 openstack-helm]# ./tools/deployment/common/wait-for-pods.sh openstack&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;auto-cursor-target&quot; id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-5.Keystone&quot;&gt;
 5. Keystone
&lt;/h3&gt;
&lt;p&gt;
 keystone도 동일한 방법으로 배포합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# tee /tmp/keystone.yaml &amp;lt;&amp;lt; EOF
pod:
  replicas:
    api: 2
EOF
[root@kube-cy4-kube001 openstack-helm]#  helm upgrade --install keystone ./keystone --namespace=openstack  --values=/tmp/keystone.yaml

[root@kube-cy4-kube001 openstack-helm]# ./tools/deployment/common/wait-for-pods.sh openstack&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 openstack 인증정보를 파일로 작성하고 openstack client 컨테이너를 이용하여 keystone이 정상적으로 작동하는지 확인합니다.
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 client는 host 에 직접 설치하지 않고 아래 방법과 같이 컨테이너를 이용하여 사용합니다. keystone의 ingress도메인은 호스트파일에 worker로 사용되는 노드의 아이피로 설정합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm-infra]# mkdir -p /etc/openstack
[root@kube-cy4-kube001 openstack-helm-infra]# tee /etc/openstack/openrc.env &amp;lt;&amp;lt; EOF
OS_AUTH_URL=http://keystone.openstack.svc.cluster.local:80/v3
OS_IDENTITY_API_VERSION=3
OS_IMAGE_API_VERSION=2
OS_PROJECT_DOMAIN_NAME=default
OS_USER_DOMAIN_NAME=default
OS_PROJECT_NAME=admin
OS_USERNAME=admin
OS_PASSWORD=password
EOF

[root@kube-cy4-kube001 openstack-helm]# echo &quot;10.4.10.22 keystone.openstack.svc.cluster.local&quot; &amp;gt;&amp;gt; /etc/hosts

[root@kube-cy4-kube001 openstack-helm-infra]# docker run -it --network host -v /images:/images --env-file /etc/openstack/openrc.env docker.io/sktdev/openstackclient:stein bash


openstackclient@kube-cy4-kube001:~$ openstack endpoint list
+----------------------------------+-----------+--------------+--------------+---------+-----------+---------------------------------------------------------+
| ID                               | Region    | Service Name | Service Type | Enabled | Interface | URL                                                     |
+----------------------------------+-----------+--------------+--------------+---------+-----------+---------------------------------------------------------+
| 0b33f6a61fdb4860b49ab2278e6ff50c | RegionOne | keystone     | identity     | True    | internal  | http://keystone-api.openstack.svc.cluster.local:5000/v3 |
| 24103bb6eacb403facc31812019e6fbf | RegionOne | keystone     | identity     | True    | public    | http://keystone.openstack.svc.cluster.local/v3          |
| 52edf255656c421f978bea28fd22f023 | RegionOne | keystone     | identity     | True    | admin     | http://keystone.openstack.svc.cluster.local/v3          |
+----------------------------------+-----------+--------------+--------------+---------+-----------+---------------------------------------------------------+&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;auto-cursor-target&quot; id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-6.Glance&quot;&gt;
 6. Glance
&lt;/h3&gt;
&lt;p&gt;
 glance는 ceph의 rbd pool을 자동적으로 생성하여 사용 됩니다. 그러기 위해서는 glance에서  ceph cluster에 접속할 정보가 있는  ceph.conf 파일을 configmap형태로 필요하기 때문에 config map을 생성합니다. 이때, ceph의 monitor버전이 nautilus버전 부터 v1,v2를 선택적으로 사용할 수 있도록 리스트 형태로 생성되지만 glance에서 해당 버전을 인식하지 못하기 때문에 아래와 같이 버전을 v1만 명시 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# vi /etc/ceph/ceph.conf
...
# Please do not change this file directly since it is managed by Ansible and will be overwritten
[global]
cluster network = 10.4.30.0/24
fsid = f9b17cb6-b38c-455b-b10d-5c44d7bcc36b
#mon host = [v2:10.4.20.21:3300,v1:10.4.20.21:6789]
mon host = 10.4.20.21:6789
...

[root@kube-cy4-kube001 openstack-helm]# kubectl create configmap ceph-etc -n openstack --from-file=/etc/ceph/ceph.conf

&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 ceph의 admin 인증정보가 필요하기 때문에 admin keyring정보를 추가한뒤 glance를 배포 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# ceph auth get client.admin | grep key
exported keyring for client.admin
	key = AQBgGCVfjOayKBAAT4iPx2CSDEMU60aSQtgBXg==
[root@kube-cy4-kube001 openstack-helm]# tee /tmp/glance.yaml  &amp;lt;&amp;lt; EOF
storage: rbd
pod:
  replicas:
    api: 2
    registry: 2
conf:
  ceph:
    enabled: true
    admin_keyring: AQBgGCVfjOayKBAAT4iPx2CSDEMU60aSQtgBXg==
  glance:
    DEFAULT:
      enable_v1_api: true
      enable_v2_registry: true
EOF

[root@kube-cy4-kube001 openstack-helm]#  helm upgrade --install glance ./glance --namespace=openstack --values=/tmp/glance.yaml

[root@kube-cy4-kube001 openstack-helm]# ./tools/deployment/common/wait-for-pods.sh openstack&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 정상적으로 pod가 배포 된것을 확인 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]#kubectl  get pod -n openstack  | grep glance                       

glance-api-ff94f9577-ph6fx                     1/1     Running     0          2m50s
glance-api-ff94f9577-scs69                     1/1     Running     0          2m50s
glance-bootstrap-csjd4                         0/1     Completed   0          2m49s
glance-db-init-8lfws                           0/1     Completed   0          2m50s
glance-db-sync-24t8f                           0/1     Completed   0          2m50s
glance-ks-endpoints-fjczv                      0/3     Completed   0          2m50s
glance-ks-service-d59gp                        0/1     Completed   0          2m50s
glance-ks-user-q2jv6                           0/1     Completed   0          2m50s
glance-metadefs-load-tgtwn                     0/1     Completed   0          2m50s
glance-rabbit-init-sq4k4                       0/1     Completed   0          2m50s
glance-storage-init-d68nf                      0/1     Completed   0          2m50s&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 glance ingress 도메인을 hosts파일에 추가후 openstack client에 접속하면 bootstrap과정에서 업로드된 cirros이미지를 확인할 수 있습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# echo &quot;10.4.10.22 glance.openstack.svc.cluster.local&quot; &amp;gt;&amp;gt; /etc/hosts
[root@kube-cy4-kube001 openstack-helm]#  docker run -it --network host -v /images:/images --env-file /etc/openstack/openrc.env docker.io/sktdev/openstackclient:stein bash
openstackclient@kube-cy4-kube001:~$ openstack image list
+--------------------------------------+---------------------+--------+
| ID                                   | Name                | Status |
+--------------------------------------+---------------------+--------+
| 8869f634-9f67-4990-9e9a-84c110d816f4 | Cirros 0.3.5 64-bit | active |
+--------------------------------------+---------------------+--------+
openstackclient@kube-cy4-kube001:~$&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;auto-cursor-target&quot; id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-7.Cinder&quot;&gt;
 7. Cinder
&lt;/h3&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 cinder는 glance와 동일하게 ceph의 rbd pool을 사용하기 때문에 admin keyring정보를 추가한뒤 배포 합니다.
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 기본적으로 cinder volume과 cinder volume backup 두가지 서비스를 위한 pool을 각각 ceph의 pool로 자동 생성합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# ceph auth get  client.admin | grep key
exported keyring for client.admin
	key = AQBgGCVfjOayKBAAT4iPx2CSDEMU60aSQtgBXg==

[root@kube-cy4-kube001 openstack-helm]# tee  /tmp/cinder.yaml &amp;lt;&amp;lt; EOF
pod:
  replicas:
    api: 2
    volume: 1
    scheduler: 1
    backup: 1
conf:
  ceph:
    admin_keyring: AQBgGCVfjOayKBAAT4iPx2CSDEMU60aSQtgBXg==
    enabled: true
  cinder:
    DEFAULT:
      backup_driver: cinder.backup.drivers.ceph.CephBackupDriver
EOF


[root@kube-cy4-kube001 openstack-helm]#  helm upgrade --install cinder ./cinder --namespace=openstack --values=/tmp/cinder.yaml

[root@kube-cy4-kube001 openstack-helm]# ./tools/deployment/common/wait-for-pods.sh openstack&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 완료되면 cinder의 pod를 확인할 수 있습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# kubectl  get pod -n openstack | grep cinder
cinder-api-64f59cbcb-5jjzq                     1/1     Running     0          112s
cinder-api-64f59cbcb-jsjjp                     1/1     Running     0          112s
cinder-backup-6c47fff559-2w2xm                 1/1     Running     0          112s
cinder-backup-storage-init-cjlb4               0/1     Completed   0          112s
cinder-bootstrap-h7bbj                         0/1     Completed   0          112s
cinder-create-internal-tenant-52s8p            0/1     Completed   0          112s
cinder-db-init-6gpws                           0/1     Completed   0          113s
cinder-db-sync-xt9kq                           0/1     Completed   0          113s
cinder-ks-endpoints-mqb9c                      0/9     Completed   0          112s
cinder-ks-service-d4bdf                        0/3     Completed   0          113s
cinder-ks-user-jx8wn                           0/1     Completed   0          113s
cinder-rabbit-init-x7659                       0/1     Completed   0          113s
cinder-scheduler-f8b98c7b4-p42jm               1/1     Running     0          113s
cinder-storage-init-6rz8c                      0/1     Completed   0          113s
cinder-volume-5d67df7bdd-sq2hx                 1/1     Running     0          112s&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 cinder ingress 도메인 정보를 hosts파일에 추가후 openstack client를 통하여 볼륨 서비스 확인 및 테스트 볼륨을 생성하여 확인 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# echo &quot;10.4.10.22 cinder.openstack.svc.cluster.local&quot; &amp;gt;&amp;gt; /etc/hosts
[root@kube-cy4-kube001 openstack-helm]#  docker run -it --network host -v /images:/images --env-file /etc/openstack/openrc.env docker.io/sktdev/openstackclient:stein bash
openstackclient@kube-cy4-kube001:~$ openstack voluem lki

openstackclient@kube-cy4-kube001:~$ openstack volume service list
+------------------+---------------------------+------+---------+-------+----------------------------+
| Binary           | Host                      | Zone | Status  | State | Updated At                 |
+------------------+---------------------------+------+---------+-------+----------------------------+
| cinder-scheduler | cinder-volume-worker      | nova | enabled | up    | 2020-08-02T05:56:41.000000 |
| cinder-backup    | cinder-volume-worker      | nova | enabled | up    | 2020-08-02T05:56:40.000000 |
| cinder-volume    | cinder-volume-worker@rbd1 | nova | enabled | up    | 2020-08-02T05:56:41.000000 |
+------------------+---------------------------+------+---------+-------+----------------------------+
openstackclient@kube-cy4-kube001:~$ openstack volume create --size 1 test

openstackclient@kube-cy4-kube001:~$ cinder list
+--------------------------------------+-----------+------+------+-------------+----------+-------------+
| ID                                   | Status    | Name | Size | Volume Type | Bootable | Attached to |
+--------------------------------------+-----------+------+------+-------------+----------+-------------+
| d47b5120-3d57-465f-aeb2-c655aceb565a | available | test | 1    | rbd1        | false    |             |
+--------------------------------------+-----------+------+------+-------------+----------+-------------+&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;auto-cursor-target&quot; id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-8.Openvswitch&quot;&gt;
 8. Openvswitch
&lt;/h3&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 openvswitch 차트는 daemonset으로 &quot;openvswitch=enabled &quot; label이 설정된 노드에만 배포 됩니다. worker노드에 openvswitch label을 설정 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# kubectl label node kube-cy4-kube002 openvswitch=enabled
node/kube-cy4-kube002 labeled
[root@kube-cy4-kube001 openstack-helm]# kubectl label node kube-cy4-kube003 openvswitch=enabled
node/kube-cy4-kube003 labeled
[root@kube-cy4-kube001 openstack-helm]# kubectl label node kube-cy4-kube004 openvswitch=enabled
node/kube-cy4-kube004 labeled&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 openvswitch 차트를 배포 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt; [root@kube-cy4-kube001 openstack-helm]# helm upgrade --install openvswitch ${OSH_INFRA_PATH}/openvswitch --namespace=openstack&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 배포가 완료된 openvswitch pod를 확인 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# kubectl  get pod -n openstack  | grep openv
openvswitch-db-8llk2                           1/1     Running     0          3m29s
openvswitch-db-gw9w5                           1/1     Running     0          3m33s
openvswitch-db-q86zr                           1/1     Running     0          3m37s
openvswitch-vswitchd-2chg8                     1/1     Running     0          3m37s
openvswitch-vswitchd-lvntw                     1/1     Running     0          3m29s
openvswitch-vswitchd-vdwmx                     1/1     Running     0          3m33s&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;auto-cursor-target&quot; id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-9.Libvirt,Neutron,Nova&quot;&gt;
 9. Libvirt,Neutron,Nova
&lt;/h3&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 Libvirt,Neutron,Nova 차트는 서로 의존성이 있기 때문에 모두 정상적으로 동작해야 차트 배포가 완료 됩니다.
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 각 노드에 label을 지정합니다.003,004노드는 compute노드로 사용 됩니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# kubectl label node  kube-cy4-kube002 openstack-helm-node-class=primary
node/kube-cy4-kube002 labeled
[root@kube-cy4-kube001 openstack-helm]# kubectl label node  kube-cy4-kube003 openstack-compute-node=enabled
node/kube-cy4-kube003 labeled
[root@kube-cy4-kube001 openstack-helm]# kubectl label node  kube-cy4-kube004 openstack-compute-node=enabled
node/kube-cy4-kube004 labeled&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 ceph admin과 cinder 유저 인증 정보를 추가한뒤 libvirt 차트를 배포 합니다. 아직 다른 component가 정상적으로 안올라와서 pod가 생성되지 않는다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# ceph auth get client.admin | grep key
exported keyring for client.admin
	key = AQBgGCVfjOayKBAAT4iPx2CSDEMU60aSQtgBXg==

[root@kube-cy4-kube001 openstack-helm]# ceph auth get client.cinder | grep key
exported keyring for client.cinder
	key = AQDHVCZfithVDBAALjJxP9UZob3Y0IC3KhGsrA==
[root@kube-cy4-kube001 openstack-helm]# tee /tmp/libvirt.yaml &amp;lt;&amp;lt; EOF
network:
  backend:
    - openvswitch
conf:
  ceph:
    enabled: true
    admin_keyring: AQBgGCVfjOayKBAAT4iPx2CSDEMU60aSQtgBXg==
    cinder:
      keyring: AQDHVCZfithVDBAALjJxP9UZob3Y0IC3KhGsrA==
      secret_uuid: 582393ff-9a5c-4a2e-ae0d-86ec18c36afc


EOF

[root@kube-cy4-kube001 openstack-helm]# helm upgrade --install libvirt ${OSH_INFRA_PATH}/libvirt --namespace=openstack --values=/tmp/libvirt.yaml

[root@kube-cy4-kube001 openstack-helm]# kubectl  get pod -n openstack | grep libvirt
libvirt-libvirt-default-4vxp5                  0/1     Init:0/3    0          27s
libvirt-libvirt-default-5spwb                  0/1     Init:0/3    0          27s&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 nova에서 ceph의 admin정보와 cinder 인정 정보를 차트에 추가 해주며 , virt type을 qemu로 설정 하여 배포 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# ceph auth get client.admin | grep key
exported keyring for client.admin
	key = AQBgGCVfjOayKBAAT4iPx2CSDEMU60aSQtgBXg==

[root@kube-cy4-kube001 openstack-helm]# ceph auth get client.cinder | grep key
exported keyring for client.cinder
	key = AQDHVCZfithVDBAALjJxP9UZob3Y0IC3KhGsrA==

[root@kube-cy4-kube001 openstack-helm]# tee /tmp/nova.yaml &amp;lt;&amp;lt; EOF
labels:
  api_metadata:
    node_selector_key: openstack-helm-node-class
    node_selector_value: primary
conf:
  ceph:
    enabled: true
    admin_keyring: AQBgGCVfjOayKBAAT4iPx2CSDEMU60aSQtgBXg==
    cinder:
      user: cinder
      keyring: AQDHVCZfithVDBAALjJxP9UZob3Y0IC3KhGsrA==
    nova:
      libvirt:
        images_type: rbd
        rbd_user: cinder
        rbd_secret_uuid: 582393ff-9a5c-4a2e-ae0d-86ec18c36afc
        virt_type: qemu
pod:
  replicas:
    api_metadata: 1
    placement: 2
    osapi: 2
    conductor: 2
    consoleauth: 2
    scheduler: 1
    novncproxy: 1
EOF

[root@kube-cy4-kube001 openstack-helm]#  helm upgrade --install nova ./nova --namespace=openstack --values=/tmp/nova.yaml&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 앞서 이야기 한것 처럼 compute노드들의  eth3인터페이스는 tanent 네트워크로 사용 하기 때문에 명시 하며, eth4 인터페이스는 자동으로 ovs 브릿지를 만들기 위해서 auto_bridge_add 변수에 추가 합니다.br-ex로 만든 인터페이스는 provider 이름의 flat network로 floating ip를 사용하기 위해서 생성 됩니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# tee /tmp/neutron.yaml &amp;lt;&amp;lt; EOF
network:
  interface:
    tunnel: eth3
pod:
  replicas:
    server: 1
conf:
  auto_bridge_add:
    br-ex: eth4
  neutron:
    DEFAULT:
      l3_ha: False
      max_l3_agents_per_router: 1
      l3_ha_network_type: vxlan
      dhcp_agents_per_network: 1
  plugins:
    ml2_conf:
      ml2_type_flat:
        flat_networks: provider
    openvswitch_agent:
      agent:
        tunnel_types: vxlan
        l2_population: True
        arp_responder: True
      ovs:
        bridge_mappings: provider:br-ex

EOF

[root@kube-cy4-kube001 openstack-helm]#  helm upgrade --install neutron ./neutron --namespace=openstack --values=/tmp/neutron.yaml&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 모든 pod와 서비스 job들이 종료 될때 까지 스크립트를 통하여 대기 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# ./tools/deployment/common/wait-for-pods.sh openstack&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 정상적으로 종료 되었습니다면  client에 접속 하여  nova, neutron서비스를 확인 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# echo &quot;10.4.10.22 nova.openstack.svc.cluster.local&quot; &amp;gt;&amp;gt; /etc/hosts
10.4.10.22 nova.openstack.svc.cluster.local /etc/hosts
[root@kube-cy4-kube001 openstack-helm]# echo &quot;10.4.10.22 neutron.openstack.svc.cluster.local&quot; &amp;gt;&amp;gt; /etc/hosts

[root@kube-cy4-kube001 openstack-helm]#  docker run -it --network host -v /images:/images --env-file /etc/openstack/openrc.env docker.io/sktdev/openstackclient:stein bash


openstackclient@kube-cy4-kube001:~$ openstack compute service list
+----+------------------+-----------------------------------+----------+---------+-------+----------------------------+
| ID | Binary           | Host                              | Zone     | Status  | State | Updated At                 |
+----+------------------+-----------------------------------+----------+---------+-------+----------------------------+
| 34 | nova-consoleauth | nova-consoleauth-5468477744-qlr5d | internal | enabled | up    | 2020-08-02T07:10:37.000000 |
| 37 | nova-consoleauth | nova-consoleauth-5468477744-d27wr | internal | enabled | up    | 2020-08-02T07:10:37.000000 |
| 40 | nova-conductor   | nova-conductor-54f649d6bd-nznqv   | internal | enabled | up    | 2020-08-02T07:10:38.000000 |
| 43 | nova-scheduler   | nova-scheduler-c5f45fb88-whbr5    | internal | enabled | up    | 2020-08-02T07:10:29.000000 |
| 58 | nova-conductor   | nova-conductor-54f649d6bd-9w5hg   | internal | enabled | up    | 2020-08-02T07:10:29.000000 |
| 61 | nova-compute     | kube-cy4-kube004                  | nova     | enabled | up    | 2020-08-02T07:10:38.000000 |
| 64 | nova-compute     | kube-cy4-kube003                  | nova     | enabled | up    | 2020-08-02T07:10:37.000000 |
+----+------------------+-----------------------------------+----------+---------+-------+----------------------------+
openstackclient@kube-cy4-kube001:~$ openstack network agent list
+--------------------------------------+--------------------+------------------+-------------------+-------+-------+---------------------------+
| ID                                   | Agent Type         | Host             | Availability Zone | Alive | State | Binary                    |
+--------------------------------------+--------------------+------------------+-------------------+-------+-------+---------------------------+
| 261a37c4-58fc-4512-aafc-81bba3519003 | Metadata agent     | kube-cy4-kube004 | None              | :-)   | UP    | neutron-metadata-agent    |
| 2f015c71-9243-4774-bb2a-5d0d070ef4f3 | Open vSwitch agent | kube-cy4-kube004 | None              | :-)   | UP    | neutron-openvswitch-agent |
| 39f2dcf4-fbf3-46cd-b712-13d808b38dd6 | L3 agent           | kube-cy4-kube002 | nova              | :-)   | UP    | neutron-l3-agent          |
| 4a1266f9-0182-462b-9e8f-3424337483f7 | DHCP agent         | kube-cy4-kube002 | nova              | :-)   | UP    | neutron-dhcp-agent        |
| 4e1bac9f-577a-48d2-b0f7-f981cad85440 | DHCP agent         | kube-cy4-kube003 | nova              | :-)   | UP    | neutron-dhcp-agent        |
| 675ee208-2f49-4b58-9540-8de865fb3865 | Open vSwitch agent | kube-cy4-kube003 | None              | :-)   | UP    | neutron-openvswitch-agent |
| 7d6056bf-9dbb-4e55-99b4-84a056042449 | Open vSwitch agent | kube-cy4-kube002 | None              | :-)   | UP    | neutron-openvswitch-agent |
| 8ba71881-7367-4874-a41a-46f8d81cd0c2 | Metadata agent     | kube-cy4-kube003 | None              | :-)   | UP    | neutron-metadata-agent    |
| 97c7da9e-1a12-4cef-bbdf-e4c021b1345d | DHCP agent         | kube-cy4-kube004 | nova              | :-)   | UP    | neutron-dhcp-agent        |
| d0a5085e-d3a4-408c-bab8-a458d32d047b | Metadata agent     | kube-cy4-kube002 | None              | :-)   | UP    | neutron-metadata-agent    |
| d856ab20-547e-481f-857f-50a0b7a87e87 | L3 agent           | kube-cy4-kube003 | nova              | :-)   | UP    | neutron-l3-agent          |
| decd265a-9ea0-41a4-9516-c7467f2d7cad | L3 agent           | kube-cy4-kube004 | nova              | :-)   | UP    | neutron-l3-agent          |
+--------------------------------------+--------------------+------------------+-------------------+-------+-------+---------------------------+&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 openstack client에서  기본 network 생성하고 ,  인스턴스를 생성해봅니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;openstackclient@kube-cy4-kube001:~$ openstack network create --share --external \
--provider-physical-network provider \
--provider-network-type flat provider
   
openstackclient@kube-cy4-kube001:~$ o openstack subnet create --network provider \
--allocation-pool start=192.168.193.210,end=192.168.193.240 \
--dns-nameserver 8.8.4.4 --gateway 192.168.0.1 \
--subnet-range 192.168.0.1/16 provider
	 
openstackclient@kube-cy4-kube001:~$ o openstack network create selfservice
 
openstackclient@kube-cy4-kube001:~$ o openstack subnet create --network selfservice \
--dns-nameserver 8.8.4.4 --gateway 11.11.1.1 \
--subnet-range 11.11.1.0/24 selfservice
 
openstackclient@kube-cy4-kube001:~$ o openstack router create  router
 
openstackclient@kube-cy4-kube001:~$ o neutron router-interface-add router selfservice
 
openstackclient@kube-cy4-kube001:~$ o neutron router-gateway-set router provider

openstackclient@kube-cy4-kube001:~$ openstack network list
+--------------------------------------+-------------+--------------------------------------+
| ID                                   | Name        | Subnets                              |
+--------------------------------------+-------------+--------------------------------------+
| 3e37ecae-fed8-432d-a7ca-0de991623717 | provider    | 360e99c6-5bdc-43e3-8275-3336a0d6ef80 |
| 9364f2bb-58ea-4ce5-a867-308a0115e3ba | selfservice | 69079fee-decb-41d6-9da2-f2cfca4cc9ca |
+--------------------------------------+-------------+--------------------------------------+


openstackclient@kube-cy4-kube001:~$ openstack flavor list
+--------------------------------------+-----------+-------+------+-----------+-------+-----------+
| ID                                   | Name      |   RAM | Disk | Ephemeral | VCPUs | Is Public |
+--------------------------------------+-----------+-------+------+-----------+-------+-----------+
| 0a866d33-ad39-45c7-8461-e90b21d37524 | m1.large  |  8192 |   80 |         0 |     4 | True      |
| 17b234fc-ff37-493e-a96a-02df7e4cf574 | m1.tiny   |   512 |    1 |         0 |     1 | True      |
| 401af6df-2c9a-4771-803d-f847b4c37d33 | m1.medium |  4096 |   40 |         0 |     2 | True      |
| 7ffcb940-fd02-46e9-9d63-9556210b31d1 | m1.xlarge | 16384 |  160 |         0 |     8 | True      |
| fe9146fa-a62c-41c6-a45c-02931fdedc5a | m1.small  |  2048 |   20 |         0 |     1 | True      |
+--------------------------------------+-----------+-------+------+-----------+-------+-----------+
openstackclient@kube-cy4-kube001:~$ openstack security group list
+--------------------------------------+---------+------------------------+----------------------------------+------+
| ID                                   | Name    | Description            | Project                          | Tags |
+--------------------------------------+---------+------------------------+----------------------------------+------+
| 8c210974-5d4c-4a8a-ac62-669846fb7ded | default | Default security group | d24347196d1a42999290eadba5c51151 | []   |
| ad3441b9-eb4e-475a-a979-517ef556936c | default | Default security group |                                  | []   |
+--------------------------------------+---------+------------------------+----------------------------------+------+
openstackclient@kube-cy4-kube001:~$ openstack   security group rule create --ingress --dst-port 22 8c210974-5d4c-4a8a-ac62-669846fb7ded


openstackclient@kube-cy4-kube001:~$ openstack image list
+--------------------------------------+---------------------+--------+
| ID                                   | Name                | Status |
+--------------------------------------+---------------------+--------+
| 8869f634-9f67-4990-9e9a-84c110d816f4 | Cirros 0.3.5 64-bit | active |
+--------------------------------------+---------------------+--------+


openstackclient@kube-cy4-kube001:~$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/home/openstackclient/.ssh/id_rsa):
Created directory '/home/openstackclient/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/openstackclient/.ssh/id_rsa.
Your public key has been saved in /home/openstackclient/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:rmKh6dug9CYW0bCIIcuWjSPLhrcD+woRDLYJoPmm8m0 openstackclient@kube-cy4-kube001
The key's randomart image is:
+---[RSA 2048]----+
|=.               |
|Ooo              |
|O*B              |
|=@ o             |
|*.=     S        |
|+B. .  .         |
|==o+ .  .        |
|==*=E  .         |
|++B*o..          |
+----[SHA256]-----+

openstackclient@kube-cy4-kube001:~$ openstack server create  --image 8869f634-9f67-4990-9e9a-84c110d816f4 --security-group 8c210974-5d4c-4a8a-ac62-669846fb7ded --flavor m1.tiny --key-name admin_client_key --network 9364f2bb-58ea-4ce5-a867-308a0115e3ba test-cirros-vm&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 provider network 에서 floating ip 생성뒤 앞서 생성한 인스턴스에 붙이고 ssh를 이용하여 접속 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;openstackclient@kube-cy4-kube001:~$ openstack floating ip create  provider
+---------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Field               | Value                                                                                                                                                                             |
+---------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| created_at          | 2020-08-02T07:19:31Z                                                                                                                                                              |
| description         |                                                                                                                                                                                   |
| dns_domain          | None                                                                                                                                                                              |
| dns_name            | None                                                                                                                                                                              |
| fixed_ip_address    | None                                                                                                                                                                              |
| floating_ip_address | 192.168.193.235                                                                                                                                                                   |
| floating_network_id | 3e37ecae-fed8-432d-a7ca-0de991623717                                                                                                                                              |
| id                  | 7cfd6a27-4bfb-46fa-b32b-2ce5c0c021e5                                                                                                                                              |
| location            | Munch({'cloud': '', 'region_name': '', 'zone': None, 'project': Munch({'id': 'd24347196d1a42999290eadba5c51151', 'name': 'admin', 'domain_id': None, 'domain_name': 'default'})}) |
| name                | 192.168.193.235                                                                                                                                                                   |
| port_details        | None                                                                                                                                                                              |
| port_id             | None                                                                                                                                                                              |
| project_id          | d24347196d1a42999290eadba5c51151                                                                                                                                                  |
| qos_policy_id       | None                                                                                                                                                                              |
| revision_number     | 0                                                                                                                                                                                 |
| router_id           | None                                                                                                                                                                              |
| status              | DOWN                                                                                                                                                                              |
| subnet_id           | None                                                                                                                                                                              |
| tags                | []                                                                                                                                                                                |
| updated_at          | 2020-08-02T07:19:31Z                                                                                                                                                              |
+---------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
openstackclient@kube-cy4-kube001:~$ openstack   server add floating ip test-cirros-vm 192.168.193.235
openstackclient@kube-cy4-kube001:~$ ssh cirros@192.168.193.235
The authenticity of host '192.168.193.235 (192.168.193.235)' can't be established.
RSA key fingerprint is SHA256:45KMfL6+lSzqdN2fLLkd9vvxnfvfUg+h0kZUFF411uY.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.193.235' (RSA) to the list of known hosts.
$ ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 16436 qdisc noqueue
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1450 qdisc pfifo_fast qlen 1000
    link/ether fa:16:3e:8b:86:9f brd ff:ff:ff:ff:ff:ff
    inet 11.11.1.198/24 brd 11.11.1.255 scope global eth0
    inet6 fe80::f816:3eff:fe8b:869f/64 scope link
       valid_lft forever preferred_lft forever&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;auto-cursor-target&quot; id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-10.Horizon&quot;&gt;
 10. Horizon
&lt;/h3&gt;
&lt;p&gt;
 horizon 배포전 브라우저를 통하여 접속 하기 위하여 node port설정이 필요 하다. 31000포트로 지정 하여 loca_settings 변수에 필요한 기능만 활성화 한뒤 배포를 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@kube-cy4-kube001 openstack-helm]# tee /tmp/horizon.yaml &amp;lt;&amp;lt; EOF
network:
  node_port:
    enabled: true
    port: 31000
conf:
  horizon:
    local_settings:
      config:
        openstack_neutron_network:
          enable_router: &quot;True&quot;
          enable_quotas: &quot;True&quot;
          enable_ipv6: &quot;False&quot;
          enable_ha_router: &quot;True&quot;
          enable_lb: &quot;True&quot;
          enable_firewall: &quot;False&quot;
          enable_vpn: &quot;False&quot;
          enable_fip_topology_check: &quot;True&quot;
EOF

[root@kube-cy4-kube001 openstack-helm]#  helm upgrade --install horizon ./horizon --namespace=openstack --values=/tmp/horizon.yaml
[root@kube-cy4-kube001 openstack-helm]# ./tools/deployment/common/wait-for-pods.sh openstack&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 배포가 완료되면 ,  http://{worker노드 ip}:31000 를 브라우저를 통하여 접속 확인 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97477266/2.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 앞서 생성한 인스턴스를 확인할 수 있습니다.
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97477266/3.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;hr/&gt;
&lt;h3 id=&quot;openstackhelm을이용한kubernetes환경에서openstack배포-참고사이트&quot;&gt;
 참고 사이트
&lt;/h3&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/ceph/ceph-ansible&quot; rel=&quot;nofollow&quot;&gt;
   https://github.com/ceph/ceph-ansible
  &lt;/a&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://docs.docker.com/engine/install/centos/&quot; rel=&quot;nofollow&quot;&gt;
   https://docs.docker.com/engine/install/centos
  &lt;/a&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://docs.openstack.org/openstack-helm/latest/&quot; rel=&quot;nofollow&quot;&gt;
   https://docs.openstack.org/openstack-helm/latest/
  &lt;/a&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/&quot; rel=&quot;nofollow&quot;&gt;
   https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/
  &lt;/a&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://docs.projectcalico.org/&quot; rel=&quot;nofollow&quot;&gt;
   https://docs.projectcalico.org/
  &lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;</description>
        <pubDate>Mon, 03 Aug 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/08/03/97477266/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/08/03/97477266/</guid>
        
        
      </item>
    
      <item>
        <title>[Success Story] How IT team reduce the costs using Atlassian Marketplace App</title>
        <description>&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97475714/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp&quot; style=&quot;text-align: left;&quot;&gt;
 &lt;strong&gt;
  [Success Story] How IT team reduce the costs using Atlassian Marketplace App
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;h2 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-MiraeAssetLifeInsurancesavedabout34%ofITcostsusingtheFlexibleUserLicense&quot; style=&quot;text-align: left;&quot;&gt;
 &lt;strong&gt;
  Mirae Asset Life Insurance saved about 34% of IT costs using the Flexible User License
 &lt;/strong&gt;
&lt;/h2&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 The IT team plays an important role in driving the business growth and innovation of the company by quickly responding to the changing organization scales and market environment.
&lt;/p&gt;
&lt;p&gt;
 At the same time, they also consider reducing IT costs by eliminating unnecessary waste from their business.
&lt;/p&gt;
&lt;p&gt;
 Due to COVID-19 Pandemic, the pressure on IT team for more efficient IT costs and budget savings is growing.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Please read our customer story that how Mirae Asset Life Insurance, a leading financial company in Korea, has been able to reduce IT costs by 34% using Atlassian marketplace app - Flexible User License.
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97475714/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 Mirae Asset Life Insurance Co., Ltd. that is major life insurance company in Korea provides retirement design services through diverse insurance products.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  Company: Mirae Asset Life Insurance Co., Ltd.
 &lt;/li&gt;
 &lt;li&gt;
  Industry: Insurance
 &lt;/li&gt;
 &lt;li&gt;
  Company size: 34.5 trillion (2018)
 &lt;/li&gt;
 &lt;li&gt;
  Atlassian Products: Jira Software, Confluence , Bitbucket, Bamboo
 &lt;/li&gt;
 &lt;li&gt;
  Hosting type: Server
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-Challenge:Workcomplexityandresourcescontinuetogrow&quot; style=&quot;text-align: left;&quot;&gt;
 &lt;strong&gt;
  Challenge : Work complexity and resources continue to grow
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;p&gt;
 Various regulations in the financial industry and changes in the working environment have resulted in continuous increase in the complexity of work and resources under management. Mirae Asset Life Insurance needs a new ways of working, such as Agile and DevOps to improve work efficiency. At the same time, they were also concerned about ways to reduce IT costs. Mirae Asset Life Insurance was using 250 user tier of Jira and Confluence, but the number of users increased to more than 500 due to increment of inquiries.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-Solution:Respondquicklytothechangethenumberofusers&quot; style=&quot;text-align: left;&quot;&gt;
 &lt;strong&gt;
  Solution : Respond quickly to the change the number of users
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 &lt;span class=&quot;tlid-translation translation&quot; lang=&quot;en&quot;&gt;
  &lt;span title=&quot;&quot;&gt;
   The cost of purchasing all Atlassian products, including the marketplace app, was expected to increase significantly due to the increase in the number of users
  &lt;/span&gt;
  &lt;span title=&quot;&quot;&gt;
   , but
  &lt;/span&gt;
 &lt;/span&gt;
 &lt;strong&gt;
  Flexible User License
 &lt;/strong&gt;
 solved this issue instead of purchasing the additional user licenses. Mirae Asset Life Insurance has experienced a 34% cost savings. In addition, Flexible User License handles to maintain 250 user license at all times through the scheduler. They don't have to monitor the system, so it has been improved the convenience of administrator.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Flexible User License
 &lt;/strong&gt;
 is an efficient user license management app that solves the license shortage issue. The administrator does not need to manually deactivate the user, and the app setting allows automatically the assignment of the licenses to the unlicensed users when they log back in. So, they can respond quickly to the change the number of users. Flexible User License is a global-enterprise-proven app by our large enterprise clients in areas such as IT, manufacturing and finance.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97475714/2.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-Getstaredwithatrialforyourbusiness&quot;&gt;
 &lt;strong&gt;
  Get stared with a trial for your business
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;p class=&quot;fs20 fw300&quot;&gt;
   &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1222216&quot; rel=&quot;nofollow&quot;&gt;
    Flexible User License for Jira
   &lt;/a&gt;
  &lt;/p&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;p class=&quot;fs20 fw300&quot;&gt;
   &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1220252&quot; rel=&quot;nofollow&quot;&gt;
    Flexible User License for Confluence
   &lt;/a&gt;
  &lt;/p&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 Learn more about Flexible User License, please
 &lt;a class=&quot;external-link&quot; href=&quot;https://osci.kr/en/flex_user.php?utm_source=techblog&amp;amp;utm_medium=posting&amp;amp;utm_campaign=appsforeveryteam&amp;amp;utm_term=July_2020&quot; rel=&quot;nofollow&quot;&gt;
  visit our website
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 Or to see how to set up your own license management, please
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.youtube.com/watch?v=3TkVf6tI49A&quot; rel=&quot;nofollow&quot;&gt;
  see this guide video.
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-AboutOpenSourceConsulting...&quot;&gt;
 &lt;strong&gt;
  About Open Source Consulting...
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;p&gt;
 &lt;strong&gt;
  Open Source Consulting Inc.,
 &lt;/strong&gt;
 a platinum partner of Atlassian, has provided  ITSM and DevOps solutions to customers based on our technical experiences in technical/application/system architecture consulting and developments. We also developing and serving the marketplace apps that help customers use Atlassian more efficiently.
&lt;/p&gt;
&lt;p class=&quot;con-title tc&quot; style=&quot;text-align: left;&quot;&gt;
 &lt;span class=&quot;fs30&quot;&gt;
  Open Source Consulting is honored as
 &lt;/span&gt;
 ‘Atlassian Partner of the Year 2019 : Marketing Innovator’ for our outstanding contribution and achievements. This means that implementing the most creative and integrated marketing strategy has contributed to creating customer demand and improving market awareness in Atlassian.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97475714/3.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-[고객사례]IT팀이AtlassianMarketplaceApp을활용하여비용을절감하는방법&quot;&gt;
 [고객사례] IT팀이 Atlassian Marketplace App을 활용하여 비용을 절감하는 방법
&lt;/h2&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-FlexibleUserLicense앱을사용해IT비용의약34%를절감한미래에셋생명의사례를확인해보세요!&quot;&gt;
 &lt;strong&gt;
  Flexible User License 앱을 사용해 IT비용의 약 34%를 절감한 미래에셋생명의 사례를 확인해 보세요!
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 기업의 IT부서는 조직이 확장되고 변화하는 시장 환경에 신속하게 대응함으로써 기업의 비즈니스 성장과 혁신을 주도하는 중요한 역할을 하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 이와 동시에 기업의 불필요한 낭비를 없애 IT비용 절감이라는 미션을 수행해야 합니다.
&lt;/p&gt;
&lt;p&gt;
 최근 코로나 펜데믹 사태에 따라, IT부서에서도 보다 효율적인 IT비용 집행과 예산 절감에 대한 압박이 커지는 상황입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이 포스팅에서는 대표적인 생명보험 회사인
 &lt;strong&gt;
  미래에셋생명이 Atlassian Marketplace App - Flexible User License를 활용하여
 &lt;/strong&gt;
 &lt;strong&gt;
  어떻게 IT 비용을 34% 가량 절감할 수 있었는지
 &lt;/strong&gt;
 소개하고자 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97475714/4.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-Challenge:업무의복잡도및리소스의계속적인증가&quot; style=&quot;text-align: left;&quot;&gt;
 &lt;strong&gt;
  Challenge : 업무의 복잡도 및 리소스의 계속적인 증가
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;p&gt;
 금융권의 각종 규제와 업무 환경의 변화로 업무의 복잡도와 관리 대상 자원이 지속적으로 증가함에 따라, 미래에셋생명은 업무 효율을 개선하기 위한 Agile, DevOps와 같은 새로운 업무 방식이 필요했습니다. 이에 미래에셋생명은 전반적인 요청 관리 프로세스를 통합하는 ITSM 시스템을 아틀라시안 기반으로 새롭게 구축하였습니다. 미래에셋생명은 사용자 수 250명 기준의 Jira와 Confluence 제품을 사용 중이었는데, 점차 문의가 증가하면서 사용자 수도 계속해서 증가하는 상황이었기 때문에 어떻게 IT비용을 줄일 수 있을지에 대한 고민이 있었습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-Solution:사용자수증감에신속하게대응&quot; style=&quot;text-align: left;&quot;&gt;
 &lt;strong&gt;
  Solution: 사용자 수 증감에 신속하게 대응
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 미래에셋생명은 사용자 수가 500명 이상으로 증가함에 따라, 마켓플레이스 앱을 포함한 아틀라시안 전체 제품의 구매 비용이 대폭적으로 증가할 수 있는 상황이었습니다. 하지만 Flexible User License 앱 제품을 도입함으로써 문제를 해결할 수 있었습니다. 미래에셋생명은 라이선스를 추가적으로 구매하지 않고도 사용자 수를 모두 감당할 수 있게 됨으로써, 약 34%의 비용 절감 효과를 누리게 되었습니다.
&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 또한 Flexible User License 제품의 스케쥴러 기능을 통해 항상 250명의 유저 라이선스를 유지시킬 수 있습니다. 별도의 모니터링을 하지 않아도 되기 때문에 관리자의 편의성도 향상 시킬 수 있었습니다.
&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-[SuccessStory]HowITteamreducethecostsusingAtlassianMarketplaceApp-FlexibleUserLicense?&quot; style=&quot;text-align: left;&quot;&gt;
 Flexible User License?
&lt;/h3&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 &lt;span&gt;
  Flexible User License는 라이선스 그룹의 사용자 수를 유연하게 관리할 수 있는 Atlassian marketplace app입니다. 쉽고 간단한
 &lt;/span&gt;
 &lt;span&gt;
  라이선스 관리를 통해 사용자 증감에 신속하게 대응하고 IT비용을 절감할 수 있습니다. Flexible User license 제품은 사용자 기반의 라이선스 자동 할당 및 삭제 기능을 제공하여,
 &lt;/span&gt;
 &lt;span&gt;
  관리자가 수동으로 사용자를 비활성화할 필요가 없으며 일정 기간 로그인 하지 않은 사용자가 다시 로그인할 때 자동으로 라이선스가 할당됩니다.
 &lt;/span&gt;
 &lt;span&gt;
  IT, 제조, 금융 등 많은 기업들이 Flexible User License 앱을 통해 효율적으로 라이선스 관리를 하고 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97475714/5.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 &lt;strong&gt;
  지금 바로 Atlassian Marketplace에서 Flexible User License 앱을 무료로 사용해 보세요!
 &lt;/strong&gt;
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1222216&quot; rel=&quot;nofollow&quot;&gt;
   [Atlassian Marketplace] Flexible User License for Jira
  &lt;/a&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1220252&quot; rel=&quot;nofollow&quot;&gt;
   [Atlassian Marketplace] Flexible User License for Confluence
  &lt;/a&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;span&gt;
   &lt;a class=&quot;external-link&quot; href=&quot;https://osci.kr/page/view.php?m_id=60&amp;amp;utm_source=techblog&amp;amp;utm_medium=posting&amp;amp;utm_campaign=appsforeveryteam&amp;amp;utm_term=July_2020&quot; rel=&quot;nofollow&quot;&gt;
    Flexible User License 제품 홈페이지 방문하기&amp;gt;&amp;gt;
   &lt;/a&gt;
  &lt;/span&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://osci.kr/page/view.php?m_id=60&amp;amp;utm_source=techblog&amp;amp;utm_medium=posting&amp;amp;utm_campaign=appsforeveryteam&amp;amp;utm_term=July_2020&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97475714/6.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Tue, 21 Jul 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/07/21/97475714/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/07/21/97475714/</guid>
        
        <category>atlassian</category>
        
        <category>atlassian-marketplace</category>
        
        <category>atlassian-customer-story</category>
        
        <category>atlassian-app</category>
        
        <category>cost-saving</category>
        
        <category>license-management</category>
        
        <category>atlassian-admin-tool</category>
        
        <category>atlassian-user-license</category>
        
        <category>apps-for-every-team</category>
        
        <category>atlassian-platinum-partner</category>
        
        <category>atlassian-partner-of-the-year</category>
        
        <category>open-source-consulting</category>
        
        
      </item>
    
      <item>
        <title>아틀라시안 마켓플레이스 소개 및 Jira Add-on 추천</title>
        <description>&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 안녕하세요!
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅의 아틀라시안팀입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 우리나라의 많은 기업들을 포함해 전세계의 150,000개가 넘는 기업들이 Atlassian의 솔루션을 통해서
&lt;/p&gt;
&lt;p&gt;
 업무 효율성을 개선하고 보다 혁신적인 팀워크를 이루고 있다는 것은 모두 잘 알고 계실 것 같아요.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Jira, Confluence
 &lt;/strong&gt;
 와 같은 협업 및 애자일 도구와
&lt;/p&gt;
&lt;p&gt;
 개발에서 운영, 서비스까지 통합하여 관리할 수 있도록 도와주는
 &lt;strong&gt;
  Jira Service Desk, OpsGenie, Bitbucket
 &lt;/strong&gt;
 등
&lt;/p&gt;
&lt;p&gt;
 Atlassian에서 제공하는 대표적인 제품들만으로도 '팀'을 위한 워크플로우를 개선하고 업무 생산성을 높일 수 있지만,
&lt;/p&gt;
&lt;p&gt;
 Atlassian Marketplace에 올라와 있는 다양한 Add-on(또는 Plugin) 제품들을 통해서 보다 확장된 기능을 구현하고 활용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Atlassian 제품을 사용하고 있지만 좀 더 높은 수준의 커스터마이징과 부가적인 기능을 원하시는 분들,
&lt;/p&gt;
&lt;p&gt;
 또는 Atlassian 솔루션의 도입을 계획하고 있는 분들께서는 본 포스팅을 주목해주세요
 &lt;img src=&quot;/assets/images/97469335/1.svg&quot;/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-AtlassianMarketplace란?&quot;&gt;
 Atlassian Marketplace 란?
&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;
 Atlssian Marketplace는 IT부터 HR팀까지, 모든 팀이 사용할 수 있는 Add-on을 구매할 수 있는 일종의 &quot;App Store&quot; 입니다.
&lt;/p&gt;
&lt;p&gt;
 Atlassian Marketplace에는 무려
 &lt;strong&gt;
  4,000개
  &lt;img src=&quot;/assets/images/97469335/2.svg&quot;/&gt;
 &lt;/strong&gt;
 가 넘는 Add-on이 있어요.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 먼저, Atlassian Marketplace(
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/&quot; rel=&quot;nofollow&quot;&gt;
  https://marketplace.atlassian.com/
 &lt;/a&gt;
 ) 페이지에 대해서 간략하게 소개해드릴게요.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/3.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 메인 페이지의 오른쪽의 필터기능을 통해서 구성하려는 제품, 카테고리등을 선택하면 그에 맞는 제품들만 추려서 탐색할 수 있고,
&lt;/p&gt;
&lt;p&gt;
 Marketplace에서도 자체적으로 새롭게 출시된 제품과 추천 Add-on 제품, 인기 제품들을  소개해주고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 앞서 말씀드린 것처럼 다양한 조직의 요구사항을 충족시켜 줄 강력한 도구들이 4000개가 넘게 있지만,
&lt;/p&gt;
&lt;p&gt;
 종류도 너무 많고 또 모든 내용이 영어로 기재되어 있어 정말 내가 원하는 Add-on을 찾기가 쉽지 않게 느껴지실 것 같아요.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 그래서
 &lt;img src=&quot;/assets/images/97469335/4.svg&quot;/&gt;
 많은 고객분들이 이미 사용하고 계시는 검증된 Add-on들을 추천해드리려고 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-1.ProjectManagement-WBS(WorkBreakdownStructure)&quot;&gt;
 1. Project Management - WBS(Work Breakdown Structure)
&lt;/h2&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-“프로젝트계획부터포트폴리오관리까지”&quot;&gt;
 &lt;em&gt;
  &lt;strong&gt;
   “
  &lt;/strong&gt;
  프로젝트 계획부터 포트폴리오 관리까지
  &lt;strong&gt;
   ”
  &lt;/strong&gt;
 &lt;/em&gt;
&lt;/h2&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/5.png&quot;/&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/6.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 하나의 프로젝트를 진행할 때 업무별, 파트별, 기간별 작업 리소스를 분배하고 진행 스케줄을 관리하기 위해서 WBS를 작성하는 것은 이미 익숙하실텐데요.
&lt;/p&gt;
&lt;p&gt;
 Jira 에서도 WBS 형식으로 프로젝트를 계획하고 관리할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 Gantt-Chart 기능을 활용하여 직접 작업을 작성하고 작업 진행률 및 마감일을 확인하여 프로젝트를 효율적으로 관리할 수 있어요.
&lt;/p&gt;
&lt;p&gt;
 Drag &amp;amp; Drop 형식으로 손쉬운 변경이 가능하고, Jira 이슈 연결을 생성하여 여러 이슈와 프로젝트를 관리할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 또한 MS Project와도 연동이 가능해서 MS Project의 작업을 가져오거나 내보낼 수 있도록 도와줍니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;img src=&quot;/assets/images/97469335/7.svg&quot;/&gt;
 &lt;strong&gt;
  추천 Add-on
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1213016/biggantt-gantt-chart-for-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/8.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1212259/bigpicture-project-management-ppm?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/9.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1211768/wbs-gantt-chart-for-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/10.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-2.JiraWorkflowManagement&quot;&gt;
 2. Jira Workflow Management
&lt;/h2&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-“효율적인워크플로우관리와업무자동화”&quot;&gt;
 &lt;em&gt;
  &lt;strong&gt;
   “
  &lt;/strong&gt;
  효율적인 워크플로우 관리와 업무 자동화
  &lt;strong&gt;
   ”
  &lt;/strong&gt;
 &lt;/em&gt;
&lt;/h2&gt;
&lt;p&gt;
 &lt;em&gt;
  &lt;strong&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/97469335/11.png&quot;/&gt;
   &lt;/span&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/97469335/12.png&quot;/&gt;
   &lt;/span&gt;
  &lt;/strong&gt;
 &lt;/em&gt;
&lt;/p&gt;
&lt;p&gt;
 커스터마이징과 자동화. 이 2가지 키워드 만으로도 많은 사용자께서 높은 관심을 보이실 것 같아요.
&lt;/p&gt;
&lt;p&gt;
 Atlassian Marketplace의 워크플로우 관련 Add-on을 통해서 Jira의 업무 프로세스를 자동화할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 또한 필드, 템플릿, 이슈의 인터페이스를 사용자가 원하는 방식으로 커스터마이징해서 효율성을 높여보세요.
&lt;/p&gt;
&lt;p&gt;
 서로 다른 워크플로우간의 연결도 가능하며, 필드 값 복사, 이슈 업데이트, 이슈 연결 등 다양한 Post Function을 제공합니다.
&lt;/p&gt;
&lt;p&gt;
 이슈를 복제하기 전에 원하는 필드의 값을 수정하고, 프로젝트와 이슈 유형을 복제하면서 조정할 수 있는 기능을 통해서,
&lt;/p&gt;
&lt;p&gt;
 시간을 절약하고 오류가 발생하는 것을 줄일 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;img src=&quot;/assets/images/97469335/13.svg&quot;/&gt;
 &lt;strong&gt;
  추천 Add-on
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/6820/scriptrunner-for-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/14.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/5048/jsu-automation-suite-for-jira-workflows?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/15.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/44043/clone-plus-for-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/16.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-3.UserManagement&quot;&gt;
 3. User Management
&lt;/h2&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-“JiraAdmin을위한효율적인사용자관리방안”&quot;&gt;
 &lt;em&gt;
  &lt;strong&gt;
   “
  &lt;/strong&gt;
  Jira Admin을 위한  효율적인 사용자 관리 방안
  &lt;strong&gt;
   ”
  &lt;/strong&gt;
 &lt;/em&gt;
&lt;/h2&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/17.png&quot;/&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/18.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 회사내의 특정 조직이나 팀뿐만 아니라 여러 협력사와의 협업, 대규모 조직의 전사적 사용 목적으로 사용자수가 증가하게 될 수록,
&lt;/p&gt;
&lt;p&gt;
 많게는 10,000명에 가까운 사용자를 관리하는 것이 Admin에게는 매우 큰 숙제로 느껴지실 것 같아요.
&lt;/p&gt;
&lt;p&gt;
 1,000명이 넘는 사용자를 보유한 조직이라면 Add-on을 통해서 사용자 증감에 대해 스케줄러 설정을 통해 알림을 받아보세요.
&lt;/p&gt;
&lt;p&gt;
 또한 활성 사용자를 식별하여 라이선스를 할당하고 오랫동안 활동이 없는 사용자는 삭제해주는 기능으로 쉽고 간단하게 라이선스를 관리할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;inline-comment-marker&quot; data-ref=&quot;930bb705-c753-449b-98b9-bd92adca4f97&quot;&gt;
  사용자 수가 유동적이고 급격하게 증가하게 될 경우 사용자 수를 유연하게 관리할 수 있도록 돕는 Add-on을 활용하시면,
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;inline-comment-marker&quot; data-ref=&quot;930bb705-c753-449b-98b9-bd92adca4f97&quot;&gt;
  유저 라이선스의 약 20% 내외정도는 추가 구매를 하지 않아도 사용자 수를 감당할 수 있어 시간과 비용을 절감할 수 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;inline-comment-marker&quot; data-ref=&quot;930bb705-c753-449b-98b9-bd92adca4f97&quot;&gt;
  (물론 장기적인 관점에서 사용자수가 계속해서 증가할 경우, User Tier를 올리는 것을 고려해야 겠지만요. ^^)
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 사용자 프로필도 좀 더 구체적이고 다채롭게 구성하여 원하는 동료를 빠르게 찾을 수 있다면 더욱 효율적으로 협업이 가능해집니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;img src=&quot;/assets/images/97469335/19.svg&quot;/&gt;
 &lt;strong&gt;
  추천 Add-on
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1222216/flexible-user-license-for-jira?hosting=server&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/97469335/20.png&quot;/&gt;
   &lt;/span&gt;
  &lt;/a&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1215285/user-management-for-jira?hosting=datacenter&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/97469335/21.png&quot;/&gt;
   &lt;/span&gt;
  &lt;/a&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1212508/user-profiles-for-jira?hosting=datacenter&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/97469335/22.png&quot;/&gt;
   &lt;/span&gt;
  &lt;/a&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-4.Theme&amp;amp;Style&quot;&gt;
 4. Theme &amp;amp; Style
&lt;/h2&gt;
&lt;h2 id='id-아틀라시안마켓플레이스소개및JiraAdd-on추천-&quot;우리조직에최적화된인터페이스구현&quot;'&gt;
 &lt;em&gt;
  &quot;우리 조직에 최적화된 인터페이스 구현&quot;
 &lt;/em&gt;
&lt;/h2&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/23.png&quot;/&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97469335/24.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 Jira 뿐만 아니라 Atlassian 제품에서 우리 조직의 브랜드를 표현하고 최적화된 환경을 조성하고 싶다면, Atlassian Marketplace의 Add-on을 활용해보세요.
&lt;/p&gt;
&lt;p&gt;
 팀의 성격과 사용 목적에 따른 맞춤형 레이아웃과 스타일, 테마를 지정하여 사용자들이 보다 쉽고 친숙하게 이용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 향상된 검색 기능과 드롭 다운 형식의 메뉴 탐색을 통해서 유용한 리소스를 바로 찾을 수 있는 편리한 사이트 환경을 조성하세요.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 뿐만 아니라 스크린샷, 복잡한 표등을 삽입하고 내장된 템플릿이나 스타일을 통해 보다 풍부한 컨텐츠를 제작할 수 있으며,
&lt;/p&gt;
&lt;p&gt;
 프로젝트와 이슈 유형에 따라 템플릿을 만들어 생산성을 향상시키도록 도와줍니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;img src=&quot;/assets/images/97469335/25.svg&quot;/&gt;
 &lt;strong&gt;
  추천 Add-on
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1216711/refined-for-jira-sites-themes?hosting=datacenter&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/26.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1210768/jeditor-rich-text-editor-for-jira?hosting=datacenter&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/27.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안마켓플레이스소개및JiraAdd-on추천-5.Integration&quot;&gt;
 5. Integration
&lt;/h2&gt;
&lt;h2 id='id-아틀라시안마켓플레이스소개및JiraAdd-on추천-&quot;다양한외부시스템/툴과의원활한통합&quot;'&gt;
 &lt;em&gt;
  &quot;다양한 외부 시스템/툴과의 원활한 통합&quot;
 &lt;/em&gt;
&lt;/h2&gt;
&lt;p&gt;
 Atlassian Marketplace에는 여러 외부 툴과의 원활한 연동과 통합을 도와주는 Add-on들이 많이 있어요.
&lt;/p&gt;
&lt;p&gt;
 우리 조직에서 이미 사용하고 있는 기존 시스템과 연동해서 보다 풍부하게 활용하고 한 곳에서 리소스를 편리하게 관리하세요.
&lt;/p&gt;
&lt;p&gt;
 &lt;img src=&quot;/assets/images/97469335/28.svg&quot;/&gt;
 &lt;strong&gt;
  추천 Add-on
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1216787/google-drive-docs-for-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/29.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1214214/connector-for-salesforce-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/30.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/4984/git-integration-for-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/31.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1213138/outlook-email-for-jira?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/32.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1212130/saml-single-sign-on-sso-jira-saml-sso?hosting=datacenter&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/33.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1215229/bigtemplate-export-to-pdf-word-excel?hosting=cloud&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97469335/34.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이 밖에도 Atlassian Marketplace에는 정말 다양하고 유용한 Add-on 들이 많이 있습니다!
&lt;/p&gt;
&lt;p&gt;
 Add-on을 통해서 더욱 다양하게 Atlassian 제품을 활용하기 위한 제품구성이나 금액이 궁금하시다면,
&lt;/p&gt;
&lt;p&gt;
 아래 연락처로 언제든지 편하게 문의해주세요.
 &lt;img src=&quot;/assets/images/97469335/35.svg&quot;/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(0,0,255);&quot;&gt;
  &lt;strong&gt;
   E-mail: atlassian
   &lt;a class=&quot;external-link&quot; href=&quot;mailto:atlassian@osci.kr&quot; rel=&quot;nofollow&quot; style=&quot;color: rgb(0,0,255);&quot;&gt;
    @
   &lt;/a&gt;
   osci.kr / Tel: 02-516-0711
  &lt;/strong&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 다음 포스팅에서는 Confluence 와 관련하여 매우 유용한 Add-on 들을 소개해드릴 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 감사합니다!
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Wed, 24 Jun 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/06/24/97469335/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/06/24/97469335/</guid>
        
        <category>atlassian</category>
        
        <category>아틀라시안</category>
        
        <category>marketplace</category>
        
        <category>jira</category>
        
        
      </item>
    
      <item>
        <title>[Container 시리즈] 05. Kuberbetes란?</title>
        <description>&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Confluence&quot; data-theme=&quot;Confluence&quot;&gt;쿠버네티스를 들어는봤는데... 컨테이너를 관리하는거라고 알고는 있는데...
정확히 이 녀석이 무엇을 하는건지 이해가 잘 안가는 분들을 위한 
Kubernetes 기초개념!&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  안녕하세요!
지난시간에 Container와 Docker에 대한 글을 작성하였었는데 Kubernetes가 과연 무엇인지?
왜 컨테이너를 이야기하면 쿠버네티스가 나오는지?
그럼 컨테이너와 쿠버네티스가 같은것인지?
이번시간에 자세히 다뤄보도록 하겠습니다!
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  지난글에서 설명드린 Container와 Docker가 기억나시나요?
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  예를들어 여러분이 새롭게 오픈한 신규 서비스가 있다고 가정해보겠습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  개발자들이 열씸히 코드를 개발하여 요즘 핫하디 핫한 컨테이너화 하게 구축을 한 후 서버에 이 컨테이너를 배포를 하였습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  대망의 오픈 첫날! 사용자가 신규 서비스로 접속을 하기 시작합니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  가장 떨리는 순간이죠
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  하지만? 너무나 핫한 신규서비스이기에 저희가 예측했던 사용자보다 훨씬 더 많은 사용자가 몰리기 시작하네요...
  &lt;br/&gt;
  즐거운 비명입니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  음... 사용자가 몰리니...
  &lt;br/&gt;
  scale out을 해야할 시점인 것 같습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  서버의 확장? 자신있습니다!
  &lt;br/&gt;
  클라우드 환경이라면 더더욱 간단하죠
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/2.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  서버를 확장하였어요!!!
 &lt;/p&gt;
 &lt;p&gt;
  근데 잠시만....
  &lt;br/&gt;
  저희 신규서비스는 컨테이너 환경인데......
  &lt;br/&gt;
  안에있는 컨테이너들은..... 어떻게 옮겨야하지....?
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/3.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  여차저차해서 새롭게 확장한 서버에 컨테이너를 가져왔습니다!!
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  하지만.....
  &lt;br/&gt;
  이렇게 가져온 컨테이너를 어떻게 적절하게 배치를 해야하는걸까요......
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  이렇게해서
  &lt;br/&gt;
  다수의 컨테이너를 관리해주는
  &lt;br/&gt;
  Container Orchestration 이라는 개념이 나오게 되었습니다!
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/4.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  즉,
  &lt;br/&gt;
  오케스트레이션 이란 단어를 들으면 다음의 이미지를 떠올리신 분들이 계시리라 생각되는데
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/5.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;auto-cursor-target&quot; style=&quot;text-align: center;&quot;&gt;
 출처 : KBS 교향악단
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;br/&gt;
 저희 컨테이너 환경에서의 오케스트레이션은
 &lt;br/&gt;
 다음의 이미지라 생각하시면 조금 쉬우실 것 같습니다!
 &lt;br/&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/6.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;br/&gt;
 쿠버네티스도 이러한 컨테이너 오케스트레이션 중 하나의 툴인데
쿠버네티스 뿐만아니라, Docker Swarm, Rancher, Apache Mesos 등등 여러가지 툴이 존재하고 있습니다.
 &lt;p&gt;
  그중에서 이번 글에서는 대표적인, De facto(사실상 업계표준) Kubernetes에 대하여 알아보겠습니다!!
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/7.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#kubernetes란&quot; id=&quot;kubernetes란&quot;&gt;
   Kubernetes란?
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   Kubernetes
  &lt;/p&gt;
  &lt;blockquote&gt;
   &lt;p&gt;
    쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장가능한 오픈소스 플랫폼이다.
    &lt;br/&gt;
    쿠버네티스는 선언적 구성과 자동화를 모두 용이하게 해준다. 쿠버네티스는 크고, 빠르게 성장하는 생태계를 가지고 있다.
    &lt;br/&gt;
    쿠버네티스 서비스, 기술 지원 및 도구는 어디서나 쉽게 이용할 수 있다.
    &lt;br/&gt;
   &lt;/p&gt;
  &lt;/blockquote&gt;
 &lt;/blockquote&gt;
 &lt;blockquote&gt;
  &lt;blockquote&gt;
   &lt;p&gt;
    쿠버네티스란 명칭은 키잡이(helmsman)나 파일럿을 뜻하는 그리스어에서 유래했다.
    &lt;br/&gt;
    구글이 2014년에 쿠버네티스 프로젝트를 오픈소스화했다.
    &lt;br/&gt;
    쿠버네티스는 프로덕션 워크로드를 대규모로 운영하는 15년 이상의 구글 경험과 커뮤니티의 최고의 아이디어와 적용 사례가 결합되어 있다.
    &lt;br/&gt;
    &lt;del&gt;
     라고 kubernetes의 공식 문서에 나와있습니다 ㅎ_ㅎ
    &lt;/del&gt;
   &lt;/p&gt;
  &lt;/blockquote&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
  즉 쿠버네티스는 앞에서 설명드린대로 컨테이너를 관리를 위해 나온 오픈소스 플랫폼입니다! (갓구글이 만듬)
 &lt;/p&gt;
 &lt;p&gt;
  쿠버네티스 특징이라고 하면 굉장히 많은 정보들이 쏟아져 나오는데요
대표적으로 아래의 3가지 특징이 있습니다.
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/8.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  &lt;strong&gt;
   1. 확장성
  &lt;/strong&gt;
  &lt;br/&gt;
  Google에서 만든것의 명성에 걸맞게 일주일에 수십억 개의 컨테이너들을 운영하게 해준 경험에 따라 쿠버네티스가 디자인되었기 때문에, 손쉽게 확장될 수 있습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   2. 유연성
  &lt;/strong&gt;
  &lt;br/&gt;
  로컬 테스트, 프로덕트 운영이든 환경에 상관없이, 사용자의 복잡한 니즈를 모두 수용할 수 있는 유연성을 가지기에 사용자의 애플리케이션들을 끊임없고 쉽게 전달할 수 있습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;strong&gt;
   3. 이식성
  &lt;/strong&gt;
  &lt;br/&gt;
  쿠버네티스는 오픈소스로서 on-prem, 하이브리드, 또는 퍼블릭 클라우드 인프라스트럭처등 여러 환경에서 기동됩니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  그 밖에 수 많은 장점, 특징을 가지고 있는 쿠버네티스 이지만 굉장히 단순한 로직을 가지고있습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  현재상태를 모니터링하면서 관리자가 설정한 상태의 값과 다르면, 관리자가 설정한값으로 바꿔주는 3단계의 심플한 법칙
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  그렇기에 관리자는 명령어로 관리하는것이 아니라,
  &lt;strong&gt;
   설정한 값이 들어있는 yaml 파일
  &lt;/strong&gt;
  등으로 관리를 해 줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#kubernetes-workflow&quot; id=&quot;kubernetes-workflow&quot;&gt;
   Kubernetes workflow
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  쿠버네티스는 다음과 같은 흐름을 가지고 있습니다.
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/9.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  보통은 조직마다 다르겠지만 협업사 혹은 협업부서에서 서비스에 해당하는 요청을 관리자 에게 전달합니다.
  &lt;br/&gt;
  관리자는 이 명렁을
  &lt;strong&gt;
   Master Node
  &lt;/strong&gt;
  에 전달하고
  &lt;br/&gt;
  Master Node는
  &lt;strong&gt;
   Worker Node
  &lt;/strong&gt;
  에게 명령어를 전달함과 동시에 트래픽을 분배해줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  위와같은 다이어그램을 조금 더 자세히 살펴보자면
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/10.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  위와 같은 아키텍처가 나옵니다!
  &lt;br/&gt;
  기본적으로 쿠버네티스는 하나의 마스터노드와 여러개의 워커노드로 구성이 되어져있는데
  &lt;br/&gt;
  &lt;del&gt;
   굉장히 복잡하고 뭐가 내부에 있는지 궁금하지도, 알고싶지도 않게 생겼지만
  &lt;/del&gt;
  &lt;br/&gt;
  해당 아키텍처에 있는 Kubernetes의 컴포넌트에 대해서 하나하나 간략하게 살펴보겠습니다
  &lt;sup&gt;
   0
  &lt;/sup&gt;
  (해맑)
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#kubernetes-components&quot; id=&quot;kubernetes-components&quot;&gt;
   Kubernetes Components
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#master-node&quot; id=&quot;master-node&quot;&gt;
   Master Node
   &lt;br/&gt;
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  : 쿠버네티스의 주요 컨트롤 유닛으로서 Worker Nodes를 관리하는 주체입니다.
  &lt;br/&gt;
  클러스터에 관한 전반적인 결정을 하고 이벤트를 감지, 반응하는 역할을 합니다
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
   &lt;tr&gt;
    &lt;th align=&quot;left&quot;&gt;
     Component
    &lt;/th&gt;
    &lt;th align=&quot;left&quot;&gt;
     설명
    &lt;/th&gt;
   &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      Kubectl
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     -마스터 노드와 통신하는 명령어로서 쿠버네티스 API를 사용해서 마스터노드와 상호작용을 합니다.
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      API Server
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     - REST API 요청을 처리하고 쿠버네티스 클러스터를 구성하는 각 컴포넌트들과 통신을 담당합니다.
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      Scheduler
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     - 노드들의 리소스 상태를 파악하여 pod가 배치될 적절한 노드를 선택해 주는 역할.
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      Controller Manager
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     - 쿠버네티스 클러스터 상태 감시, 설정한 상태로 유지하는 역할.
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      ETCD
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     - 오픈소스 key-value 저장소로서 Kubernetes에서는 Master Node의 API Server가 HTTP/JSON API를 이용하여 접근할 수 있는 구성 데이터를 저장하는 용도로 사용됩니다.
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#worker-node&quot; id=&quot;worker-node&quot;&gt;
   Worker Node
   &lt;br/&gt;
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  : 워커노드는 할당된 task를 요청대로 수행하는 시스템입니다.
  &lt;br/&gt;
  예전에는 Minions 라고도 불렸으며 컨테이너들간의 네트워크 등 서비스에 필요한 전반적인 일들을 마스터 노드와 통신하며 수행합니다.
 &lt;/p&gt;
 &lt;table class=&quot;confluenceTable&quot;&gt;
  &lt;thead&gt;
   &lt;tr&gt;
    &lt;th align=&quot;left&quot;&gt;
     Component
    &lt;/th&gt;
    &lt;th align=&quot;left&quot;&gt;
     설명
    &lt;/th&gt;
   &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      Kubelet
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     - 쿠버네티스 마스터 노드간의 통신을 담당하는 에이전트로서 노드에서 동작하는 pod들을 관리합니다
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      Kube-proxy
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     - 각 노드별로 탑재되며 네트워크 프록시 및 로드밸런서 역할을 해줍니다.
    &lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td align=&quot;left&quot;&gt;
     &lt;strong&gt;
      Pod
     &lt;/strong&gt;
    &lt;/td&gt;
    &lt;td align=&quot;left&quot;&gt;
     - Pod는 컨테이너의 그룹으로 한 개 또는 여러 개의 컨테이너를 포함하는 쿠버네티스의 작업단위 입니다.
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
  각각의 컴포넌트들이 굉장히 복잡해 보이는데 조금 더 쉬운 다이어그램을 가지고 왔습니다.
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97465347/11.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  Kuberenetes 도큐먼트에 한번쯤 들어가보셨다면 익숙하실 그림일겁니다.
 &lt;/p&gt;
 &lt;p&gt;
  조금더 쉽게 말씀드리자면,
  &lt;br/&gt;
  마스터노드는 쿠버네티스 클러스터를 관리하며
  &lt;br/&gt;
  워커노드는 실질적인 업무를 수행하는 주체입니다.
  &lt;del&gt;
   열일하는 worker node 친근하네요
  &lt;/del&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  또한 이 워커노드를 확대하면 오른쪽 다이어그램처럼 되는데요,
  &lt;br/&gt;
  워커노드안에는 pod가 들어가게 되고
  &lt;br/&gt;
  이 pod안에는 containerized된 application이 들어가게됩니다!
 &lt;/p&gt;
 &lt;p&gt;
  이 pod는 쿠버네티스의 가장작은 작업단위 요소로서,
  &lt;br/&gt;
  필요에 따라 쉽게 생성되고 쉽게 버려지는 비교적 짧은 수명을 가지는 것이 특징입니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  또한, 각각의 pod마다 다른 ip를 가지고 있고 pod 안에 있는 컨테이너끼리 는 내부 통신이 가능합니다.
  &lt;br/&gt;
  &lt;em&gt;
   (DNS로 통신 (coredns))
  &lt;/em&gt;
 &lt;/p&gt;
 &lt;p&gt;
  Pod안에 있는 컨테이너들 끼리 볼륨을 공유하며
  &lt;br/&gt;
  컨테이너가 죽고 재시작 되어도 pod가 살아있는 한 shared volume은 유지됩니다.
 &lt;/p&gt;
 &lt;p&gt;
  여러분의 Application을 컨테이너로 이쁘게 만들고 이를 사용자들에게 서비스를 하려면
  &lt;br/&gt;
  실질적으로 동일한 pod가 지속적으로 올라와져 있어야하는데요~
  &lt;br/&gt;
  (좀 전에 pod는 쉽게 죽는 특징을 가지고 있다고 했는데 ....)
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  우리의 쿠버네티스는 똑똑한 친구이니 이런 빅픽쳐를 계산해두었습니다.
  &lt;br/&gt;
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  어디에서 많이들어본...
  &lt;br/&gt;
  Replica Set, Deployment, Service, Ingress 등등
  &lt;br/&gt;
  모임에서 한번 쯤 들었던거같은 이름들..
  &lt;br/&gt;
  다음시간에는 이런 Kubernetes의 구성요소들에 대하여 더 깊게 알아보는 시간을 가지도록 하겠습니다!
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  &lt;del&gt;
   뜬금없지만
  &lt;/del&gt;
  다들 코로나 조심하세요!
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;div class=&quot;confluence-information-macro has-no-icon confluence-information-macro-information conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;info&quot;&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   참고 URL
  &lt;/p&gt;
  &lt;p&gt;
   Container Orchestration Image :
   &lt;a class=&quot;external-link&quot; href=&quot;https://www.awsforbusiness.com/what-is-container-orchestration/&quot; rel=&quot;nofollow&quot;&gt;
    https://www.awsforbusiness.com/what-is-container-orchestration/
   &lt;/a&gt;
  &lt;/p&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Sat, 06 Jun 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/06/06/97465347/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/06/06/97465347/</guid>
        
        <category>docker</category>
        
        <category>kubernetes</category>
        
        <category>k8s</category>
        
        <category>kubernetes기초</category>
        
        <category>container</category>
        
        
      </item>
    
      <item>
        <title>아틀라시안 클라우드 마이그레이션에 대한 10가지 오해와 진실</title>
        <description>&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97456877/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 안녕하세요, 오픈소스컨설팅 한진규상무입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 지라와 컨플루언스 같은 아틀라시안 제품을 사용할 때 아직은 직접 서버에 설치형으로 사용하시는 경우가 많은데요, 작년부터는 클라우드 제품을 활용하시는 분들이 늘어가는 것 같습니다.
&lt;/p&gt;
&lt;p&gt;
 최근 아틀라시안을 구매하는 신규 고객의 90%이상이 클라우드 제품을 사용하는 걸 보면, 앞으로는 클라우드 제품이 더 많은 비중을 차지 하지 않을까 하는 생각이 드네요.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아, 혹시 모르시는 분들을 위해 설명드리면, 아틀라시안의 대부분의 제품은 자사 서버에 설치 할 수 있는 설치형 제품(서버, 데이터센터)과 클라우드에 접속해서 사용할수 있는 클라우드형(SaaS) 제품 두가지로 공급이 되고 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 자, 그럼 본론으로 들어가서
&lt;/p&gt;
&lt;p&gt;
 오늘 이야기할 내용은, 아틀라시안 클라우드로 이전하는데 있어서 사람들이 흔히 알고 있는 오해와 그에 대한 진실에 대해 이야기 해보려고 합니다.
&lt;/p&gt;
&lt;p&gt;
 이 내용은 아틀라시안 블로그에 게재된 내용인데, 편안하게 읽으시라고
 &lt;s&gt;
  오역과
 &lt;/s&gt;
 의역을 담아 한글로 전달하는데 목적을 두고 적는 것이니,
 &lt;s&gt;
  오역과
 &lt;/s&gt;
 의역이 불편하신 경우 상큼하게 영어 원본을 읽으시길 권장 드립니다 ㅎㅎ
&lt;/p&gt;
&lt;p&gt;
 그 마음 충분히 이해하거든요. 워낙 발번역이라.....흠흠..
&lt;/p&gt;
&lt;p&gt;
 &lt;em&gt;
  &lt;strong&gt;
   원본 링크 :
  &lt;/strong&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/blog/platform/myths-about-moving-to-atlassian-cloud&quot; rel=&quot;nofollow&quot;&gt;
   https://www.atlassian.com/blog/platform/myths-about-moving-to-atlassian-cloud
  &lt;/a&gt;
 &lt;/em&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 일단 그럼 어떤 오해가 있는지 한번 알아볼까요?
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 오해1. 클라우드와 서버 제품은 동일하다.
&lt;/p&gt;
&lt;p&gt;
 오해2. 온프레미스(On-premise)가 클라우드보다 더 안전하게 데이터를 보관한다.
&lt;/p&gt;
&lt;p&gt;
 오해3. 온프레미스(On-premise) 관리 비용이 클라우드보다 더 싸다.
&lt;/p&gt;
&lt;p&gt;
 오해4. 대기업은 클라우드를 사용하지 않는다.
&lt;/p&gt;
&lt;p&gt;
 오해5. 운영서버 마이그레이션이 핵심이다.
&lt;/p&gt;
&lt;p&gt;
 오해6. 클라우드 마이그레션 전에 '정리'작업은 필요없다.
&lt;/p&gt;
&lt;p&gt;
 오해7. 클라우드에서는 애드온을 사용할 수 없다.
&lt;/p&gt;
&lt;p&gt;
 오해8. 애드온은 클라우드로 이관되지 않는다.
&lt;/p&gt;
&lt;p&gt;
 오해9. 클라우드 마이그레이션은 우리 조직의 니즈에 부합 할 만큼 유연하지 못하다.
&lt;/p&gt;
&lt;p&gt;
 오해10. 클라우드 마이그레이션은 우리 조직에서 수행하기에 너무 번거로운 일이다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 어떠세요? 맞다~ 맞다~ 하고 계신가요??
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 그렇다면 진실은 무엇일까요??
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해1.클라우드제품과서버제품은똑같은거아녀?지라가그놈이그놈이지....&quot;&gt;
 오해1. 클라우드제품과 서버제품은 똑같은거 아녀? 지라가 그놈이 그놈이지....
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아닙니다. 아틀라시안 클라우드 제품들이 서버 제품과 동일한 이점을 제공하긴 하지만 서버제품과는 기능과 고객경험에 있어서 약간의 차이가 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 즉, Jira Cloud 및 Confluence Cloud 고유의 차이점 뿐만 아니라 플랫폼 차이에서 오는 특징들이 있거든요.
&lt;/p&gt;
&lt;p&gt;
 일단, 클라우드 제품들은 서버제품과 메뉴바 등도 다르고, 애드온이나, 사용자관리 등 다양한 차이가 있습니다.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  Jira Cloud는 새로운 이슈보기 및 '차세대 프로젝트'를 제공하고 Confluence Cloud에는 서버제품에는 없는 새로운 페이지 편집기가 있습니다. 또한 iOS 및 Android 용 무료 모바일 앱을 사용하여 어디서나 이슈와 페이지에 쉽게 액세스하고 업데이트 할 수 있습니다. 특히, 차세대 프로젝트는 지라를 마치 트렐로처럼 쓸수 있게 해주는데요 즉, 복잡한 설정 없이 클릭만으로 워크플로우를 생성/편집/삭제 할 수 있어서 엄청 편리합니다. 서버제품에는 제공할 생각이 없는 듯 해서 좀 아쉽네요.
 &lt;/li&gt;
 &lt;li&gt;
  클라우드에서는 제품 관리 및 사용자 계정이 중앙 집중화되어 관리 됩니다. 저희가 서버 제품을 쓸때는 주로 크라우드(Crowd)라는 제품을 통해서 계정을 관리하는데요, 클라우드에서는 Atlassian Access라는 제품을 통해 비슷한 역할을 합니다. 하지만 좀 더 강력하죠. Atlassian Access는 Atlassian의 클라우드 제품 전체에 추가적인 엔터프라이즈급 보안 및 강화 된 관리 도구를 제공합니다. 클라우드 별 비용 플랜 및 청구 / 라이센스모델을 관리 할수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 이러한 기능을 익히는 가장 좋은 방법은 사용해 보는 거겠죠? 현재 서버 및 데이터센터 고객이라면, 해당 라이센스 기간동안
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  클라우드 평가판을 무료로 제공
 &lt;/span&gt;
 해 줍니다. (자세한 사항은 파트너사에 문의해 주세요)
&lt;/p&gt;
&lt;p&gt;
 그리고 저희 오픈소스컨설팅과 같은 파트너사를 통해서도 연단위/월단 빌링이 가능하기 때문에 담당자는 관리에 신경쓰지 않고 편하게 사용하실 수 있다는점. 다시한번 강조드립니다. ㅎㅎ
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해2.온프레미스(On-premise)가당연히클라우드보다더안전하게데이터를보관하겠지.중요한데이터는무조건온프레미스야!!마이프레셔~스~&quot;&gt;
 오해2. 온프레미스(On-premise)가 당연히 클라우드보다 더 안전하게 데이터를 보관하겠지. 중요한 데이터는 무조건 온프레미스야!! 마이 프레셔~스~
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아닙니다. Atlassian 클라우드 플랫폼의 핵심은 보안, 안정성, 개인 정보 및 규정 준수입니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 여러분의 회사가 Atlassian 클라우드로 전환하면, 그 순간부터 아틀라시안이 여러분 회사의 보안팀이 됩니다. 클라우드로 전환했을뿐인데, 보안팀이 딸려왔네? 요런느낌적인 느낌
&lt;/p&gt;
&lt;p&gt;
 Atlassian의 클라우드 제품은 전 세계적으로 업계에서 승인 된 규정 준수 및 데이터 개인 정보 보호 표준을 능가하며 전송 및 저장시 암호화를 통해 데이터를 보호하거든요.
&lt;/p&gt;
&lt;p&gt;
 Atlassian Access는 관리자에게 클라우드 제품을 사용하는 모든 사람을 파악하고 관리 할 수 있는 중앙 위치를 제공합니다.
&lt;/p&gt;
&lt;p&gt;
 그렇게 때문에 많은 기업이 마이그레이션의 첫 단계로 Atlassian Access에 가입합니다. 이를 통해 기존 클라우드 사용량에 대한 가시성이 향상되고 보안 기준이 설정됩니다.
&lt;/p&gt;
&lt;p&gt;
 Atlassian이 사용자를 보호하는 방법에 대해 자세히 알아 보려면
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/trust&quot; rel=&quot;nofollow&quot;&gt;
  Atlassian 보안 센터
 &lt;/a&gt;
 를 방문해보시길 권장합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해3.온프레미스(On-premise)관리비용이클라우드보다훨씬쌀껄?클라우드로가면비싸다던데...&quot;&gt;
 오해3. 온프레미스(On-premise) 관리 비용이 클라우드보다 훨씬 쌀껄? 클라우드로가면 비싸다던데...
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아닙니다. TCO (Total cost of ownership)로 보면 클라우드 제품이 온프레미스보다 저렴합니다. 온프레미스를 관리하는데 들어가는 숨은 비용이 많거든요.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97456877/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 클라우드로의 원활한 전환을 위해서 아틀라시안이 제공하는 비용절감 방안을 활용하는 것도 좋은 방법입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/cloud-migration/explore-cloud&quot; rel=&quot;nofollow&quot;&gt;
  무료 확장 클라우드 평가판 라이센스
 &lt;/a&gt;
 , 미사용 서버 메인터넌스 할인,
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/licensing/cloud/cloudmigrationfaq&quot; rel=&quot;nofollow&quot;&gt;
  기업 고객에 대한 로열티 요금정책
 &lt;/a&gt;
 등을 제공하고 있으며, 특히 학교나 비영리단체에는 할인된 가격으로 제품을 공급하고 있으니 참고하세요!
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해4.대기업은클라우드를사용하지않는다?&quot;&gt;
 오해4. 대기업은 클라우드를 사용하지 않는다?
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아닙니다. 많은 수의 대기업이 클라우드로 옮겨가고 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 포춘 500대 기업 중 80% 이상(ARM, Oracle 등)이 아틀라시안 클라우드 라이센스를 사용 중이며, 신규 고객의 90%가 클라우드 제품을 선택하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 아틀라시안의 Maren Hotvedt에 따르면,
&lt;/p&gt;
&lt;p&gt;
 그 어느때보다 많은 수의 Atlassian 서버 및 데이터센터 고객이 클라우드로 마이그레이션하고 있으며 새로운 엔터프라이즈 고객도 클라우드를 선택하고 있다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 소규모 고객만이 아니라, Redfin, Nestle, Lululemon, Pfizer, Unilever 등의 엔터프라이즈 회사도 많다고 하네요.
&lt;/p&gt;
&lt;p&gt;
 엔터프라이즈 마이그레이션에 대한 자세한 내용은 1,000유저 규모의 북미에 위치한 부동산 전문 회사
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/customers/redfin&quot; rel=&quot;nofollow&quot;&gt;
  Redfin이 최근 Atlassian 클라우드로 마이그레이션
 &lt;/a&gt;
 하고 6 만 달러 이상을 절약하여 경쟁력을 유지하고 미션에 집중할 수 있었던 사례를 확인해 보시기 바랍니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해5.운영서버마이그레이션이핵심이다?&quot;&gt;
 오해5. 운영서버 마이그레이션이 핵심이다?
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아닙니다. 오히려 계획 및 준비 과정이 마이그레이션에서 가장 크고 중요한 부분이며, 이러한 과정이 얼마나 잘 준비되느냐가 마이그레이션 성공에 가장 큰 영향을 미칩니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 특히, 여러 인스턴스를 통합하거나 많은 수의 앱이 설치된 경우 클라우드로 마이그레이션하는 데 6개월 이상이 걸릴 수 있어요.
&lt;/p&gt;
&lt;p&gt;
 이때 운영서버 이전은 하나의 과정일 뿐이며, 오히려 마이그레이션과 관련된 대부분의 작업은 운영서버  마이그레이션전과 마이그레이션 후에 유저들이 새로운 시스템에 적응하면서 이루어집니다.
&lt;/p&gt;
&lt;p&gt;
 그 과정을 살펴보면 다음과 같습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/97456877/2.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해6.클라우드마이그레션전에'정리'작업은필요없다?&quot;&gt;
 오해6. 클라우드 마이그레션 전에 '정리'작업은 필요없다?
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아닙니다. 클라우드로 이전하기 전에 이주 전에 소위 말하는 &quot;봄맞이 대청소&quot;와 같은 시간을 갖는다면 훨씬 좋은 효과를 가질 수 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 많은 조직에서 마이그레이션 전 정리작업이 필수가 아니라 &quot;하면 좋은&quot;것 정도로 간주하는데요,  Atlassian 클라우드 마이그레이션 전에 자체 관리 형 인스턴스를 구성하는 것이 중요합니다. 여기에는 사용되지 않은 공간(Space) 및 프로젝트 아카이빙, 사용자 계정 정리, Add-on Test, 커스터마이징 검토 및 최소화, 중복 제거 및 사용되지 않은 스키마, 필드 및 이슈 유형 삭제가 포함됩니다.
&lt;/p&gt;
&lt;p&gt;
 이러한 봄맞이 대청소를 실시하면 두 가지 이점이 있습니다. 첫째, 마이그레이션을 더 빠르고 원활하게 하며, 둘째, 클라우드 마이그레이션이 완료되었을 때 시스템의 데이터 및 볼륨 감소 덕분에 성능도 향상되는 경우가 많습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해7.클라우드에서는앱(애드온)을사용할수없다.&quot;&gt;
 오해7. 클라우드에서는 앱(애드온)을 사용할 수 없다.
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  아닙니다. 앱(아틀라시안에서는 애드온을 App이라고 표현) 개발자들은 더 좋고 더 많은 클라우드용 앱을 빠르게 만들어내고 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 Atlassian Marketplace는 클라우드 제품의 사용성 확장을 지원하는 1,000 개 이상의 앱을 클라우드 고객에게 제공합니다.
&lt;/p&gt;
&lt;p&gt;
 가장 인기있는 서버용 앱인 Insight Asset Management(자산관리), Jira Workflow Toolbox, JSU Automation for Jira, Structure(간트챠트 및 시각화 지원) 및 ConfiForms들은 이미 클라우드 버전을 공급하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 이 뿐이 아니라 매일 새로운 앱이 나옵니다. Atlassian은 2019 년에만 250 개의 새로운 클라우드 앱을 추가했습니다. 특히 내가 사랑하는 서버용 앱이 클라우드에는 아직 없을 경우 공급 업체에 문의하여 개발중인 제품을 확인하는 것이 좋습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해8.앱(애드온)은클라우드로이관되지않는다.&quot;&gt;
 오해8. 앱(애드온)은 클라우드로 이관되지 않는다.
&lt;/h2&gt;
&lt;p&gt;
 사실, 앱 마이그레이션은 Atlassian 및 앱 공급 업체의 주요 관심사입니다.
&lt;/p&gt;
&lt;p&gt;
 고객의 60 % 이상이 Atlassian Marketplace에서 앱을 사용하므로 마이그레이션 팀은 앱 평가 및 마이그레이션을 단순화하기 위해 노력하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 앱 평가 도구를 사용하면 서버의 앱 사용 공간과 사용량을보다 쉽게 ​​이해할 수 있습니다. 이 정보는 클라우드에서 필요할 앱에 대한 마이그레이션 계획을 작성하는 데 사용될 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 Atlassian의 Migration Assistant 도구는 팀이 앱을 얼마나 자주 사용 하는지를 표시합니다.
&lt;/p&gt;
&lt;p&gt;
 클라우드 버전을 사용할 수 있으며 마이그레이션 경로가 있는지 여부 이 기능은 현재
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1219672/confluence-cloud-migration-assistant?hosting=server&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  Confluence Cloud Migration Assistant
 &lt;/a&gt;
 및
 &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1222010/jira-cloud-migration-assistant?hosting=server&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
  Jira Cloud Migration Assistant
 &lt;/a&gt;
 에서 사용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 그러나 평가는 과정의 절반에 불과합니다.
&lt;/p&gt;
&lt;p&gt;
 현재 앱 데이터는 핵심 제품 데이터와 클라우드로 마이그레이션되지 않습니다. 앱 데이터 마이그레이션은 공급 업체와 직접 작업해야 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 이는 마이그레이션 계획 기간과 프로덕션 마이그레이션을 연장하고 복잡하게 만들 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  이러한 어려움을 완화하기 위해 Atlassian은 오버 헤드를 최소화하고 안정성을 극대화하는 앱 마이그레이션 도구를 개발하고 있습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해9.클라우드마이그레이션은우리조직의니즈에부합할만큼유연하지못하다.&quot;&gt;
 오해9. 클라우드 마이그레이션은 우리 조직의 니즈에 부합 할 만큼 유연하지 못하다.
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;color: rgb(255,0,0);&quot;&gt;
  아닙니다.
 &lt;/span&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  Atlassian은 조직이 원하는 속도로 클라우드로 이동하거나 단계별로 마이그레이션하거나 하이브리드 방식을 사용할 수 있는
  &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
   유연한 마이그레이션 도구를 공급하고 있습니다.
  &lt;/span&gt;
  &lt;br/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  처음에는 이러한 도구가 없어서 진짜 어려웠지만, 컨플루언스같은 경우는 거의 문제 없이 이관이 가능해졌고, 지라도 점점 마이그레이션 도구가 업데이트 되면서 상당부분 스트레스 받지 않고 마이그레이션이 가능하게 되었어요.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  아틀라시안에서 제공중인 무료 마이그레이션 도구 :
  &lt;br/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  ·
  &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1219672/confluence-cloud-migration-assistant?hosting=server&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
   Confluence Migration Assistant
  &lt;/a&gt;
  - 이 무료 서버 앱은 2018 년에 출시되었습니다. Confluence Server 또는 Data Center에서 클라우드로 데이터 및 사용자를 쉽게 마이그레이션 할 수 있습니다. 이 도구를 사용하여 관리자는 마이그레이션 대상, 방법 및시기를 선택할 수 있습니다.
  &lt;br/&gt;
  ·
  &lt;a class=&quot;external-link&quot; href=&quot;https://marketplace.atlassian.com/apps/1222010/jira-cloud-migration-assistant?hosting=server&amp;amp;tab=overview&quot; rel=&quot;nofollow&quot;&gt;
   Jira Cloud Migration Assistant
  &lt;/a&gt;
  - 조직은 사용자 및 그룹과 함께 프로젝트별로 Jira 인스턴스를 마이그레이션 할 수 있습니다. Migration Assistant는 조직이 클라우드 마이그레이션에보다 전략적으로 접근 할 수 있도록 도와줍니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/97456877/3.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;h2 id=&quot;id-아틀라시안클라우드마이그레이션에대한10가지오해와진실-오해10.클라우드마이그레이션은우리조직에서수행하기에너무번거로운일이다.&quot;&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  오해10. 클라우드 마이그레이션은 우리 조직에서 수행하기에 너무 번거로운 일이다.
 &lt;/span&gt;
&lt;/h2&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;http://www.osci.kr&quot; rel=&quot;nofollow&quot;&gt;
   오픈소스컨설팅
  &lt;/a&gt;
  과 같은 아틀라시안 파트너사는 이러한 문제를 해결하고 고객이 무리없이 클라우드로 이전할 수 있도록 기획 단계부터 컨설팅을 지원합니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  초기 단계에서 부터 함께 이야기를 나누다면, 더 완벽한 클라우드로의 이전이 가능해 집니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  이렇게 10가지 오해와 진실에 대해서 알아봤는데요, 클라우드제품도 편리하게 무료 트라이얼이 가능하니까 고민만 하지 마시고 한번 사용해보시길 권해 드립니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/ko/software/free&quot; rel=&quot;nofollow&quot;&gt;
   https://www.atlassian.com/ko/software/free
  &lt;/a&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  클라우드 사용 및 이전과 관련한 더 궁금한 사항은 오픈소스컨설팅으로 문의 주세요!
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;mailto:atlassian@osci.kr&quot; rel=&quot;nofollow&quot;&gt;
  atlassian@osci.kr
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Fri, 08 May 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/05/08/97456877/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/05/08/97456877/</guid>
        
        <category>아틀라시안</category>
        
        <category>atlassian</category>
        
        <category>cloud</category>
        
        
      </item>
    
      <item>
        <title>[Container 시리즈] 04. 실행중인 App 서비스를 컨테이너화 해보자!</title>
        <description>&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-information conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;info&quot;&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   Sample application으로 dockerized 하는 과정에 대해 기술
  &lt;/p&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  안녕하세요! 굉장히 오랜만에 블로그로 다시 찾아온 것 같습니다.
 &lt;/p&gt;
 &lt;p&gt;
  지난시간에 Docker의 기본적인 개념과 어떻게 동작했는지를 알아봤는데요,
  &lt;br/&gt;
  이번에는
  &lt;u&gt;
   실질적으로 사용하고있는 Application을 어떻게 Containerized 할지에 관련된 주제
  &lt;/u&gt;
  를 가지고 돌아왔습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;br/&gt;
 &lt;p&gt;
  &lt;strong&gt;
   순서는 다음과 같습니다.
  &lt;/strong&gt;
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;1. Source code clone
2. npm build
3. docker file 생성
4. docker file을 통한 docker image 생성
5. docker run을 이용한 컨테이너 실행
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#1-source-code-clone&quot; id=&quot;1-source-code-clone&quot;&gt;
   1. Source Code Clone.
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  해당 Source 들은 GitLab에 올려져 있으며.
  &lt;br/&gt;
  해당 애플리케이션 같은경우 Hostname과 현재 시간을 출력해주는 simple application입니다.
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  자 그럼 Giblab에 올려진 코드들을 가지고 와봅니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stl]# git clone http://192.168.197.132/root/stlapp.git
Cloning into 'stlapp'...
Username for 'http://192.168.197.132': kbseo
Password for 'http://kbseo@192.168.197.132': 
remote: Enumerating objects: 131, done.
remote: Counting objects: 100% (131/131), done.
remote: Compressing objects: 100% (69/69), done.
remote: Total 217 (delta 70), reused 112 (delta 56), pack-reused 86
Receiving objects: 100% (217/217), 564.33 KiB | 0 bytes/s, done.
Resolving deltas: 100% (84/84), done.
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  소스들을 서버로 잘 데리고 왔습니다.
  &lt;br/&gt;
  참고로 말씀드리자면 해당 Application은 React와 Spring Boot로 만들어졌고 maven을 통해 build하도록 되어져있습니다.
  &lt;br/&gt;
  추가로 Maven내에 npm build가 가능하도록 한 상태여서 maven 명령을 통해서 빌드가 가능합니다.
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#2-npm-build&quot; id=&quot;2-npm-build&quot;&gt;
   2. npm build
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# ./mvnw package
[INFO] Scanning for projects...
[INFO] 
[INFO] -------------------------&amp;lt; no.kantega:stlapp &amp;gt;--------------------------
[INFO] Building spring-and-react 0.1
[INFO] --------------------------------[ war ]---------------------------------
[INFO] 
[INFO] --- frontend-maven-plugin:1.6:install-node-and-npm (install node and npm) @ stlapp ---
[INFO] Installing node version v6.17.1
[INFO] Unpacking /root/.m2/repository/com/github/eirslett/node/6.17.1/node-6.17.1-linux-x64.tar.gz into /root/stl/stlapp/target/node/tmp
[INFO] Copying node binary from /root/stl/stlapp/target/node/tmp/node-v6.17.1-linux-x64/bin/node to /root/stl/stlapp/target/node/node
[INFO] Installed node locally.
[INFO] Installing npm version 3.10.10
[INFO] Unpacking /root/.m2/repository/com/github/eirslett/npm/3.10.10/npm-3.10.10.tar.gz into /root/stl/stlapp/target/node/node_modules
.....
[INFO] --- spring-boot-maven-plugin:2.0.1.RELEASE:repackage (default) @ stlapp ---
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 02:22 min
[INFO] Finished at: 2020-04-24T18:30:05+09:00
[INFO] ------------------------------------------------------------------------
[root@kbseo-test1 stlapp]# 

&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  빌드를 완료해주었습니다!
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#3-docker-file-생성&quot; id=&quot;3-docker-file-생성&quot;&gt;
   3. docker file 생성
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  이렇게 가지고 온 source를 컨테이너화 하기위하여 docker file을 먼저 생성해 줘야겠죠?
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# vim Dockerfile
FROM tomcat:8.5.50-jdk8-openjdk

MAINTAINER kbseo@osci.kr

ENV TZ=Asia/Seoul
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime

RUN rm -rf /usr/local/tomcat/webapps/ROOT
COPY target/stlapp-0.1.war /usr/local/tomcat/webapps/ROOT.war

&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  Simple application은 hostname과 time zone을 출력해주는 간단한 동작을 하는 애플리케이션 이기에
  &lt;br/&gt;
  docker file안에 timezone을 설정해주고 tomcat상에서 동작될 war파일을 복사해줍니다.
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#4-docker-file을-통한-docker-image-생성&quot; id=&quot;4-docker-file을-통한-docker-image-생성&quot;&gt;
   4. docker file을 통한 docker image 생성
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  이전 글에서 설정해드린것과 같이 docker는 image로 배포를 하기 때문에
  &lt;br/&gt;
  만들어두었던 docker file을 image화 해 줍니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;# 현재 가지고있는 이미지가 있나 확인을 해줍니다
[root@kbseo-test1 stlapp]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
[root@kbseo-test1 stlapp]# 
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  이미지가 한개도 없는것을 확인하실수 있습니다.
 &lt;/p&gt;
 &lt;p&gt;
  이미지 형태로 빌드를 해줍니다!
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker build -t stlapp:1.0 .
Sending build context to Docker daemon 252.2 MB
Step 1/6 : FROM tomcat:8.5.50-jdk8-openjdk
Trying to pull repository docker.io/library/tomcat ... 
8.5.50-jdk8-openjdk: Pulling from docker.io/library/tomcat
dc65f448a2e2: Pull complete 
346ffb2b67d7: Pull complete 
dea4ecac934f: Pull complete 
8ac92ddf84b3: Pull complete 
d8ef64070a18: Pull complete 
6577248b0d6e: Pull complete 
576c0a3a6af9: Pull complete 
6e0159bd18db: Pull complete 
944191e51caa: Pull complete 
9ee6a5ca751e: Pull complete 
Digest: sha256:d53c2079ea67db92f6d7c39e9450f641610336016fdddef5392c5afd41518e5e
Status: Downloaded newer image for docker.io/tomcat:8.5.50-jdk8-openjdk
 ---&amp;gt; b56d8850aed5
Step 2/6 : MAINTAINER jacobbaek@osci.kr
 ---&amp;gt; Running in 148cd746d772
 ---&amp;gt; 3b0a94a52842
Removing intermediate container 148cd746d772
Step 3/6 : ENV TZ Asia/Seoul
 ---&amp;gt; Running in 7398ad9609a2
 ---&amp;gt; 706e8669d2d6
Removing intermediate container 7398ad9609a2
Step 4/6 : RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime
 ---&amp;gt; Running in 1bcb6e658984

 ---&amp;gt; 453ac37a79dd
Removing intermediate container 1bcb6e658984
Step 5/6 : RUN rm -rf /usr/local/tomcat/webapps/ROOT
 ---&amp;gt; Running in f3c3bf4eb17b

 ---&amp;gt; 32f3bddc0334
Removing intermediate container f3c3bf4eb17b
Step 6/6 : COPY target/stlapp-0.1.war /usr/local/tomcat/webapps/ROOT.war
 ---&amp;gt; 3f24f0f7deaa
Removing intermediate container 134e07409a14
Successfully built 3f24f0f7deaa
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  docker build 같은경우 지난시간의 글에서 좀 더 자세히 확인 가능하십니다 ㅎ.ㅎ
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  명령어에 대해서 간단히 설명을 다시 드리자면,
  &lt;br/&gt;
  &lt;strong&gt;
   $ docker build &amp;lt;옵션&amp;gt; &amp;lt;dockerfile 경로&amp;gt;
  &lt;/strong&gt;
  &lt;br/&gt;
  저는 태그를 지정해주기 위하여 -t옵션을 사용해주었습니다.
  &lt;br/&gt;
  태그는 &amp;lt;저장소이름&amp;gt;/&amp;lt;이미지이름&amp;gt;:&amp;lt;태그&amp;gt; 형식입니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  다시 이미지를 확인해보면 좀전에 build한 이미지가 올라온 것을 확인 하실 수 있습니다!
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker images
REPOSITORY          TAG                   IMAGE ID            CREATED             SIZE
stlapp              1.0                   3f24f0f7deaa        3 minutes ago       545 MB
docker.io/tomcat    8.5.50-jdk8-openjdk   b56d8850aed5        2 months ago        529 MB
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  어라? 왜 두개의 이미지가 올라가져있을까요....?
분명히 도커 빌드는 한번만 실행했는데..
도커파일을 다시 살펴볼까요?
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;FROM tomcat:8.5.50-jdk8-openjdk
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  첫줄에서 답이 나왔습니다!
  &lt;br/&gt;
  FROM 을 통해 tomcat이미지를 먼저 받아서 그 위에 차례대로 레이어를 쌓아가면서 도커파일을 실행하기에
  &lt;br/&gt;
  이미지가 두개가 만들어지게 됩니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;ol start=&quot;5&quot;&gt;
  &lt;li&gt;
   docker run을 이용한 컨테이너 실행
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;p&gt;
  이제 Image를 만들었으니 실행해봅시다!
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@kbseo-test1 stlapp]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  아직까지 실행되고있는 컨테이너가 없네요
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker run -d -p 8081:8080 --name=stlapp stlapp:1.0
fc16ba3e9f3f03ba22a2ca0b7eb12909a8311b555ef34bcf9b0f591537a76d2a
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  명령어에 대해 간단히 설명드리자면
  &lt;br/&gt;
  &lt;strong&gt;
   $ docker run &amp;lt;옵션&amp;gt; &amp;lt;이미지이름, ID &amp;gt; &amp;lt;명령&amp;gt; &amp;lt;매개변수&amp;gt;
  &lt;/strong&gt;
 &lt;/p&gt;
 &lt;p&gt;
  이렇게 구성되어있습니다.
 &lt;/p&gt;
 &lt;p&gt;
  &lt;code&gt;
   docker run -d -p 8081:8080 --name=stlapp stlapp:1.0
  &lt;/code&gt;
  이 명령어를 보자면
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;p&gt;
    -d 데몬모드로 컨테이너를 실행하고,
   &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;
    -p 옵션을 이용하여 외부포트를 연결해줍니다
    &amp;lt;호스트포트&amp;gt;:&amp;lt;컨테이너포트&amp;gt; -&amp;gt; 8080컨테이너 포트를 8081포트를 이용해 외부로 연결시킵니다.
   &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;
    --name 컨테이너 이름을 지정해줍니다.
    여기에서는 stlapp이라는 이름을 달아주었습니다.
   &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;
    실행시킬 컨테이너와 태그정보를 입력해줍니다.
   &lt;/p&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
  결과를 한번 봐볼까요?
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
fc16ba3e9f3f        stlapp:1.0          &quot;catalina.sh run&quot;   11 minutes ago      Up 11 minutes       0.0.0.0:8081-&amp;gt;8080/tcp   stlapp
[root@kbseo-test1 stlapp]# 

&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  실행되고있는 컨테이너를 확인하실 수 있습니다.
 &lt;/p&gt;
 &lt;p&gt;
  브라우저를 통해 확인해볼까요?
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97455310/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  컨테이너 이미지의 ID와 현재 시간이 잘 출력되는것을 보실 수 있습니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  하지만 빨간색이라 눈이 너무나 아픈것같은 느낌적인 느낌입니다
  &lt;br/&gt;
  그래서 검은색으로 바꾸고 재 배포를 해볼까요??
 &lt;/p&gt;
 &lt;p&gt;
  순서는 간단합니다!
 &lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;
   실행되고 있는 컨테이너 중지
  &lt;/li&gt;
  &lt;li&gt;
   해당 컨테이너 삭제
  &lt;/li&gt;
  &lt;li&gt;
   소스수정
  &lt;/li&gt;
  &lt;li&gt;
   소스빌드, 컨테이너 빌드
  &lt;/li&gt;
  &lt;li&gt;
   컨테이너 실행
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#1-실행되고-있는-컨테이너-중지&quot; id=&quot;1-실행되고-있는-컨테이너-중지&quot;&gt;
   1. 실행되고 있는 컨테이너 중지
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  단칼에 중지시켜 줍니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 src]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
fc16ba3e9f3f        stlapp:1.0          &quot;catalina.sh run&quot;   29 minutes ago      Up 29 minutes       0.0.0.0:8081-&amp;gt;8080/tcp   stlapp

 
[root@kbseo-test1 src]# docker kill stlapp
stlapp


[root@kbseo-test1 src]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                       PORTS               NAMES
fc16ba3e9f3f        stlapp:1.0          &quot;catalina.sh run&quot;   29 minutes ago      Exited (137) 3 seconds ago                       stlapp
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  docker kill 명령어를 통해 중지시켜준 후
  &lt;br/&gt;
  docker ps 를 통해 확인해보면 상태가 바뀐것을 보실 수 있습니다.
  &lt;br/&gt;
  브라우저를 통해 접속해봐도 접속이 안되는것을 보실 수 있죠
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#2-해당-컨테이너-삭제&quot; id=&quot;2-해당-컨테이너-삭제&quot;&gt;
   2. 해당 컨테이너 삭제
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  프로세스를 삭제시켜 줍니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 src]# docker rm stlapp
stlapp

[root@kbseo-test1 src]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

&lt;/code&gt;&lt;/pre&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#3-소스수정&quot; id=&quot;3-소스수정&quot;&gt;
   3. 소스수정
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  css코드를 수정하여 색상을 변경해줍니다.
  &lt;del&gt;
   저는 블랙블랙으로 바꿨습니다.(TMI)
  &lt;/del&gt;
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#4-소스빌드&quot; id=&quot;4-소스빌드&quot;&gt;
   4. 소스빌드
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  소스를 수정했으니 재빌드를 해줘야겠죠?
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# ./mvnw package
INFO] Scanning for projects...
[INFO] 
[INFO] -------------------------&amp;lt; no.kantega:stlapp &amp;gt;--------------------------
[INFO] Building spring-and-react 0.1
[INFO] --------------------------------[ war ]---------------------------------
[INFO] 
[INFO] --- frontend-maven-plugin:1.6:install-node-and-npm (install node and npm) @ stlapp ---
[INFO] Node v6.17.1 is already installed.
[INFO] NPM 3.10.10 is already installed.
[INFO] 
[INFO] --- frontend-maven-plugin:1.6:npm (npm install) @ stlapp ---
[INFO] Running 'npm install' in /root/stl/stlapp/frontend
...
...
[INFO] --- spring-boot-maven-plugin:2.0.1.RELEASE:repackage (default) @ stlapp ---
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 43.467 s
[INFO] Finished at: 2020-04-27T20:10:43+09:00
[INFO] ------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  소스를 빌드했으니 도커를 빌드해봅시다!
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker build -t stlapp .
Sending build context to Docker daemon 252.2 MB
Step 1/6 : FROM tomcat:8.5.50-jdk8-openjdk
 ---&amp;gt; b56d8850aed5
Step 2/6 : MAINTAINER jacobbaek@osci.kr
 ---&amp;gt; Using cache
 ---&amp;gt; 3b0a94a52842
Step 3/6 : ENV TZ Asia/Seoul
 ---&amp;gt; Using cache
 ---&amp;gt; 706e8669d2d6
Step 4/6 : RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime
 ---&amp;gt; Using cache
 ---&amp;gt; 453ac37a79dd
Step 5/6 : RUN rm -rf /usr/local/tomcat/webapps/ROOT
 ---&amp;gt; Using cache
 ---&amp;gt; 32f3bddc0334
Step 6/6 : COPY target/stlapp-0.1.war /usr/local/tomcat/webapps/ROOT.war
 ---&amp;gt; Using cache
 ---&amp;gt; 3f24f0f7deaa
Successfully built 3f24f0f7deaa
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  이미지가 만들어졌는지 확인해볼까요?
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker images
REPOSITORY          TAG                   IMAGE ID            CREATED             SIZE
stlapp              1.0                   3f24f0f7deaa        3 hours ago         545 MB
stlapp              latest                3f24f0f7deaa        3 hours ago         545 MB
docker.io/tomcat    8.5.50-jdk8-openjdk   b56d8850aed5        2 months ago        529 MB
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  하나의 이미지가 추가로 생성된 것을 보실 수 있습니다!
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#5-컨테이너-실행&quot; id=&quot;5-컨테이너-실행&quot;&gt;
   5. 컨테이너 실행
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  돌려봅니다
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker run -d -p 8081:8080 --name=stlapp stlapp
5140e8332057ed23c4bf491a36d2d63fa0d09f0ffc4378073e145c2626075c30
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  잘 올라가져있는지 확인해볼까요?
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
dd58841261fa        stlapp              &quot;catalina.sh run&quot;   55 seconds ago      Up 55 seconds       0.0.0.0:8081-&amp;gt;8080/tcp   stlapp
&lt;/code&gt;&lt;/pre&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/97455310/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;p&gt;
  이제 깔끔한 BLACK 색상으로 바뀌었습니다.
 &lt;/p&gt;
 &lt;p&gt;
  이렇게 제 local환경에서 테스트한 컨테이너들에게 TAG를 지정하여서 버전관리도 할 수 있습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker tag stlapp:latest 192.168.197.130:5000/stlapp_kb:1.2.0

[root@kbseo-test1 stlapp]# docker images
REPOSITORY                       TAG                   IMAGE ID            CREATED             SIZE
192.168.197.130:5000/stlapp_kb   1.2.0                 3e72ae5de27a        5 minutes ago       545 MB
stlapp                           latest                3e72ae5de27a        5 minutes ago       545 MB
docker.io/tomcat                 8.5.50-jdk8-openjdk   b56d8850aed5        2 months ago        529 MB
[root@kbseo-test1 stlapp]# 
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  테스트를 끝냈으니 registry에 올려줄 차례죠
 &lt;/p&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker push 192.168.197.130:5000/stlapp_kb:1.2.0
The push refers to a repository [192.168.197.130:5000/stlapp_kb]
The push refers to a repository [192.168.197.130:5000/stlapp_kb]
Get https://192.168.197.130:5000/v1/_ping: http: server gave HTTP response to HTTPS client
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  어랏? 안돼네요?
  &lt;br/&gt;
  이유는 바로 도커는 https 통신을 하기 때문입니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  고로 저는 http 통신을 하기위해
  &lt;br/&gt;
  docker에게 직접 친절히 사용하고자 하는 ip를 등록해주도록 하겠습니다.
 &lt;/p&gt;
 &lt;h3&gt;
  &lt;a href=&quot;#docker-insecure&quot; id=&quot;docker-insecure&quot;&gt;
   docker insecure
  &lt;/a&gt;
 &lt;/h3&gt;
 &lt;p&gt;
  여러가지의 방법이 있지만
  &lt;br/&gt;
  저는 daemon.json 파일 안에 등록을 해주도록 하겠습니다.
  &lt;br/&gt;
  (가장 간단해서 이방법으로 하였습니다 히힛)
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;ol&gt;
  &lt;li&gt;
   /etc/docker/daemon.json 수정
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# cat /etc/docker/daemon.json 
{
&quot;insecure-registries&quot;:[&quot;192.168.197.130:5000&quot;]
}
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  사용할 registry 주소와 포트를 입력해줍니다.
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;
   dpcker 데몬 재기동
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# service docker restart
Redirecting to /bin/systemctl restart docker.service
&lt;/code&gt;&lt;/pre&gt;
 &lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;
   레지스트리에 login
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker login http://192.168.197.130:5000
Username: admin
Password: 
Login Succeeded
&lt;/code&gt;&lt;/pre&gt;
 &lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;
   레지스트리에 push
  &lt;/li&gt;
 &lt;/ol&gt;
 &lt;pre&gt;&lt;code&gt;[root@kbseo-test1 stlapp]# docker push 192.168.197.130:5000/stlapp_kb:1.2.0
The push refers to a repository [192.168.197.130:5000/stlapp_kb]
c20036844421: Pushed 
64bc7cab37ab: Pushed 
caeac141f483: Layer already exists 
5245df7d360d: Layer already exists 
78f5460c83b5: Layer already exists 
c601709dd5d2: Layer already exists 
72ce39f2b7f6: Layer already exists 
33783834b288: Layer already exists 
5c813a85f7f0: Layer already exists 
bdca38f94ff0: Layer already exists 
faac394a1ad3: Layer already exists 
ce8168f12337: Layer already exists 
1.2.0: digest: sha256:93e8b021981faed5cb1e5b22f4c0694f841afc1aa4502fff78d7edf9ffdb97cf size: 2840
[root@kbseo-test1 stlapp]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  짜잔! 등록이 되었습니다
 &lt;/p&gt;
 &lt;p&gt;
  이번시간에는 간단한 Application을 컨테이너화 하여 실행하는거 까지 함께 했는데요
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  간단하다고 했지만 실질적으로 여러 작업이 들어갔었습니다
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  그래서 다음시간에는 이를 좀 더 간단히 수행하기위해
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  젠킨스를 이용하여 작업을 해보도록 하겠습니다!
  &lt;br/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  뿅!
 &lt;/p&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;</description>
        <pubDate>Thu, 30 Apr 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/04/30/97455310/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/04/30/97455310/</guid>
        
        <category>docker</category>
        
        <category>kubernetes</category>
        
        <category>dockerize</category>
        
        <category>containerize</category>
        
        <category>도커</category>
        
        <category>컨테이너</category>
        
        
      </item>
    
      <item>
        <title>오픈소스에 기여하는 방법에 대하여 - #2 새로운 프로젝트 시작하기</title>
        <description>&lt;p&gt;
 이전 편에 이어, 새로운 오픈소스 프로젝트를 시작하는 방법에 대해서 설명하고자 합니다.
&lt;/p&gt;
&lt;p&gt;
 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://tech.osci.kr/2020/04/09/94568493/&quot; rel=&quot;nofollow&quot;&gt;
  오픈소스에 기여하는 방법에 대하여 - #1 기존 프로젝트 활용하기
 &lt;/a&gt;
 보러 가기
&lt;/p&gt;
&lt;h1 class=&quot;auto-cursor-target&quot; id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-2.기여#2-아니야!내가새로만들래!&quot;&gt;
 &lt;strong&gt;
  2. 기여 #2 - 아니야! 내가 새로 만들래!
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;p&gt;
 새로운 오픈소스 소프트웨어 프로젝트의 시작은 요구 사항을 만족하는 기존 프로젝트를 발견하지 못한 경우나 기존의 유사 프로젝트에 새로운 기능에 대한 수용 요구가 받아들여지지 않은 경우 등에 내리는 최후의 선택이라고 볼 수 있습니다. 그 밖에 자주 발생하는 새 프로젝트 시작 요인으로는 개인적 취향에 따른 것인데, 기존 프로젝트에 사용된 개발 언어가 마음에 들지 않는 경우도 많습니다.
&lt;/p&gt;
&lt;p&gt;
 실제 오픈 소스 소프트웨어들은 다양한 라이선스 정책을 가지고 있지만, 거의 대부분은 기존의 코드에서의 브랜치가 문제가 되는 경우는 많이 없습니다. 자신이 순환 구조에의 참여가 어렵다고 느끼는 경우, 프로젝트 결과물의 설계 구조에 전혀 동의 할 수 없는 경우, 마지막으로는 기존 프로젝트의 핵심 개발자, 관리자 그룹을 개인적으로 선호하지 않는 경우 등이 있을 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 일단 여러 동기에 의하여, 새로운 프로젝트가 시작되면, 상용 소프트웨어의 개발과 유사한 과정을 거치게 되는데, 이 과정은 같은 동기와 목표 의식을 가진 핵 심 개발자들로 개발팀을 구성하고, 요구 분석을 더욱 견고하게 한 뒤, 각종 위험 요인 분석, 일정 만들기 등의 절차적인 작업들로 시작됩니다.
&lt;/p&gt;
&lt;p&gt;
 그 가운데 위험 요인 분석에는, 이 새로운 프로젝트가 기존 프로젝트들 에 비하여 경쟁력을 가질 수 있는지, 개발과 추후 관리를 위한 충분한 자원자를 확보할 수 있는지, 개발에 필요한 장비가 확보 가능한지 등을 포함하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 프로젝트의 시작 단계에서부터 소스의 관리, 버그의 관리, 개발자들 간의 원활한 의사소통을 위하여 Github와 같은 오픈소스 소프트웨어 개발자 사이트를 이용할 수 있지만, 많은 초기의 프로젝트의 경우, 프로젝트의 시작 동기, 요구 사항, 설계 등이 기술된 공식적 문서의 부족이나, 다운로드가 가능한 소프트웨어 릴리즈가 없다는 이유로 개발자 지원 사이트에 등록된다 해도 커뮤니티 형성 등의 파급 효과를 기대하기는 어렵긴 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-첫번째할일.프로토타입구현&quot;&gt;
 첫번째 할 일. 프로토타입 구현
&lt;/h3&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 소프트웨어가 커뮤니티의 관심을 끌기 위한 최소한의 작업은 고품질의 프로토타입을 완성하는 일입니다. 프로토타입의 개발은 비교적 소수의 폐쇄적인 핵심 개발자 그룹을 중심으로 이루어집니다. 따라서 개발자들 사이의 의견 교환 및 의사 결정을 위한 시스템의 존재 여부는 크게 문제가 되지 않지만, 프로토타입 구현이 진행되면서, 최초의 요구 사항이 일부 수정되고 그 결과가 설계의 변경을 필요로 하는 경우도 많아, 구성원 사이의 의사소통 방법과 최소한의 문서 화는 노력이 반드시 필요합니다.
&lt;/p&gt;
&lt;p&gt;
 많은 오픈 소스 소프트웨어 프로젝트에서는 상용의 대형 소프트웨어 개발 방식에서 사용되는 소프트웨어 공학적 개발 방법론이 사용되지 않으며, 설계 방식과 참여한 개발자들의 취향에 따른 개발 방식이 사용되는게 일반적입니다. 하지만, 오픈 소스 개발의 가장 중요한 특징인 분산 개발을 효과적으로 수행하고, 소스 코드의 재사용 가능성을 높이기 위하여 모듈화, 계층화된 소프트웨어 설계를 하는 것이 중요합니다.
&lt;/p&gt;
&lt;p&gt;
 설계는 이전에 있던 유사 프로젝트의 설계를 바탕으로 이루어지기도 하며, 더 많은 경우는, 개발자들의 혁신 의지에 따라, 새로운 설계를 추구하게 됩니다. 프로토타입 구현의 완성도와 설계 특징들은, 프로젝트의 동기와 목표에 수긍하는 개발자들을 커뮤니티에 끌어들이고, 그들의 적극적인 피드백을 유도하는 중요한 원동력입니다.
&lt;/p&gt;
&lt;p&gt;
 따라서 프로토타입은 기본적인 기능 요구를 만족하며, 안정적인 동작을 해야 하며, 단순 명료한 소프트웨어 구조를 유지 하는 것이 바람직하며. 또한 기능적인 부분을 포함하여 개선할 여지도 있어야 개발자들이 많이 참여를 하게 될 것입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568500/0.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 프로토타입의 배포 이전에 반드시 거쳐야 하는 단계는 내부 시험입니다. 이 단계는 커뮤니티 참여자를 끌어 들이기 위하여, 최초로 오픈되는 소프트웨어가 그럴 듯하게 보여야할 뿐만 아니라 높은 수준의 안정성도 확보되어야 한다는 관점에서 매우 중요합니다. 대개의 프로젝트에서  별도의  QA, 테스팅 도구나 정교한 방법론은 잘 사용되지 않으며, 최근에는 가상 머신을 이용하여, 다양한 시스템 환경에서의 테스팅을 이전 보다는 더 용이하게 할 수 있다는 특징이  있습니다. 주로 모듈 단위로 설계, 구현되는 소프트웨어 구조 때문에 오픈 소스 프로젝트에서는 기존의 라이브러리들을 적극적으로 활용하게 되며, 많은 경우 각 모듈 또한 라이브러리 형식으로 개발되는 게 일반적입니다.  사실 개발되는 많은 오픈소스 소프트웨어들이 패키지 형태의 완성품보다는 라이브러리 형태의 모듈이 상당히 많습니다.
&lt;/p&gt;
&lt;p&gt;
 프로토타입 개발자들은 오픈 소스 프로젝트로서 성공적인 정착을 위해 배포 전에 호환성, 가이드, 편의성 문제의 해결에 많은 노력을 기울여야 하며,  다양한 빌드도구를 활용하여 개발자들이 손쉽게 우리가 만든 소프트웨어를 개발하고 테스팅할 수 있는 환경을 만들어주는 것이 중요합니다.
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-두번째.결과물배포&quot;&gt;
 두번째. 결과물 배포
&lt;/h3&gt;
&lt;p&gt;
 프로그램 배포는 완성된 프로토타입을 공개함으로써, 프로젝트를 오픈소스 소프트웨어 순환 구조 안에서 발전 하도록 만들기 위한 단계입니다. 프로젝트의 오픈과 소프트웨어의 배포는 BitBucket, GitHub과 같은 오픈소스 프로젝트 사이트를 이용할 수 있습니다. 하지만 GitHub만 따져도
 &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
  &lt;strong&gt;
   &lt;span&gt;
   &lt;/span&gt;
   현재 등록된 프로젝트의 수가 이미 수십만 개를 넘었기 때문에
  &lt;/strong&gt;
 &lt;/span&gt;
 , 초기 단계의 프로젝트가 검색 단계에서 발견되어 커뮤니티의 주목을 받기는 쉽지가 않은 상황입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568500/1.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;createlink&quot; href=&quot;https://wiki.osci.kr/pages/createpage.action?spaceKey=CIS&amp;amp;title=%ED%97%88%EA%B1%B1%21+%EC%88%98%EC%8B%AD%EB%A7%8C%EA%B0%9C%21&amp;amp;linkCreation=true&amp;amp;fromPageId=91696766&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: underline;&quot;&gt;
  허걱! 1억개!
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 배포를 통해 성공적인 커뮤니티 기반 오픈 소스 프로젝트가 되기 위해서는 프로젝트 관리 구조에 대한 프로세스 등의 여러 가지 중대한 결정들이 필요합니다. 프로젝트 관리 구조는 개발자 그룹과 최종적으로 프로젝트의 방향을 결정하는 의사 결정 그룹, 그리고 의사 결정 과정을 의미하는 것입니다. 즉, 배포를 통해서 프로젝트의 소유가 초기의 핵심 개발자 그룹에서 커뮤니티로 바뀐다는 점을 바탕으로, 프로젝트에 더 많은 사람들이 참여할 수 있는 구조와 의사 결정 과정을 만드는 것인데, 이 관리 구조는 프로젝트 결과물의 성격에 따라 다르게 결정되어야 합니다. 예를 들어 운영체제의 커널 또는 그의 일부와 같이 기술적 위험이 수반되는 프로젝트의 경우에는 보수적 관점에서의 관리를 추구하여야 합니다.
&lt;/p&gt;
&lt;p&gt;
 새로운 기능의 수용, 소스 코드의 수정 등에 매우 신중한 결정을 해야 하며, 시험 및 새로운 릴리즈에 관한 중앙집중형 통제권을 유지하는 것이 바람직합니다. 반면에 GUI와 같은 사용자 편의 위주의 프로젝트는 다양한 기능적 요구를 빠르게 수용하기 위한 관리 스타일이 좋다. 초기의 프로젝트에서는 메일링 리스트, 뉴스그룹, 포럼 등을 이용 한 의견 교환과 묵시적인 합의에 의하여 프로젝트가 진행될 수 있으나, 프로젝트가 점차 명성을 얻어 커뮤니티가 커지면, 공개적이면서도 좀 더 명확한 의사 결정 구조를 요구합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 여러 관리 스타일에도 불구하고 커뮤니티를 기반으로 발전하는 오픈 소스 프로젝트에서는 개발자, 사용자들의 모든 형태의 기여(기능 추가, 버그 수정, 버그 리포팅, 새로운 기능 요구, 등)가 반드시 권장되야 하며, 개발자들의 기여 내용이 빠르게 프로젝트에 반영되어야 합니다. 배포 전에 결정해야 할 또 다른 중요한 사항은 공개될 소스의 라이선스를 결정하는 것입니다.
&lt;/p&gt;
&lt;p&gt;
 OSI(Open Source Initiative)의 오픈 소스 정의는 오픈 소스 에 대한 명확한 가이드라인으로 사용되고 있으며, 라이선스가 이 가이드라인을 만족하면, 오픈소스 소프트웨어라고 할 수 있습니다. 많은 오픈 소스 소프트웨어들이 GPL(Generic Public Licence) 또는 LGPL(Lesser GPL) 라이선스를 가지고 있지만, GPL 버전들 사이의 차이를 비롯하여, OSI에 등록된 다양한 오픈소스 라이선스들의 미묘한 차이점은 오픈소스 개발자 들이 프로젝트에의 참여 여부를 결정하는 한 요인이 되기도 합니다.
&lt;/p&gt;
&lt;p&gt;
 기타 결정 사항에는 커뮤니티 참여자들의 주 통신 방법과 소스 코드로의 접근방법 등이 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-세번째!개발자간의사소통&quot;&gt;
 세번째! 개발자간 의사소통
&lt;/h3&gt;
&lt;p&gt;
 개발자간 소통 방법에는 커뮤니티 참여자의 성격(개발자, 관리자, 사용자 등)에 따른 메일링 리스트, 포럼과 그들의 아카이브, 버그 리포트, 프로젝트 관련 문서, FAQ 등이 있습니다. 버그 리포트는 사용자와 개발자의 공식적인 통신 방법으로, 오픈 소스 소프트웨어 개발자 사이트들이 공통으로 제공하는 버그 트래킹 시스템을 이용합니다. 별도의 홈페이지를 이용하여 프로젝트를 공개한다면, Bugzilla, Trac, Redmine과 같은 버그 트래킹 시스템을 설치하여 이용할 수 있으며,
 &lt;span&gt;
 &lt;/span&gt;
 &lt;u&gt;
  &lt;span style=&quot;color: rgb(255,0,0);&quot;&gt;
   &lt;strong&gt;
    아틀라시안의 JIRA를 오픈소스 개발자용 버전으로 받아 사용하는 방법도 있습니다.(아틀라시안 강추!!)
   &lt;/strong&gt;
  &lt;/span&gt;
 &lt;/u&gt;
&lt;/p&gt;
&lt;p&gt;
 버그 트래킹 시스템은 버그를 등록 하고, 누가 그것을 담당하여 수정할 지를 할당하고, 현재 처리 상태는 어떤지, 그리고 그 버그에 대한 의견 교환을 하는 등, 버그의 발생부터 해결까지의 전 과정에 대한 체계적인 관리 방법을 제공합니다. 소스 코드의 경우 안정된 배포 버전, 흔히 베타 버전라고 하는 외부용 시험 버전, 그리고 현재 개발이 진행 중인 소스 코드 스냅샷, 세 가지를 모두 공개하는 것이 보통입니다.
&lt;/p&gt;
&lt;p&gt;
 소스 코드 스냅샷 공개는 개발자들 이 소스의 버전 관리를 위하여 사용하고 있는 소스 코드 버전 관리 서버에 로그인하여 소스에 읽을 수 있도록 하는 것입니다. 소스 코드의 공개는 오픈소스 소프트웨어의 가장 큰 미덕으로 누구나 쉽게 다운로드, 리뷰, 빌드를 할 수 있도록 하고, 궁극적으로 패치를 만들어 프로젝트 관리자에게 보낼 수 있어야 합니다.
&lt;/p&gt;
&lt;p&gt;
 많은 오픈 소스 프로젝트들은 홈페이지 또는 배포된 소스에 프로젝트 컨트리뷰터(기여자)와 커미터들을 나열함으로써, 그들의 기여에 감사하고, 동시에 그 목록에 없는 개발자, 사용자들에게 동기를 부여하고 있으며 커리어 개발의 도구로도 활용되고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#2새로운프로젝트시작하기-네번째,커뮤니티기반개발&quot;&gt;
 네번째, 커뮤니티 기반 개발
&lt;/h3&gt;
&lt;p&gt;
 일단 프로젝트의 프로토타입, 소스가 공개되어, 점차 알려지고, 사용자,  개발자 등의 관심을 끌어, 커뮤니티가 형성되면 오픈소스 순환 구조에 의해 프로젝트는 진화하는 게 일반적입니다. 공개에 앞서 결정된 의사 결정 구조 등에 의거하여 수정 버전의 릴리즈, 기능이 대폭 강화된 버전업 등이 이루어지며, 사용 중에 발생하는 버그의 리포팅 및 수정, 기능 추가 요구 등이 커뮤니티 측에서도 이루어지며, 그 결과가 프로젝트 관리자 그룹에 의해 반영됩니다.
&lt;/p&gt;
&lt;p&gt;
 이 순환 구조가 얼마나 원활하게 운영되는지가 결국 오픈소스 소프트웨어 프로젝트의 성패를 결정하게 되며, 이 구조의 원활한 순환과 효율성은 모든 참여자 사이의 의사소통 및 의사 결정 과정 등, 배포 전에 내려진 여러 결정에 의해 좌우됩니다. 오픈소스 소프트웨어가 커뮤니티에 의해 진화한다는 일반적인 인식에도 불구하고, 그 프로젝트를 처음 시작하고, 많은 경우 결국 관리하게 되는 코어 개발자 그룹의 지속적인 관심과 개선 의지는 프로젝트 성공의 가장 중요한 요인이 됩니다.
&lt;/p&gt;
&lt;p&gt;
 많은 오픈 소스 소프트웨어 프로젝트 참여의 동기가 ‘재미’로 시작되는 경우입니다. 하지만, 오픈소스 순환 구조에 안정적으로 들어선 아주 성공적인 프로젝트들(예: 빅데이터 프로젝트, NoSQL 등)은 그 결과가 상업적인 활동에 점차 많이 적용되면서, 기술 지원과 새로운 기능 요구에 대하여 시기적절한 대응이 요구되며, 프로젝트의 핵심 개발자, 관리자 그룹에게는 더 빠른 진화를 할 수 있는 추가적인 동력이 필요하게 되고, 이 과정에서 많은 경우 기술 지원에 대한 대가로서 금전적 보상이 따르는 경우가 많아져 많은 개발자들이 이러한 오픈소스 개발에 관심을 가지게 되었습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 간략하게나마 오픈소스에 기여하는 방법에 대해 살펴보았는데 읽을만 하셨나요? 사실 바쁘게 업무 시스템관리하면서 오픈소스하기가 쉽지 않습니다. 대부분의 오픈소스 개발자들이 재미로 본인의 여가시간을 활용하여 시작한 경우가 대부분입니다. 앞으로 조금만 시간을 들여서 유튜브 동영상, 게임하시는 시간 조금 줄이고 간단한 오픈소스 활용부터 하시는 건 어떨까요?
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  이런 소프트웨어 엔지니어가 되선 안되잖아요. ^^
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568500/2.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;</description>
        <pubDate>Thu, 09 Apr 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/04/09/94568500/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/04/09/94568500/</guid>
        
        <category>오픈소스</category>
        
        <category>기여</category>
        
        <category>기여방법</category>
        
        <category>리누스</category>
        
        <category>토발즈</category>
        
        <category>리눅스</category>
        
        <category>오픈소스컨설팅</category>
        
        
      </item>
    
      <item>
        <title>오픈소스에 기여하는 방법에 대하여 - #1 기존 프로젝트 활용하기</title>
        <description>&lt;p&gt;
 &lt;span style=&quot;color: rgb(51,51,51);&quot;&gt;
  오늘은 오픈소스에 기여하는 실제적인 방법이 어떤 것이 있는지에 대해서 설명하도록 하겠습니다.
  &lt;img src=&quot;/assets/images/94568493/0.svg&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(51,51,51);&quot;&gt;
  대표적인 오픈소스인 리눅스만 하더라도 리누스 토발즈가 처음 그 코드를 공개했을 때 세계 최대 규모의 오픈소스 소프트웨어가 될 거라는 생각조차 못했을 것입니다. 여전히 토발즈는 커널의 승인 여부를 혼자 결정하고 있지만 누구나 개선될 수 있는 소스코드를 보내게 되고 그것이 도움이 된다고 판단되면  해당 소스코드의 저자(Author) 항목에 기여자(Contributor)가 되어 다음 릴리즈 되는 버전에 이름이 나오게 되었습니다. 이는 유명해지려는 사람들의 욕구(과시욕)를 충족시켜 주었을 뿐더러 개발자들에게 돈 한푼 주지 않고도 커널의 버그 수정, 드라이버 개발, 기능 추가를 할 수 있는 중요한 원동력이 되었습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(51,51,51);&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
    &lt;img src=&quot;/assets/images/94568493/1.jpeg&quot;/&gt;
   &lt;/span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;
 화끈한 창시자
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  리누스 베네딕트 토발즈(Linus Benedict Torvalds,
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 1969년
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 12월 28일
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  &lt;span&gt;
  &lt;/span&gt;
  ~ )는
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 스웨덴
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  계
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 핀란드
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  인
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 소프트웨어
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  &lt;span&gt;
  &lt;/span&gt;
  개발자이다.
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 &lt;strong&gt;
  리눅스의 아버지
 &lt;/strong&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  로 유명하며, 분산
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 버전 관리 시스템
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  인
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://namu.wiki/w/Git&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot; title=&quot;Git&quot;&gt;
  Git
 &lt;/a&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  &lt;span&gt;
  &lt;/span&gt;
  등을 만들었다. 그의 종특은 맘에 안드는 것은 뭐든지 까는 것으로, 거친 언사도 서슴지 않으며, 일반인들과도 뉴스그룹, 이메일 등지에서 욕설섞인 배틀을 자주 뜨는 현장을 목격 할 수 있
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  다. 특히 리눅스 개발 커뮤니티의 분위기를 살벌하게 만드는 일등 공신이 리누스 본인인데, 오픈소스 개발이라고 하면 누구나 편하게 자신의 코드를 커밋할 수 있을 것 같지만
  &lt;span&gt;
  &lt;/span&gt;
  현실은 시궁창으로, 리눅스에 함부로 손을 댄 사람은 리누스에게 쌍욕을 먹고 멘붕을 하게 되기 일쑤다. 소스 코드 리뷰에서 심각하게 결함이 있는 부분이나 마음에 안드는 부분을 가차없이 까내리는 모습이 거의
  &lt;span&gt;
  &lt;/span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://namu.wiki/w/%EA%B3%A0%EB%93%A0%20%EB%9E%A8%EC%A7%80&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot; title=&quot;고든 램지&quot;&gt;
   고든 램지
  &lt;/a&gt;
  급.
  &lt;span&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 기여의 1단계로 보자면 우선 내가 사용하고 있는 오픈소스에 대한 관심과 그것이 가진 기능을 활용해 보는 것이 첫번째일 것입니다. 어떤 업무시스템 또는 소프트웨어를 개발하고자 하는 경우 개발하고자 하는 기능에 대한 충분한 분석을 한 뒤, 이미 존재하는 오픈 소스 소프트웨어 프로젝트들이면 내가 원하는 요구 사항을 만족하는 것이 있는지 확인하는 작업부터가 시작일 것입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-1.기여#1-있는거참여할래!&quot;&gt;
 &lt;strong&gt;
  1.  기여 #1 - 있는거 참여할래!
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-가.오픈소스프로젝트검색&quot;&gt;
 가. 오픈소스 프로젝트 검색
&lt;/h3&gt;
&lt;p&gt;
 현재 오픈소스 프로젝트는 셀 수 없을 정도로 많으며, 해당 프로젝트가 관리되고 있는 저장소도 각각 다릅니다. 이렇게 많은 프로젝트들 중 특정 프로젝트를 찾기 위해 다음과 같은 방법을 사용할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h4 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(1)구글링&quot;&gt;
 (1) 구글링
&lt;/h4&gt;
&lt;p&gt;
 잘 알려진 유명한 오픈소스 프로젝트들은 타이틀만으로도 구글링을 통해 충분히 검색할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/2.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-1 구글링을 이용한 프로젝트 검색]
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h4 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(2)오픈소스저장소내검색&quot;&gt;
 (2) 오픈소스 저장소 내 검색
&lt;/h4&gt;
&lt;p&gt;
 GitHub, SourceForge, Bitbucket, Google Code 등 오픈소스 저장소에 접속하여 직접 검색합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/3.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-2 오픈소스 저장소 내 프로젝트 검색] - 아이고 많기도 하여라!
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h4 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(3)오픈소스재단내검색&quot;&gt;
 (3) 오픈소스 재단 내 검색
&lt;/h4&gt;
&lt;p&gt;
 아파치 재단, 리눅스 재단, 모질라 재단 등 오픈소스 재단에 접속하여 직접 검색할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/4.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-3 오픈소스 재단 내 프로젝트 검색]
&lt;/p&gt;
&lt;p&gt;
 그 밖에
 &lt;span&gt;
 &lt;/span&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;http://www.findbestopensource.com/&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot;&gt;
  &lt;u&gt;
   http://www.findbestopensource.com
  &lt;/u&gt;
 &lt;/a&gt;
 ,
 &lt;span&gt;
 &lt;/span&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.openhub.net/&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot;&gt;
  &lt;u&gt;
   https://www.openhub.net/
  &lt;/u&gt;
 &lt;/a&gt;
 &lt;span&gt;
 &lt;/span&gt;
 등의 사이트에서도 검색할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-나.오픈소스프로젝트참여&quot;&gt;
 나. 오픈소스 프로젝트 참여
&lt;/h3&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 오픈소스 프로젝트에 참여하는 방법은 다음과 같이 아주 다양합니다.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  버그 리포트
 &lt;/li&gt;
 &lt;li&gt;
  커뮤니티 활동을 통한 의견 교류
 &lt;/li&gt;
 &lt;li&gt;
  프로젝트 문서 수정 또는 번역
 &lt;/li&gt;
 &lt;li&gt;
  기능 등록 및 수정 요청
 &lt;/li&gt;
 &lt;li&gt;
  패치 요청
 &lt;/li&gt;
 &lt;li&gt;
  커미터 또는 컨트리뷰터 활동
 &lt;/li&gt;
 &lt;li&gt;
  한글 번역
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 * 커미터(Committer) : 프로젝트내에서 직접 코드를 push할 수 있는 권한을 가진 사람
&lt;/p&gt;
&lt;p&gt;
 * 컨트리뷰터(Contributter) : 패치 등의 소스 코드를 제공하는 사람
&lt;/p&gt;
&lt;p&gt;
 즉, 반드시 코드를 수정, 작성해야만 프로젝트에 참여하는 것이 아니고 자신이 할 수 있는 부분에서 꾸준한 관심과 희생정신을 가지고 활동하는 것이 바람직합니다.
&lt;/p&gt;
&lt;p&gt;
 개발자에게 있어 커미터 또는 컨트리뷰터가 되는 것이 가장 이상적인 참여 방법이 될 수 있으며, 일반적인 과정은 다음과 같습니다.
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(1)기술및사용법습득과개발환경구축&quot;&gt;
 (1) 기술 및 사용법 습득과 개발환경 구축
&lt;/h3&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 오픈소스 프로젝트에서 사용하는 언어 및 프레임워크 등의 기술을 습득하고 해당 오픈소스 프로젝트를 활용할 수 있어야 하며 개발가이드를 통한 자신만의 개발 환경을 구축합니다.
&lt;/p&gt;
&lt;p&gt;
 GitHub의 경우 개발환경 구축 시 프로젝트를 개인 저장소로 복제하기 위해 Fork를 수행합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/5.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-4 GitHub 소셜 메뉴]
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Watch, Star, Fork는 GitHub의 소셜 기능으로써 Watch는 해당 프로젝트를 지속적으로 관찰하겠다는 의미로 이 기능을 활성화 시키면 해당 프로젝트가 처리하고 있는 이슈들에 대해서 알림이 오게 됩니다. Star는 해당 프로젝트에 관심을 나타내는 것으로 별점과 비슷하며, Star가 많은 프로젝트들은 월간, 주간, 일간으로 분류하여 인기 프로젝트로 선정되며 Explore 메뉴에서 보여집니다. 마지막으로 Fork는 해당 프로젝트를 내 계정에 그대로 복사하는 기능으로 해당 프로젝트에 Push 권한이 없다면 복제된 프로젝트에 기능을 추가, 수정하고 Pull Request로 변경사항을 적용 요청할 수 있습니다.
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(2)메일링리스트구독및커뮤니티활동&quot;&gt;
 (2) 메일링 리스트 구독 및 커뮤니티 활동
&lt;/h3&gt;
&lt;p&gt;
 메일링 리스트를 구독함으로써 프로젝트 관련 정보를 받아볼 수 있으며, 커뮤니티 활동으로 구성원들과의 의견 교류를 활발히 합니다. 본인이 해당 컴포넌트에 대한 장단점을 파악하고 이에 대한 설명이 가능한 상태에서
 &lt;span&gt;
 &lt;/span&gt;
 &lt;u&gt;
  &lt;strong&gt;
   영어 작문이 능통하다면 StackOverflow를 활용
  &lt;/strong&gt;
 &lt;/u&gt;
 하여 꾸준히 활동하는 방법도 정말 좋습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/6.jpeg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 (아 영어!) - 영어의 중요성!!
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(3)버그리포트&amp;amp;기능제안&quot;&gt;
 (3) 버그 리포트 &amp;amp; 기능 제안
&lt;/h3&gt;
&lt;p&gt;
 재현할 수 있는 버그에 대해 상황과 상태를 자세히 기술하며, JIRA나 GitHub 이슈 등의 공식 이슈 트래커를 사용하여 리포트합니다. 단, 버그 리포트를 등록하기 전 유사한 버그가 있는지 확인하고 이미 존재한다면 기존 내용에 코멘트 등으로 부가 설명 후 vote나 watch 등으로 관심을 표현하는 것이 좋겠죠! 기능 제안도 버그 리포팅과 마찬가지고 이슈 트래커를 사용하며, 유사한 이슈가 있는지 확인 후 등록하면 더욱 좋습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(4)패치등록/PullRequest&quot;&gt;
 (4) 패치 등록 / Pull Request
&lt;/h3&gt;
&lt;p&gt;
 버그, 기능 개선, 신규 기능 등을 위해 등록된 이슈에 패치를 첨부하면 커미터들이 패치를 검토한 후 적용하게 됩니다. GitHub가 사실상 오픈소스 코드 저장소의 표준이 되었기 때문에 요즘은 패치를 보내는 일은 많지 않고 대부분 GitHub의 Pull Request를 이용하면 됩니다. 자세한 설명은 인터넷에 무지하게 널렸으니 참고하여 주셔도 됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;img src=&quot;/assets/images/94568493/7.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 [그림 1-5 GitHub Pull Request]
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 class=&quot;auto-cursor-target&quot; id=&quot;id-오픈소스에기여하는방법에대하여-#1기존프로젝트활용하기-(5)이도저도안되겠다?!&quot;&gt;
 (5) 이도 저도 안되겠다?!
&lt;/h3&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 그러면 우선 번역하는데 참여하겠다로 시작하는 방법도 최고의 시작점이 아닐까 합니다.
&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;
 국내 오픈소스 커미터 현황
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
 &lt;/strong&gt;
 2019년 2월 기준* 총
 &lt;span&gt;
 &lt;/span&gt;
 &lt;strong&gt;
  500여
 &lt;/strong&gt;
 &lt;strong&gt;
  명
 &lt;/strong&gt;
 의 국내 커미터가 OS, Cloud, Mobile, BigData, IoT, AI, Network, Web, Embedded, Development Environment 등의 10개의 분야의 총 1,398 글로벌 오픈소스 프로젝트*에 참여하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 * 글로벌 커미터 현황은 프로젝트의 기여도와 코드의 정성적 평가 등을 거쳐
 &lt;span&gt;
 &lt;/span&gt;
 &lt;u&gt;
  &lt;strong&gt;
   30
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   일
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   ~90
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   일 간격으로 신규 커미터를 추가하며
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   ,
   &lt;span&gt;
   &lt;/span&gt;
  &lt;/strong&gt;
 &lt;/u&gt;
 &lt;u&gt;
  &lt;strong&gt;
   기존 커미터도 지속적인 소스코드 개발과 기여가 없으면 커미터 자격이 유지되지 않음
  &lt;/strong&gt;
 &lt;/u&gt;
&lt;/p&gt;
&lt;p&gt;
 ㅇ 국내 커미터들이 가장 많이 개발에 참여하고 있는 글로벌 오픈소스 프로젝트는 구글 안드로이드(Google Android)이며, 총 86명의 국내 커미터가 분포되어 있음
&lt;/p&gt;
&lt;p&gt;
 - 구글 안드로이드 다음으로는 Google Chromium 프로젝트에 46명, WebKit 프로젝트와 Rust 프로그래밍 언어에 각각 18명의 국내 커미터가 개발하고 있음
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
 &lt;/strong&gt;
 국내 커미터가 참여하는 글로벌 프로젝트 분야 Top 3는 ① Development Environment* 분야 119명 ② Mobile 분야 105명 ③ Web분야에 80명이 참여하여 Top 3를 형성하고 있음
&lt;/p&gt;
&lt;p&gt;
 * 개발환경 분야는 Programming Language, Testing Tool, Simulator, Compiler, Build system, Library, Framework 등을 포함하고 있음
&lt;/p&gt;</description>
        <pubDate>Thu, 09 Apr 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/04/09/94568493/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/04/09/94568493/</guid>
        
        <category>오픈소스</category>
        
        <category>리누즈</category>
        
        <category>토발즈</category>
        
        <category>리눅스</category>
        
        <category>오픈소스컨설팅</category>
        
        <category>커뮤니티</category>
        
        <category>기여방법</category>
        
        
      </item>
    
      <item>
        <title>Kubernetes상에서 Keycloak과 Jenkins 그리고 Spinnaker 연동하기</title>
        <description>&lt;p&gt;
 keycloak이라는 SSO solution을 이용하여 Jenkins 그리고 Spinnaker를 SAML과 OIDC 방식으로 연동하고
&lt;/p&gt;
&lt;p&gt;
 한번의 로그인으로 각 솔루션을 접근할수 있는 방법에 대하여 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Keycloak이란?&quot;&gt;
 Keycloak이란?
&lt;/h1&gt;
&lt;p&gt;
 우선 Keycloak에 대하여 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현대의 Application과 Service들에 대한 오픈소스 계정 및 접근 관리 솔루션으로 기존에 서비스 되고 있었거나
&lt;/p&gt;
&lt;p&gt;
 새로운 Application을 구현하고자할때 해당 코드의 변경없이(혹은 약간의 수정만으로) 인증과 자원보호의 기능을 제공하는 솔루션입니다.
&lt;/p&gt;
&lt;p&gt;
 해당 솔루션은 오픈소스로 제공되며 Community 버전의 경우 별도의 비용없이 사용이 가능하며 Red Hat Single Sign-On이라는 솔루션으로
&lt;/p&gt;
&lt;p&gt;
 벤더의 지원을 구매하여 사용하실수도 있습니다.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.keycloak.org/about.html&quot; rel=&quot;nofollow&quot;&gt;
   https://www.keycloak.org/about.html
  &lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-기본적으로제공하는기능은다음과같습니다.&quot;&gt;
 기본적으로 제공하는 기능은 다음과 같습니다.
&lt;/h3&gt;
&lt;ul&gt;
 &lt;li&gt;
  SSO (Single Sign On)
 &lt;/li&gt;
 &lt;li&gt;
  ID 중개와 소셜 로그인 (OpenID, SAML, GitHub, facebook, google, twitter 등)
 &lt;/li&gt;
 &lt;li&gt;
  사용자 연합 (LDAP, AD, RDMS와의 연동을 통해 중앙화된 계정통합을 제공)
 &lt;/li&gt;
 &lt;li&gt;
  관리자 / 계정관리 콘솔
 &lt;/li&gt;
 &lt;li&gt;
  표준 프로토콜 지원 (OpenID, SAML, OAuth 2.0)
 &lt;/li&gt;
 &lt;li&gt;
  Client Adapters (다수의 platform과 프로그래밍 언어가 사용가능한 adapter를 가지고 있다.)
 &lt;/li&gt;
 &lt;li&gt;
  권한부여 서비스
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 여기까지는 간단하게 Keycloak이라는 SSO에 대하여 알아보았고 이제부터 Keycloak을 Kubernetes 환경에 배포하고
&lt;/p&gt;
&lt;p&gt;
 배포된 Keycloak을 이용하여 Jenkins, Spinnaker에 SSO 환경을 구성하는 방법에 대하여 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Keycloak배포및구성&quot;&gt;
 Keycloak 배포 및 구성
&lt;/h1&gt;
&lt;p&gt;
 우선 간단하게 helm을 이용하여 Kubernetes환경에서 keycloak을 구성하는 방법에 대하여 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 설치시 helm을 이용할 예정이기에 values.yaml내에 아래와 같은 몇가지 설정을 변경합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@labs-kube-infra001 keycloak]# kubectl create ns keycloak
[root@labs-kube-infra001 keycloak]# helm repo add codecentric https://codecentric.github.io/helm-charts
&quot;codecentric&quot; has been added to your repositories
[root@labs-kube-infra001 keycloak]# mkdir keycloak &amp;amp;&amp;amp; cd keycloak
[root@labs-kube-infra001 keycloak]# helm show values codecentric/keycloak &amp;gt; values.yaml
[root@labs-kube-infra001 keycloak]# cat values.yaml
...
  ## Username for the initial Keycloak admin user
  username: keycloak

  ## Password for the initial Keycloak admin user. Applicable only if existingSecret is not set.
  ## If not set, a random 10 characters password will be used
  password: &quot;Pa55w0rd$#&quot;
...
  service:
    annotations: {}
    # service.beta.kubernetes.io/aws-load-balancer-internal: &quot;0.0.0.0/0&quot;

    labels: {}
    # key: value

    ## ServiceType
    ## ref: https://kubernetes.io/docs/user-guide/services/#publishing-services---service-types
    type: LoadBalancer
...
  persistence:
    # If true, the Postgres chart is deployed
    deployPostgres: true

    # The database vendor. Can be either &quot;postgres&quot;, &quot;mysql&quot;, &quot;mariadb&quot;, or &quot;h2&quot;
    dbVendor: &quot;postgres&quot;
...
postgresql:
...
  persistence:
    ## Enable PostgreSQL persistence using Persistent Volume Claims.
    ##
    enabled: true
...
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 자 이제 설치를 진행해보도록 하겠습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;[root@labs-kube-infra001 keycloak]# helm install --name keycloak -f values.yaml codecentric/keycloak --namespace keycloak
NAME:   keycloak
LAST DEPLOYED: Thu Mar 19 15:33:50 2020
NAMESPACE: keycloak
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/ConfigMap
NAME              DATA  AGE
keycloak-sh       1     2s
keycloak-startup  1     2s
keycloak-test     1     2s

==&amp;gt; v1/Pod(related)
NAME                   READY  STATUS    RESTARTS  AGE
keycloak-0             0/1    Init:0/1  0         1s
keycloak-postgresql-0  0/1    Pending   0         1s

==&amp;gt; v1/Secret
NAME                 TYPE    DATA  AGE
keycloak-http        Opaque  1     3s
keycloak-postgresql  Opaque  1     3s

==&amp;gt; v1/Service
NAME                          TYPE          CLUSTER-IP    EXTERNAL-IP      PORT(S)                      AGE
keycloak-headless             ClusterIP     None          &amp;lt;none&amp;gt;           80/TCP,8443/TCP              2s
keycloak-http                 LoadBalancer  10.233.3.82   192.168.197.141  80:32242/TCP,8443:31190/TCP  2s
keycloak-postgresql           ClusterIP     10.233.7.200  &amp;lt;none&amp;gt;           5432/TCP                     2s
keycloak-postgresql-headless  ClusterIP     None          &amp;lt;none&amp;gt;           5432/TCP                     2s

==&amp;gt; v1/StatefulSet
NAME                 READY  AGE
keycloak             0/1    2s
keycloak-postgresql  0/1    2s


NOTES:

Keycloak can be accessed:

* Within your cluster, at the following DNS name at port 80:

  keycloak-http.keycloak.svc.cluster.local

* From outside the cluster, run these commands in the same shell:

  NOTE:
  It may take a few minutes for the LoadBalancer IP to be available.
  You can watch the status of by running 'kubectl get svc -w keycloak'

  export SERVICE_IP=$(kubectl get svc --namespace keycloak keycloak -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
  echo http://$SERVICE_IP:80

Login with the following credentials:
Username: keycloak

To retrieve the initial user password run:
kubectl get secret --namespace keycloak keycloak-http -o jsonpath=&quot;{.data.password}&quot; | base64 --decode; echo

[root@labs-kube-infra001 keycloak]# k get po -n keycloak
NAME                    READY   STATUS    RESTARTS   AGE
keycloak-0              1/1     Running   0          6m42s
keycloak-postgresql-0   1/1     Running   0          6m42s
[root@labs-kube-infra001 keycloak]# k get svc -n keycloak
NAME                           TYPE           CLUSTER-IP     EXTERNAL-IP       PORT(S)                       AGE
keycloak-headless              ClusterIP      None           &amp;lt;none&amp;gt;            80/TCP,8443/TCP               6m49s
keycloak-http                  LoadBalancer   10.233.3.82    192.168.197.141   80:32242/TCP,8443:31190/TCP   6m49s
keycloak-postgresql            ClusterIP      10.233.7.200   &amp;lt;none&amp;gt;            5432/TCP                      6m49s
keycloak-postgresql-headless   ClusterIP      None           &amp;lt;none&amp;gt;            5432/TCP                      6m49s
[root@labs-kube-infra001 keycloak]# k get statefulset -n keycloak
NAME                  READY   AGE
keycloak              1/1     7m6s
keycloak-postgresql   1/1     7m6s&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 설치가 완료되고 keycloak 서비스에 접근하게 되면 아래와 같은 관리자 화면이 출력됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 로그인 계정은 앞서 helm values.yaml 파일에 설정했던 value를 사용하여 로그인을 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-note conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;note&quot;&gt;
 &lt;p class=&quot;title&quot;&gt;
  참고사항
 &lt;/p&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   docker-compose를 사용할수 있는 예제도 존재하니 테스트를 해보고자 하는 경우 간단히 docker-compose 예제를 다운로드 받아
  &lt;/p&gt;
  &lt;p&gt;
   설치 및 테스트를 수행해보기를 추천드립니다.
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/keycloak/keycloak-containers/tree/master/docker-compose-examples&quot; rel=&quot;nofollow&quot;&gt;
     https://github.com/keycloak/keycloak-containers/tree/master/docker-compose-examples
    &lt;/a&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Keycloak연동하기전에기본적인용어들&quot;&gt;
 Keycloak 연동하기 전에 기본적인 용어들
&lt;/h1&gt;
&lt;p&gt;
 SSO 혹은 Keycloak이 처음이라면 아래의 용어에 우선 친숙해질 필요가 있습니다.
&lt;/p&gt;
&lt;p&gt;
 간단하게 설명된 용어들을 읽어보고 연동을 진행해보기를 추천드립니다.
&lt;/p&gt;
&lt;h5 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Realm&quot;&gt;
 Realm
&lt;/h5&gt;
&lt;ul&gt;
 &lt;li&gt;
  SSO로서 인증 대상의 범위를 지정한다라고 생각하면 됩니다.
 &lt;/li&gt;
 &lt;li&gt;
  Realm을 통해 Namespace 형태로 관리할수 있으며 Metadata와 관련 설정에 대한 모든것을 관리하도록 도와줍니다.
 &lt;/li&gt;
 &lt;li&gt;
  참고로 다수의 realm을 가질수 있고 일반적으로 master(default로 생성된 realm)는 관리자의 목적으로만 사용하고
  &lt;br/&gt;
  다른 realm을 생성하여 사용하기를 권장합니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Client&quot;&gt;
 Client
&lt;/h5&gt;
&lt;ul&gt;
 &lt;li&gt;
  SSO를 사용할 각 Application입니다.
  &lt;br/&gt;
  (즉, 여기서는 Jenkins, Spinnaker가 Client라고 보시면 됩니다.)
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-User&quot;&gt;
 User
&lt;/h5&gt;
&lt;ul&gt;
 &lt;li&gt;
  앞서 설명드린 Client에 실제 로그인할 사용자계정이라 보면됩니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-참고&quot;&gt;
 참고
&lt;/h5&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://jsonobject.tistory.com/445&quot; rel=&quot;nofollow&quot;&gt;
   https://jsonobject.tistory.com/445
  &lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Keycloak과Jenkins연동하기&quot;&gt;
 Keycloak과 Jenkins 연동하기
&lt;/h1&gt;
&lt;p&gt;
 Keycloak과 Jenkins를 연결하여 인증을 Keycloak을 통해서 받을 수 있도록 해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 Keycloak 연동에는 다양한 방식이 있고 역할기반의 제어도 가능하나 여기서는 Jenkins의 경우
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  SAML을 이용한 방식의 로그인만을 연동
 &lt;/strong&gt;
 하는 방법에 대하여 알아볼 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 참고로
 &lt;span style=&quot;letter-spacing: 0.0px;&quot;&gt;
  Jenkins는 jenkins.openlabs:8080 으로 접속되는 환경으로 구성이 이미 완료된 상태입니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-KeycloakSide&quot;&gt;
 Keycloak Side
&lt;/h3&gt;
&lt;p&gt;
 앞서 설명하였던대로 Master가 기본으로 설정되어 있지만 이를 사용하지 않고 새로운 Realm을 생성합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/2.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 생성된 Realm의 Realm Settings로 이동하여 Endpoint를 확인합니다.
&lt;/p&gt;
&lt;p&gt;
 (해당 Endpoint 정보는 Jenkins 의 Keycloak 관련 SAML 설정상에서 사용될 예정입니다.)
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/3.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 클릭해보면 다음과 같은 XML 형태의 문서가 출력되게 됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/4.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 해당 정보를 사전에 복사해둡니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 keycloak를 사용한 인증을 위한 Jenkins Client를 생성합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/5.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 설정은 아래 그림에 체크되어 있는 설정을 추가하여 설정을 마무리 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/6.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 위에 체크된 항목에 대해 추가를 진행한다.
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-note conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;note&quot;&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   만약 설정시 아래와 같은 이슈가 있다면 참고하시기 바랍니다.
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    invalid_redirect_url 에러 관련
    &lt;ul&gt;
     &lt;li&gt;
      Valid Redirect URIs 에 IP 및 domain 정보가 추가되어 있지 않아서 발생된 이슈로 추가시 이슈해결됨.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
   &lt;li&gt;
    로그인후에 자동 로그아웃되는 현상
    &lt;ul&gt;
     &lt;li&gt;
      document signing enable 후에 자동로그아웃되는 현상 사라짐.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-JenkinsSide&quot;&gt;
 Jenkins Side
&lt;/h3&gt;
&lt;p&gt;
 이제 Keycloak SSO를 사용하기 위한 Jenkins의 설정을 추가해 보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 Jenkins의 경우 앞서 Keycloak에서 설정했듯이 SAML을 이용할 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 하여 SAML plugin을 먼저 설치합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/7.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 SAML plugin 설치후 global security 설정에서 아래와 같은 설정을 진행합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/8.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 위에 체크된 항목을 변경하여 설정을 완료합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이제 설정은 완료되었습니다. 아래와 같이 직접 Jenkins UI로 접근을 시도해봅니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/9.gif&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 이제 SSO 연동을 위한 Jenkins 로그인 과정을 완료하였습니다.
&lt;/p&gt;
&lt;p&gt;
 SSO의 경우 한번의 로그인을 통해 다수의 서비스를 사용할수 있는 것이기에 다음 Spinnaker를 SSO와 연동하여 두개의 서비스가
&lt;/p&gt;
&lt;p&gt;
 한번의 로그인으로 이루어질수 있는지 추가로 알아보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-note conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;note&quot;&gt;
 &lt;p class=&quot;title&quot;&gt;
  참고
 &lt;/p&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   Keycloak은 Login Page에 대한 customization을 제공하기 때문에 아래 링크를 활용하여 custom theme를 작성하고
  &lt;/p&gt;
  &lt;p&gt;
   적용하여 자신만의 login page를 구성할수 있습니다.
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://medium.com/@auscunningham/create-a-custom-theme-for-keycloak-8781207be604&quot; rel=&quot;nofollow&quot;&gt;
     https://medium.com/@auscunningham/create-a-custom-theme-for-keycloak-8781207be604
    &lt;/a&gt;
   &lt;/li&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/Alfresco/alfresco-keycloak-theme&quot; rel=&quot;nofollow&quot; style=&quot;letter-spacing: 0.0px;&quot;&gt;
     https://github.com/Alfresco/alfresco-keycloak-theme
    &lt;/a&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-Spinnaker와Keycloak&quot;&gt;
 Spinnaker와 Keycloak
&lt;/h1&gt;
&lt;p&gt;
 이번에는 Spinnaker 연동을 해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 앞서 이야기 드렸듯이 Keycloak 연동에는 다양한 방식이 있고 역할기반의 제어도 가능하나 여기서는 spinnaker의 경우
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  OIDC를 이용한 방식의 로그인만을 연동
 &lt;/strong&gt;
 하는 방법에 대하여 알아볼 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 참고로
 &lt;span&gt;
  spinnaker는 spinnaker.openlabs 으로 접속되는 환경으로 구성이 이미 완료된 상태입니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 또한 spinnaker-gate.openlabs:8084로 gate가 접속 가능한 환경입니다.
&lt;/p&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-KeycloakSide.1&quot;&gt;
 Keycloak Side
&lt;/h3&gt;
&lt;p&gt;
 이제 Keycloak에서 spinnaker를 위한 Client를 생성합니다.
&lt;/p&gt;
&lt;p&gt;
 이번에는 keycloak에서 권장하는 OIDC(OpenID Connect)로 설정하여 Client를 생성해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/10.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Jenkins 연동시와 동일하게 Client을 생성합니다.
&lt;/p&gt;
&lt;p&gt;
 (Jenkins 에서 생성했던 Realm을 동일하게 사용하는 것을 가정하였습니다.)
&lt;/p&gt;
&lt;p&gt;
 이후 아래와 같은 설정에 매칭되는 OIDC json 파일의 내용을 확인합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/11.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 실제 Json 내용은 다음과 같습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;{
  &quot;realm&quot;: &quot;Openlabs&quot;,
  &quot;auth-server-url&quot;: &quot;http://keycloak.openlabs/auth/&quot;,
  &quot;ssl-required&quot;: &quot;external&quot;,
  &quot;resource&quot;: &quot;spinnaker&quot;,
  &quot;credentials&quot;: {
    &quot;secret&quot;: &quot;d123150f-2879-4a99-9e22-e40fcaf02bdb&quot;
  },
  &quot;confidential-port&quot;: 0
}&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 여기서 우리는 credentials 정보와 auth-server-url, realm 등을 사용할 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 또한 realm 의 endpoint 정보도 확인해놓습니다.
&lt;/p&gt;
&lt;p&gt;
 아래와 같이 앞서 생성했던 Realm 의 Settings에서 Endpoints 내에 OpenID Endpoint Configuration을 클릭하여 확인이 가능합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/12.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 클릭시 아래와 같은 Json 결과가 출력될 것이고 아래 정보는 spinnaker 설정에서 사용될 예정입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/13.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 실제 사용될 url 정보는 다음과 같습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;authorization_endpoint: &quot;http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/auth&quot;,
token_endpoint: &quot;http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/token&quot;,
userinfo_endpoint: &quot;http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/userinfo&quot;&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-SpinnakerSide&quot;&gt;
 Spinnaker Side
&lt;/h3&gt;
&lt;p&gt;
 이제 spinnaker에서 설정을 진행해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 아시다시피 spinnaker의 경우 halyard pod에 접속하여 (혹은 hal command가 가능한 서버에 접속하여) 설정 변경을 수행해야 합니다.
&lt;/p&gt;
&lt;p&gt;
 하여 halyard pod에 접속하여 hal command를 수행해봅니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;jacob@jacob-laptop:~/workspace$ k get po
NAME                                READY   STATUS      RESTARTS   AGE
spin-clouddriver-5d569c94b8-ffmfs   1/1     Running     0          69d
spin-deck-7754884b55-fq7r4          1/1     Running     0          69d
spin-echo-c57577776-vz8zg           1/1     Running     0          69d
spin-front50-79d4d69b45-klchv       1/1     Running     0          69d
spin-gate-75c76579c4-dxnjp          1/1     Running     0          69d
spin-igor-74d8c59858-zj4bt          1/1     Running     0          69d
spin-orca-f7b8c4676-kfbwp           1/1     Running     0          69d
spin-rosco-7d58898bd6-8h2g5         1/1     Running     0          69d
spinnaker-install-using-hal-x9vds   0/1     Completed   0          70d
spinnaker-minio-5dc587c6f-k9hsx     1/1     Running     0          70d
spinnaker-redis-master-0            1/1     Running     0          70d
spinnaker-redis-slave-0             1/1     Running     0          70d
spinnaker-redis-slave-1             1/1     Running     0          70d
spinnaker-spinnaker-halyard-0       1/1     Running     0          70d
jacob@jacob-laptop:~/workspace$ k exec -it spinnaker-spinnaker-halyard-0 /bin/bash
spinnaker@spinnaker-spinnaker-halyard-0:/workdir$ &lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 실제 halyard pod에서 수행될 명령어들은 다음과 같습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;echo &quot;server:
  tomcat:
    protocolHeader: X-Forwarded-Proto
    remoteIpHeader: X-Forwarded-For
    internalProxies: .*
    httpsServerPort: X-Forwarded-Port
security:
  oauth2:
    enabled: true
    client: 
      clientId: spinnaker
      clientSecret: d123150f-2879-4a99-9e22-e40fcaf02bdb
      userAuthorizationUri: http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/auth
      accessTokenUri: http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/token
      scope: roles,email,profile
    resource:
      userInfoUri: http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/userinfo
    userInfoMapping:
      email: email
      firstName: given_name
      lastName: family_name
      username: preferred_username&quot; &amp;gt; .hal/default/profiles/gate-local.yml
hal config security authn oauth2 edit \
--client-id spinnaker \
--client-secret d123150f-2879-4a99-9e22-e40fcaf02bdb \
--pre-established-redirect-uri http://spinnaker-api.openlabs:8084/login
hal config security authn oauth2 enable
hal config security ui edit --override-base-url http://spinnaker.openlabs:9000
hal config security api edit --override-base-url http://spinnaker-api.openlabs:8084 
hal deploy apply

## 혹은 다음 명령 set 수행
hal config security authn oauth2 edit \
--client-id spinnaker \
--client-secret d123150f-2879-4a99-9e22-e40fcaf02bdb \
--pre-established-redirect-uri http://spinnaker-api.openlabs:8084/login \
--access-token-uri http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/token \
--scope read:roles,email,profile \
--user-authorization-uri http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/auth \
--user-info-mapping-email email \
--user-info-mapping-first-name given_name \
--user-info-mapping-last-name family_name \
--user-info-mapping-username preferred_username \
--user-info-uri http://keycloak.openlabs/auth/realms/Openlabs/protocol/openid-connect/userinfo
hal config security authn oauth2 enable
hal config security ui edit --override-base-url http://spinnaker.openlabs:9000
hal config security api edit --override-base-url http://spinnaker-api.openlabs:8084 
hal deploy apply&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 물론 helm chart를 이용한 업그레이드 방법도 가능합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Midnight&quot; data-theme=&quot;Midnight&quot;&gt;   additionalProfileConfigMaps:
     create: true
     data:
       gate-local.yml: |-
         server:
           tomcat:
             protocolHeader: X-Forwarded-Proto
             remoteIpHeader: X-Forwarded-For
             internalProxies: .*
             httpsServerPort: X-Forwarded-Port
         security:
           oauth2:
             enabled: true
             client:
               clientId: spinnaker
               clientSecret: xxxx00cc-xxxx-xxxx-xxxx-xxxx2515xxxx
               userAuthorizationUri: http://keycloak.openlabs/auth/realms/openlabs/protocol/openid-connect/auth
               accessTokenUri: http://keycloak.openlabs/auth/realms/openlabs/protocol/openid-connect/token
               scope: roles,email,profile
             resource:
               userInfoUri: http://keycloak.openlabs/auth/realms/openlabs/protocol/openid-connect/userinfo
             userInfoMapping:
               email: email
               firstName: given_name
               lastName: family_name
               username: preferred_username
   additionalScripts:
     create: true
     data: 
       override_baseurls.sh: |-
           $HAL_COMMAND config security api edit --override-base-url http://spinnaker-gate.openlabs:8084/
           $HAL_COMMAND config security ui edit --override-base-url http://spinnaker.openlabs/
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 위 명령 혹은 helm upgrade를 통한 설정 변경을 수행한 후 실제 로그인을 수행해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/14.gif&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 로그인 완료후 아래와 같이 로그인 계정이 확인됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/15.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-확인&quot;&gt;
 확인
&lt;/h1&gt;
&lt;p&gt;
 자 이제 SSO 기능 검증을 위해 두개의 Application을 로그인시도해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/91699412/16.gif&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 두개의 Application을 한번의 로그인으로 사용할수 있도록 하는것을 확인할수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;confluence-information-macro confluence-information-macro-warning conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;warning&quot;&gt;
 &lt;p class=&quot;title&quot;&gt;
  참고사항
 &lt;/p&gt;
 &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-error confluence-information-macro-icon&quot;&gt;
 &lt;/span&gt;
 &lt;div class=&quot;confluence-information-macro-body&quot;&gt;
  &lt;p&gt;
   &lt;strong&gt;
    keycloak에서 권장하는 사항들
   &lt;/strong&gt;
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    SAML을 사용하는 경우
    &lt;ul&gt;
     &lt;li&gt;
      XML 교환방식을 Post Binding 으로 사용하는것을 권장 (보안과 크기제한에 대한 이슈로 인하여)
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
   &lt;li&gt;
    SAML 보다는 OIDC를 권장
    &lt;ul&gt;
     &lt;li&gt;
      &lt;a class=&quot;external-link&quot; href=&quot;https://www.keycloak.org/docs/latest/server_admin/#openid-connect-vs-saml&quot; rel=&quot;nofollow&quot;&gt;
       https://www.keycloak.org/docs/latest/server_admin/#openid-connect-vs-saml
      &lt;/a&gt;
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&quot;Kubernetes상에서Keycloak과Jenkins그리고Spinnaker연동하기-참고사이트&quot;&gt;
 참고사이트
&lt;/h1&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.keycloak.org/docs/latest/getting_started/index.html&quot; rel=&quot;nofollow&quot;&gt;
   https://www.keycloak.org/docs/latest/getting_started/index.html
  &lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;</description>
        <pubDate>Sat, 04 Apr 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/04/04/91699412/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/04/04/91699412/</guid>
        
        <category>spinnaker</category>
        
        <category>jenkins</category>
        
        <category>keycloak</category>
        
        <category>sso</category>
        
        <category>saml</category>
        
        <category>oidc</category>
        
        
      </item>
    
      <item>
        <title>데이터센터의 클라우드 전환</title>
        <description>&lt;h1 id=&quot;id-데이터센터의클라우드전환-1.클라우드전환개요&quot;&gt;
 &lt;strong&gt;
  1.클라우드 전환 개요
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;p&gt;
 엔터프라이즈 기업의 데이터센터가 변화하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 유닉스 기반의 경직된 시스템 환경에서 스케일 아웃을 통한 확장성 있는 인프라로의 변화를 위하여 많은 기업들이 소프트웨어 정의 데이터센터
 &lt;span&gt;
  (SDDC:Software Defined Data Center)
 &lt;/span&gt;
 를 외치고 있는 실정입니다.
&lt;/p&gt;
&lt;p&gt;
 현재 데이터센터를 자체적으로 보유한 기업들 조차도 신규 서비스 기획 시 사업에 대한 불명확성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 시장 반응들을 살펴볼 수 있는 시스템을 만들기 위하여 하드웨어 박스를 구매하고
 &lt;span&gt;
  ,
 &lt;/span&gt;
 상용 소프트웨어로 도배된 데이터센터 기반 시스템의 사용에 대해 의문을 가지고 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 일부 서비스를 클라우드 서비스 혹은 하이브리드 방식의 클라우드로의 전환을 검토 또는 진행 중에 있습니다.
&lt;/p&gt;
&lt;p&gt;
 퍼블릭 클라우드 인프라 시장도 급속도로 팽창을 하고 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 아래의 표에서도 나타나지만
 &lt;span&gt;
  IaaS, PaaS
 &lt;/span&gt;
 시장은 계속
 &lt;span&gt;
  4
 &lt;/span&gt;
 대 업체로 통합되고 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이들 대형업체는 신규 서비스를 지속적으로 내놓고 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 자신들의 강점 분야를 내세워 데이터센터 고객의 자사 클라우드 유도와 하이브리드 운영 방안에 대한 레퍼런스를 지속적으로 내놓고 있는 상황입니다.
&lt;/p&gt;
&lt;p&gt;
 가트너에 의하면 아마존은 2019년 7월 기준으로 전세계 IaaS 시장의 50% 이상을 여전히 차지하고 있는 것으로 발표하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/91696364/0.jpeg&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 참고
 &lt;span&gt;
  URL:
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.zdnet.co.kr/view/?no=20190730175837&quot; rel=&quot;nofollow&quot;&gt;
   https://www.zdnet.co.kr/view/?no=20190730175837
  &lt;/a&gt;
  (아마존 IaaS 시장 절반 이상 독식)
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  국내의 경우 가장 먼저 진출한 아마존
 &lt;/span&gt;
 &lt;span&gt;
  AWS
 &lt;/span&gt;
 &lt;span&gt;
  가 시장에서 많이 적용되고 있으며
 &lt;/span&gt;
 &lt;span&gt;
  ,
 &lt;/span&gt;
 &lt;span&gt;
  스타트업들에게는 사실상의 표준
 &lt;/span&gt;
 &lt;span&gt;
  (DeFacto Standard)
 &lt;/span&gt;
 &lt;span&gt;
  으로 자리를 잡았습니다
 &lt;/span&gt;
 &lt;span&gt;
  .
 &lt;/span&gt;
 &lt;span&gt;
  본 아티클에서는 엔터프라이즈 관점에서 데이터 센터을 어떻게 퍼블릭 클라우드로 전환하는지에 대해 살펴보려고 합니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  전환의 이유는 무엇인가
  &lt;span&gt;
   ?
  &lt;/span&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 국내 대기업의 데이터센터는 그룹사의
 &lt;span&gt;
  IT
 &lt;/span&gt;
 를 담당하는 회사에서 관리를 주로 하고 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 오픈스택 또는 가상화 기반 하의 클라우드라는 명칭으로 각 그룹 고객사에 서비스 제공하려 많은 노력들을 기울이고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 내부의
 &lt;span&gt;
  IT
 &lt;/span&gt;
 자원의 성능이 훨씬 더 압도적일 것이라 대부분 판단하지만 퍼블릭 클라우드 서비스 업체가 기반 물리 자원에 대한 액세스를 너무나 잘 관리하기 때문에 그 차이가 그렇게 극명하게 나지 않는 것이 일반적입니다.
&lt;/p&gt;
&lt;p&gt;
 또한 내부
 &lt;span&gt;
  ITSM
 &lt;/span&gt;
 시스템의 관제하에 들어가게 되므로 클라우드 컴퓨팅이 제공하는 가치의 많은 부분이 민첩성에서 나온다는 점에서 이를 포기하고 데이터 센터만을 고집하는 것도 좋은 결정은 아닐 것입니다.
 &lt;span&gt;
 &lt;/span&gt;
 이로 인해 퍼블릭 클라우드에 대한 도입 검토와 개념검증
 &lt;span&gt;
  (PoC),
 &lt;/span&gt;
 실제 전환이 활발하게 이루어지고 있는 실정입니다.
&lt;/p&gt;
&lt;p&gt;
 일반적으로 전환 후 록인
 &lt;span&gt;
  (lock-in)
 &lt;/span&gt;
 에 대해서 우려를 하는 기업들도 있겠지만 그러한 록인은 데이터 센터가 훨씬 더 심하며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 기업은 다양한 서버와 운영체제
 &lt;span&gt;
  ,
 &lt;/span&gt;
 애플리케이션
 &lt;span&gt;
  ,
 &lt;/span&gt;
 어플라이언스를 선택하고 원하는 특정 결과를 얻기 위한 과정일 뿐입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  어떻게 전환할 것인가
  &lt;span&gt;
   ?
  &lt;/span&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 클라우드 전환에 있어 중요한 한 가지는 클라우드라는 트렌드에 대한 기업의
 &lt;span&gt;
  ‘
 &lt;/span&gt;
 적응력
 &lt;span&gt;
  ’
 &lt;/span&gt;
 과
 &lt;span&gt;
  ‘
 &lt;/span&gt;
 변화에 대한 의지
 &lt;span&gt;
  ’
 &lt;/span&gt;
 가 가장 클 것입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 쿠팡
 &lt;span&gt;
  (
 &lt;/span&gt;
 쿠팡
 &lt;span&gt;
  , IT
 &lt;/span&gt;
 인프라 전체를
 &lt;span&gt;
  AWS
 &lt;/span&gt;
 클라우드로 이전했다
 &lt;span&gt;
  ,
 &lt;/span&gt;
 기사
 &lt;span&gt;
  :
  &lt;a class=&quot;external-link&quot; href=&quot;https://byline.network/2017/08/10-6/&quot; rel=&quot;nofollow&quot;&gt;
   https://byline.network/2017/08/10-6/
  &lt;/a&gt;
  )
 &lt;/span&gt;
 과 같이 모든 인프라를 퍼블릭 클라우드로 전환하는 경우도 있겠지만
 &lt;span&gt;
  ,
 &lt;/span&gt;
 대부분은 기존에 운영되던 시스템과 고객의 정보
 &lt;span&gt;
  (
 &lt;/span&gt;
 규제를 포함하는
 &lt;span&gt;
  )
 &lt;/span&gt;
 로 인하여
 &lt;span&gt;
  100%
 &lt;/span&gt;
 이전을 못하는 경우가 대다수이다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이로 인해 단계적인 클라우드 전환을 고려하게 되는데
 &lt;span&gt;
  ,
 &lt;/span&gt;
 아래와 같이 데이터 센터와 퍼블릭 클라우드를 연결하여 상호 통신을 할 수 있도록 서비스를 구성하게 됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/91696364/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 데이터센터와 퍼블릭 클라우드
 &lt;span&gt;
  &amp;gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 퍼블릭 클라우드로 전환할 수 있는 단계는 여러가지가 있을 수 있지만 우선 크게
 &lt;span&gt;
  3
 &lt;/span&gt;
 단계에 대한 전환 절차를 고려할 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 첫번째 단계로 대상 시스템 선정 및 기술입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 기존의 내부 시스템에 대한 조사를 통해 퍼블릭 클라우드의 유연성
 &lt;span&gt;
  (
 &lt;/span&gt;
 오토스케일링 같은
 &lt;span&gt;
  )
 &lt;/span&gt;
 을 통해 그 효과를 즉시 확인할 수 있는 시스템들이 그 대상이 될 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이러한 시스템에 대한
 &lt;span&gt;
  AS-IS
 &lt;/span&gt;
 현황 분석을 통해 클라우드 전환 시
 &lt;span&gt;
  TO-BE
 &lt;/span&gt;
 아키텍처를 그릴 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이 때 중요한 것은 전체 업무 대상 시스템이 아니며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 현재 가장 손쉽게 올릴 수 있는
 &lt;span&gt;
  WEB-WAS-DB
 &lt;/span&gt;
 아키텍처를 가진 트래픽의 양 변화가 큰 업무들이 대상이 될 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그 업무 시스템에서 사용하는 기술들이 클라우드로 전환됐을 때
 &lt;span&gt;
  ,
 &lt;/span&gt;
 그대로 옮겨갈 것인지
 &lt;span&gt;
  AWS
 &lt;/span&gt;
 와 같은 클라우드의 네이티브 서비스
 &lt;span&gt;
  (
 &lt;/span&gt;
 예
 &lt;span&gt;
  : ELB, RDS, DynamoDB)
 &lt;/span&gt;
 를 활용할 것인지도 중요한 결정 사항이 될 것입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 두번째 단계로는 시스템 전환입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 대부분의 큰 기업에서는 내부의 데이터센터와 클라우드를 연결하는 것을 기본 전제로 하고 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이 때 서비스를 어떻게 구성할지에 대한 부분의 검토를 하게 되는데
 &lt;span&gt;
  ,
 &lt;/span&gt;
 보통 퍼블릭 클라우드에서는 아래의 방식의 서비스들을 제공하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 기업의 퍼블릭 클라우드 연결 방식
 &lt;span&gt;
  &amp;gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 기업 내의 데이터 센터와의 연결 시 전용선
 &lt;span&gt;
  (
 &lt;/span&gt;
 비용 상승
 &lt;span&gt;
  )
 &lt;/span&gt;
 방식과
 &lt;span&gt;
  VPN
 &lt;/span&gt;
 을 통한 퍼블릭 클라우드 네트워크 연결을 고려할 수 있으며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 비용과 안정성 측면에서 장단점이 존재하므로 전환 시 의사결정이 필요한 부분 중 하나이다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 이후 클라우드 시스템 내의 목표 시스템 설계
 &lt;span&gt;
  ,
 &lt;/span&gt;
 기술 아키텍처를 정의하고 기존의 베어메탈 방식에서 활용되던 개념을 스케일
 &lt;span&gt;
  -
 &lt;/span&gt;
 아웃형 시스템으로 전환 설계 후 전환 작업을 진행한다
 &lt;span&gt;
  .
 &lt;/span&gt;
 전환 단계 상에서 성능
 &lt;span&gt;
  ,
 &lt;/span&gt;
 안정성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 확장성 테스트를 통해 해당 시스템이 처리할 수 있는 능력을 정확하게 파악하고 이를 기준으로 향후 신규 온디맨드 시스템들이 필요한 경우 지표로 삼을 수 있어야 한다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 전환의 방식은 크게 아래와 가지를 들 수 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  Life-and-Shift 방식
  &lt;span&gt;
   :
  &lt;/span&gt;
  기존 시스템의 기능
  &lt;span&gt;
   ,
  &lt;/span&gt;
  소프트웨어 등을 변경하지 않고 그대로 클라우드 이전
 &lt;/li&gt;
 &lt;li&gt;
  Cloud-Native 방식
  &lt;span&gt;
   :
  &lt;/span&gt;
  퍼블릭 클라우드에서 운영할 수 있도록 초기 또는 전환 시점부터 클라우드가 제공하는 서비스 활용에 중점을 두어 이전
 &lt;/li&gt;
 &lt;li&gt;
  오픈소스 전환 방식
  &lt;span&gt;
   :
  &lt;/span&gt;
  클라우드의 이점인 확장성과 비용 효율성을 최대한 살릴 수 있도록 대응 오픈소스로 변경하여 이전
  &lt;span&gt;
   (
  &lt;/span&gt;
  멀티 클라우드 대응
  &lt;span&gt;
   ,
  &lt;/span&gt;
  록인 방지
  &lt;span&gt;
   )
  &lt;/span&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 전환에 대한 목표와 시스템 소프트웨어의 변경에 대한 예시는 다음의 그림과 같습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;img src=&quot;/assets/images/91696364/2.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 클라우드 목표모델 레이어 및 시스템 소프트웨어 변화
 &lt;span&gt;
  &amp;gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 마지막 단계로 운영 서비스로의 이행입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 전환 이후 전체 시스템에 대한 기능
 &lt;span&gt;
  ,
 &lt;/span&gt;
 성능에 대한 상세 모니터링을 진행하고 필요 시 인스턴스 개수 조절
 &lt;span&gt;
  ,
 &lt;/span&gt;
 사이즈 조정 등을 통해 비용최적화를 위한 작업을 진행합니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 이 때의 운영은
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 를 기반으로 한 운영 서비스를 전제로 하고
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 로의 전환
 &lt;span&gt;
  (
 &lt;/span&gt;
 클라우드와
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 툴을 통해 개발자 중심의 자동화 환경 구축
 &lt;span&gt;
  -&amp;gt;
 &lt;/span&gt;
 지속적인 배포
 &lt;span&gt;
  (CD, Continuous Delivery)
 &lt;/span&gt;
 가 가능하게 함으로써 효율성을 확보하고 개발자의 생산성과 비즈니스 민첩성 향상을 위한 기초를 만들 수 있도록 해야 합니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 기업이 가진 시스템에 대한 클라우드 전환은 빅뱅이 되어서는 안됩니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 현재는 차세대 개념의 빅뱅형이 아닌 점진형 방식의 전환을 통해 리스크를 최소화할 수 있는 전략을 구상해야 한다
 &lt;span&gt;
  .
 &lt;/span&gt;
 전환 이후에도 트렌드로 자리잡아가고 있는 마이크로서비스 아키텍처
 &lt;span&gt;
  ,
 &lt;/span&gt;
 컨테이너로의 확장과 자동화를 염두에 둔 전환이 필요한 시점이며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 이를 위한 조직
 &lt;span&gt;
  /
 &lt;/span&gt;
 운영의 관점도 달라져야 할 것입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;h1 id=&quot;id-데이터센터의클라우드전환-2.클라우드기반의컨테이너서비스를활용한PaaS&quot;&gt;
 &lt;strong&gt;
  2. 클라우드 기반의 컨테이너 서비스를 활용한
  &lt;span&gt;
   PaaS
  &lt;/span&gt;
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;p&gt;
 컨테이너 서비스가 대세다
 &lt;span&gt;
  .
 &lt;/span&gt;
 컨테이너는 리소스 격리 프로세스에서 애플리케이션과 종속 항목을 실행하게 해주는 운영 시스템 가상화 방법입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 컨테이너를 사용하면 애플리케이션의 코드
 &lt;span&gt;
  ,
 &lt;/span&gt;
 구성 및 의존성에 대한 사용이 단순한 빌딩 블록 형태로 바로 패키징할 수 있으며 빌딩 블록은 환경 일관성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 운영 효율성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 개발자 생산성
 &lt;span&gt;
  ,
 &lt;/span&gt;
 버전 제어를 제공합니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이를 통해 애플리케이션이 보다 빠르고 안정적으로 배포와 운영이 될 수 있는 환경이 만들어질 수 있는 장점이 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현재 프라이빗
 &lt;span&gt;
  /
 &lt;/span&gt;
 퍼블릭 클라우드 기반의 인프라를 구축하거나 이미 사용하고 있는 엔터프라이즈에서는
 &lt;span&gt;
  DevOps,
 &lt;/span&gt;
 시스템 간의 오케스트레이션을 위하여 적극적으로 컨테이너 서비스에 대한 조사와 도입 검토를 진행하고 있는 상황입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이러한 맥락과 함께 컨테이너 서비스 시장은 현재 엄청난 팽창을 하고 있으며 클라우드와 연계된 기술 영역에서 매년
 &lt;span&gt;
  40%
 &lt;/span&gt;
 이상의 높은 성장률을 통해
 &lt;span&gt;
  2020
 &lt;/span&gt;
 년까지
 &lt;span&gt;
  27
 &lt;/span&gt;
 억 달러 수준으로 커질 것으로 전망하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
   &lt;img src=&quot;/assets/images/91696364/3.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 애플리케이션 컨테이너 서비스 시장 전망
 &lt;span&gt;
  , 2017. 451 Research’s
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 출처
 &lt;span&gt;
  :
  &lt;a class=&quot;external-link&quot; href=&quot;https://451research.com/images/Marketing/press_releases/Application-container-market-will-reach-2-7bn-in-2020_final_graphic.pdf&quot; rel=&quot;nofollow&quot;&gt;
   https://451research.com/images/Marketing/press_releases/Application-container-market-will-reach-2-7bn-in-2020_final_graphic.pdf
  &lt;/a&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현재 아마존
 &lt;span&gt;
  , IBM,
 &lt;/span&gt;
 마이크로소프트의 퍼블릭 클라우드에서도 이러한 컨테이너 서비스를 통한 애플리케이션 빌딩 블록을 만들 수 있는 서비스를 이미 내놓고 있는 상태이며
 &lt;span&gt;
  , PaaS(Platform as a Service)
 &lt;/span&gt;
 환경을 구축하는 부분에 대해 적극적으로 고객을 유도하고 있는 상황입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현재 컨테이너 서비스들은 대부분 리눅스 환경에서 작동되고
 &lt;span&gt;
  Linux
 &lt;/span&gt;
 컨테이너를 활용하여 개발 팀과 운영 팀 간의 충돌을 줄일 수 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한
 &lt;span&gt;
  , Linux
 &lt;/span&gt;
 컨테이너는
 &lt;span&gt;
 &lt;/span&gt;
 &lt;span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.redhat.com/ko/open-source&quot; rel=&quot;nofollow&quot;&gt;
   오픈소스
  &lt;/a&gt;
 &lt;/span&gt;
 기술을 기반으로 하기 때문에 사용 즉시 최신 기술을 활용하여 회사 내부 인프라 및 애플리케이션에 대한 발전을 시킬 수 있는 특징을 가지고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 &lt;span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;http://thenewstack.io/cri-o-make-kubernetes-center-container-ecosystem/&quot; rel=&quot;nofollow&quot;&gt;
   CRI-O
  &lt;/a&gt;
 &lt;/span&gt;
 ,
 &lt;span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;http://kubernetes.io/&quot; rel=&quot;nofollow&quot;&gt;
   Kubernetes
  &lt;/a&gt;
 &lt;/span&gt;
 및
 &lt;span&gt;
 &lt;/span&gt;
 &lt;span&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.redhat.com/ko/topics/containers/what-is-docker&quot; rel=&quot;nofollow&quot;&gt;
   Docker
  &lt;/a&gt;
 &lt;/span&gt;
 등의 컨테이너 기술은 애플리케이션 개발 및 배포를 간소화하고 가속화하는 데 큰 도움이 됩니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  퍼블릭 클라우드의 컨테이너 서비스
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 퍼블릭 클라우드들은 컨테이너를 위한 다양한 서비스를 제공하여 고객들을 자사의 클라우드 서비스로 유도하기 위해 많은 노력을 기울이고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 IBM 클라우드에서는
 &lt;span&gt;
  Blumix Container Service
 &lt;/span&gt;
 를 통해 컨테이너 서비스를 제공하고 있으며,
 &lt;span&gt;
 &lt;/span&gt;
 하위의 인프라 기반은
 &lt;span&gt;
  Kubernetes
 &lt;/span&gt;
 와
 &lt;span&gt;
  Docker
 &lt;/span&gt;
 기반으로 스케줄링
 &lt;span&gt;
  ,
 &lt;/span&gt;
 자체 복구
 &lt;span&gt;
  ,
 &lt;/span&gt;
 스케일
 &lt;span&gt;
  -
 &lt;/span&gt;
 아웃 기능을 제공하고
 &lt;span&gt;
  IBM
 &lt;/span&gt;
 의 인프라에서는 마스터 노드를 관리하며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 사용자들은 자신들의 서비스에 대한 작업 노드를 정의하는 구조로 되어 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 특징적인 부분은
 &lt;span&gt;
  CLI
 &lt;/span&gt;
 기반으로 클러스터 배치 등을 관리하고 강점으로 내세우는 왓슨
 &lt;span&gt;
  (Watson)
 &lt;/span&gt;
 을 활용하여 스토리지
 &lt;span&gt;
  ,
 &lt;/span&gt;
 분석
 &lt;span&gt;
  ,
 &lt;/span&gt;
 액세스 제어 등에 대한 서비스를 통합할 수 있는 기능을 제공하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 아마존은
 &lt;span&gt;
  ECS(Amazon EC2 Container Service)
 &lt;/span&gt;
 서비스를 통해
 &lt;span&gt;
  Docker
 &lt;/span&gt;
 컨테이너를 제공하고 있으며
 &lt;span&gt;
  , EKS(Elastic Kubernetes Service)의
 &lt;/span&gt;
 자체 클러스터 관리 인프라를 구축하여 고객에게 제공하고 있습니다
 &lt;span&gt;
  . SDK
 &lt;/span&gt;
 를 통한
 &lt;span&gt;
  API
 &lt;/span&gt;
 호출을 통해 클러스터 상태관리
 &lt;span&gt;
  ,
 &lt;/span&gt;
 보안
 &lt;span&gt;
  ,
 &lt;/span&gt;
 엘라스틱 로드밸런싱
 &lt;span&gt;
  , EBS
 &lt;/span&gt;
 등에 대한 리소스 연계와 확장을 제공하고 있는 특징이 있으며
 &lt;span&gt;
  , EC2
 &lt;/span&gt;
 서비스 내에 포함되어 컨테이너 서비스에 대한 별도 비용이 필요없다는 특징이 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 마이크로소프트는 애저 컨테이너 서비스를 활용하여 아마치 메소스
 &lt;span&gt;
  , Docker
 &lt;/span&gt;
 등을 함께 사용할 수 있는 서비스를 제공하고 있으며
 &lt;span&gt;
  , 2015
 &lt;/span&gt;
 년에 서비스를 출시했습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 다른 퍼블릭 클라우드와는 다르게
 &lt;span&gt;
  Docker
 &lt;/span&gt;
 를 위한 비주얼 스튜디오
 &lt;span&gt;
  (Visual Studio Tools for Docker)
 &lt;/span&gt;
 를 통해 컨테이너 환경 하에서 윈도우용
 &lt;span&gt;
  .NET
 &lt;/span&gt;
 이나 리눅스용 코어 응용 프로그램을 빌드하여 배포할 수 있는 기능을 제공하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한 비주얼 스튜디오 팀 서비스를 통해 애자일 및
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 를 위한 워크플로우에 컨테이너를 통합할 수 있는 기능을 제공하고 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Docker
 &lt;/strong&gt;
 &lt;strong&gt;
  를 통한 기술
  &lt;span&gt;
   /
  &lt;/span&gt;
  프로세스 표준화
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 프라이빗과 퍼블릭 클라우드의 방향성은
 &lt;span&gt;
  IaaS
 &lt;/span&gt;
 기반에서 컨테이너 서비스를 통한 플랫폼 유연성을 극대화하는 방법으로도 진화하고 있습니다
 &lt;span&gt;
  . Docker
 &lt;/span&gt;
 는 별도의 게스트
 &lt;span&gt;
  OS
 &lt;/span&gt;
 를 설치하지 않고 커널 레벨에서 격리된 가상의 공간을 제공한다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이의 장점은 호스트 운영체제와의 속도 차이가 거의 없고 가상머신보다 경량화된 상태에서 관리를 할 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/91696364/4.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 클라우드
 &lt;span&gt;
  ,
 &lt;/span&gt;
 컨테이너
 &lt;span&gt;
  ,
 &lt;/span&gt;
 마이크로서비스
 &lt;span&gt;
  , DevOps
 &lt;/span&gt;
 구조
 &lt;span&gt;
  , DZone
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 출처
 &lt;span&gt;
  :
  &lt;a class=&quot;external-link&quot; href=&quot;https://dzone.com/articles/markus-eisele-answers-questions-about-java-ee-and&quot; rel=&quot;nofollow&quot;&gt;
   https://dzone.com/articles/markus-eisele-answers-questions-about-java-ee-and
  &lt;/a&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 현재 많은 기업들이 자사의 서비스 기반을 마이크로 아키텍처 서비스로 만들고자 하면서 컨테이너 서비스를 활용하고 이에 대한 내부 기술 표준화를 위한 시도를 많이 하고 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한 개발
 &lt;span&gt;
  /
 &lt;/span&gt;
 배포
 &lt;span&gt;
  /
 &lt;/span&gt;
 운영 프로세스에 대한 부분을 컨테이너 서비스를 통해 일원화하기 위한 노력도 병행하고 있습니다
 &lt;span&gt;
  . MSA(Micro Service Architecture)
 &lt;/span&gt;
 를 컨테이너 기반으로 구성하는데 있어 프로세스화 되어야 하는 부분은
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 영역입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 컨테이너는 이러한
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 영역에 대한 부분을 통합할 수 있도록 하는 좋은 방법 중의 하나입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 컨테이너는 개발과 운영이라는 두 팀간의 장벽을 허무는
 &lt;span&gt;
  DevOps
 &lt;/span&gt;
 의 가교 역할을 하게 되며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 두 팀이 함께 협업하여 개발자 생산성과 운영의 안정성이라는 두 마리 토끼를 잡게 해줍니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그러한 관점에서 인프라
 &lt;span&gt;
  ,
 &lt;/span&gt;
 컨테이너
 &lt;span&gt;
  ,
 &lt;/span&gt;
 미들웨어 컴포넌트를 컨테이너화함으로써 클라우드 네이티브 형태의 애플리케이션을 만들 수 있습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한 기업이 가진 업무 시스템을 최적화하는 방법으로 컨테이너화된 다양한 오픈소스 기술을 활용하여 비즈니스적인 목표를 달성할 수도 있다
 &lt;span&gt;
  .
 &lt;/span&gt;
 이를 도식화한 간략한 그림은 아래와 같습니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/91696364/5.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그림
 &lt;span&gt;
  .
 &lt;/span&gt;
 클라우드 네이티브 영역 지도
 &lt;span&gt;
  (
  &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/cncf/landscape&quot; rel=&quot;nofollow&quot;&gt;
   https://github.com/cncf/landscape
  &lt;/a&gt;
 &lt;/span&gt;
 의 도식도를 축약한 것임
 &lt;span&gt;
  )
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 그림에서 보는 것처럼 컨테이너 서비스는 그 기반이 퍼블릭과 프라이빗과 상관없이 작동시키며 프로비저닝 자동화
 &lt;span&gt;
  ,
 &lt;/span&gt;
 프로세스 개선
 &lt;span&gt;
  , DevOps
 &lt;/span&gt;
 를 활용할 수 있는 기반을 마련해줍니다
 &lt;span&gt;
  .
 &lt;/span&gt;
 또한 조직이 소프트웨어 개발과 인프라 관리 프로세스의 자동화 및 간소화를 통해 더 빠르게 혁신할 수 있도록 지원하며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 이를 통한 비즈니스 이익이 극대화될 수 있도록 도와줍니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 컨테이너
 &lt;span&gt;
  , PaaS, DevOps
 &lt;/span&gt;
 는 상호 연결된 밀접한 단어이다
 &lt;span&gt;
  .
 &lt;/span&gt;
 아직
 &lt;span&gt;
  IaaS
 &lt;/span&gt;
 를 기반으로 한 클라우드
 &lt;span&gt;
  (
 &lt;/span&gt;
 퍼블릭
 &lt;span&gt;
  /
 &lt;/span&gt;
 클라우드
 &lt;span&gt;
  )
 &lt;/span&gt;
 에 대한 경험이 없는 상태라 하더라도 기획을 해볼 수 있는 중요한 아이템이 바로 컨테이너 기반
 &lt;span&gt;
  PaaS
 &lt;/span&gt;
 영역이다
 &lt;span&gt;
  .
 &lt;/span&gt;
 인프라 자동화
 &lt;span&gt;
  , DevOps, MSA
 &lt;/span&gt;
 등의 단어를 의식하고 있다면 클라우드 기반의 컨테이너 서비스 대한 적극적 검토를 해보아야 하며
 &lt;span&gt;
  ,
 &lt;/span&gt;
 향후 펼쳐지게 될
 &lt;span&gt;
  IT
 &lt;/span&gt;
 시스템의 변화에 대한 준비를 해야 할 것입니다
 &lt;span&gt;
  .
 &lt;/span&gt;
&lt;/p&gt;</description>
        <pubDate>Wed, 25 Mar 2020 00:00:00 +0900</pubDate>
        <link>https://tech.osci.kr/2020/03/25/91696364/</link>
        <guid isPermaLink="true">https://tech.osci.kr/2020/03/25/91696364/</guid>
        
        <category>클라우드</category>
        
        <category>docker</category>
        
        <category>cncf</category>
        
        <category>msa</category>
        
        
      </item>
    
  </channel>
</rss>
